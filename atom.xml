<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刘浩的技术博客]]></title>
  <link href="http://liuhaoxiu.github.io/atom.xml" rel="self"/>
  <link href="http://liuhaoxiu.github.io/"/>
  <updated>2016-08-04T16:23:22+08:00</updated>
  <id>http://liuhaoxiu.github.io/</id>
  <author>
    <name><![CDATA[刘浩]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实现独特APP特性的策略]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/08/03/shi-xian-du-te-appte-xing-de-ce-lue/"/>
    <updated>2016-08-03T16:44:37+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/08/03/shi-xian-du-te-appte-xing-de-ce-lue</id>
    <content type="html"><![CDATA[<h1>实现特定APP特性的策略(Strategies for Implementing Specific App Features)</h1>

<p>不同的APP有不同的需要，但是有一些行为对于许多的APP是共同的。接下来的块提供了指导关于在你的APP中实现特定的特性。</p>

<h2>隐私策略(Privacy Strategies)</h2>

<p>在设计一个APP的时候保护用户的隐私是一个重大的考虑。隐私保护包含了保护用户数据，用户身份和个人信息。系统框架已经提供了关于管理数据的隐私框架，例如联系人，但是你的APP应该采取措施去保护你的本地使用的数据。</p>

<h3>保护数据使用在磁盘加密(Protecting Data Using On-Disk Encryption)</h3>

<p>数据保护使用内置硬件使用一个加密的格式去存储文件到磁盘，需要它们的时候再解密。在用户锁定屏幕期间，保护文件是访问不到的，即使是创建它们的APP也不行。你个APP能够访问一个它保护的文件必须是这个设备不是屏幕锁定的(通过键入适当的密码解锁)。</p>

<p>数据保护在大部分iOS设备是可用的，但需要服从以下的要求：</p>

<ul>
<li>在用户设备上的文件系统必须支持数据保护.大部分设备支持这个行为.</li>
<li>这个用户必须有有效的密码用于锁定这个设备.</li>
</ul>


<p>去保护一个文件，你添加一个特性到这个文件只是所需要的保护等级。添加这个特性使用<code>NSData</code>类或者<code>NSFileManager</code>其中的一个。当写一个新文件，你能使用<code>NSData</code>的<code>writeToFile:options:error:</code>方法并用一个合适的值作为写选项参数。关于现存的文件，你能使用<code>NSFileManager</code>的<code>setAttributes:ofItemAtPath:error:</code>方法去设置或者改变 <code>NSFileProtectionKey</code>的值。当使用这些方法，给你文件指定一个以下的保护等级。</p>

<ul>
<li>没有保护——这个文件是加密的但是没有通过密码保护，在这个设备锁定期间是可用的。指定<code>NSDataWritingFileProtectionNone</code>选项(<code>NSData</code>)或者<code>NSFileProtectionNone</code>属性(<code>NSFileManager</code>).</li>
<li>完全的保护——这个文件是加密的，在设备锁定期间是不可访问的。指定 <code>NSDataWritingFileProtectionNone</code>选项(<code>NSData</code>)或者<code>NSFileProtectionNone</code>属性(<code>NSFileManager</code>).</li>
<li>完全保护但是除了已经打开的文件——这个文件是加密的。在设备锁定期间一个关闭的文件是不可访问的。用户解锁这个设备之后，你的APP能够打开这个文件并使用它。在文件打开期间用户锁定了设备你的APP能继续去访问它。指定<code>NSDataWritingFileProtectionCompleteUnlessOpen</code>选项(<code>NSData</code>)或者<code>NSFileProtectionCompleteUnlessOpen</code>属性(<code>NSFileManager</code>).</li>
<li>完全保护直到第一次登录——这个文件是加密的，这个设备启动后文件是不可访问的，用户一旦解锁这个设备文件就可以访问了。指定 <code>NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication</code>选项(<code>NSData</code>)或者<code>NSFileProtectionCompleteUntilFirstUserAuthentication</code>属性(<code>NSFileManager</code>).</li>
</ul>


<p>如果你保护一个文件，你的APP必须准备去失去对这个文件的访问。当完全的文件保护启用时，当用户锁定屏幕你的APP失去了读写这个文件内容的能力。你能使用接下来的技术跟踪保护文件状态的改变。</p>

<ul>
<li>实现APP代理的<code>applicationProtectedDataWillBecomeUnavailable:</code>和 <code>applicationProtectedDataDidBecomeAvailable:</code>方法。</li>
<li>任何对象能够注册<code>UIApplicationProtectedDataWillBecomeUnavailable</code>和 <code>UIApplicationProtectedDataDidBecomeAvailable</code>通知。</li>
<li>任何对象能够验证<code>UIApplication</code>共享对象的<code>protectedDataAvailable</code>属性值去确定当前文件是否是可访问的。</li>
</ul>


<p>关于新文件，在写任何数据到这个文件之前你去启用数据保护是被推荐的。如果你使用<code>writeToFile:options:error:</code>方法去写一个<code>NSData</code>对象内容到磁盘，这个是保护自动发生的。关于现存的文件，用一个新的数据版本添加数据保护去替换一个未保护的文件。</p>

<h3>识别你的APP的独特用户(Identifying Unique Users of Your App)</h3>

<p>仅仅在你去识别你的APP的一个用户能够提供一个明显的好处给你的用户的时候你才应该去做这个。你如果仅仅需要去区分你的APP的一个用户是不是来自另外一个，iOS提供了标识符能够帮助你去做这个。无论如何，如果你需要一个高的安全级别，你可能需要自己做更多的工作。</p>

<p><code>Important：当识别一个用户时，总是明确的关于你想要用你获得的信息做什么。识别用户是不可接受的，这样你能秘密的跟踪它们.</code></p>

<p>这里是一些你需要去识别用户的常用的场景，以下是一些关于如何实现它们和一些解决方案.</p>

<ul>
<li>你想去链接一个用户到一个特定的账户。包含一个登录屏幕需要用户去键入它们的安全账户信息。总是保护你收集来自用户的账户信息通过加密的形式去存储。</li>
<li>你想去区分你的APP实例运行去不同的设备上。使用<code>UIDevice</code>类的<code>identifierForVendor</code>属性去获取一个<code>ID</code>，这个用于区别在不同设备的的同一个用户。这个技术现在允许你去识别特定的用户。当个用户可能有多个设备，在每个设备上有不同的<code>ID</code>值。</li>
<li>你想去识别关于广告目的的用户。使用<code>ASIdentifierManager</code>类的<code>advertisingIdentifier</code>属性去获取关于这个用户的<code>ID</code>。</li>
</ul>


<p>因为用户是允许去运行APP到他们所有的iOS设备上的，Apple不提供一个方法去识别同样的用户在多个设备上，如果你需要去识别一个特定的用户，你必须提供你自己的解决方案使用通用的唯一<code>IDs</code>(<code>UUIDS</code>),一个登录账户，或者一些另外的身份识别类型系统。</p>

<h2>关于限制(Respecting Restrictions)</h2>

<p>用户能够设置限制，指定想去在你的APP中使用的媒体的等级。如果你的APP播放媒体或者修改基于限制的行为，你需要去确定当前的设置和去响应设置的改变。(访问限制就是用户可以在通用里面设置不同国家和地区的对你的APP所包含内容的访问限制，你可以选择那些内容是可以看到，那些APP是可以运行的，这个是分级制度保护不同阶段的人看到不同的内容，比如儿童可以设置一下限制级的内容限制访问)。</p>

<p>去获得当前的设置，获得共享对象<code>standardUserDefaults</code>和使用它的<code>objectForKey:</code>方法去查看以下键的值：</p>

<ul>
<li><code>com.apple.content-rating.ExplicitBooksAllowed</code> <code>Boolean</code>。如果这个键的值是NO，明确书是不允许的。</li>
<li><code>com.apple.content-rating.ExplicitMusicPodcastsAllowed</code> <code>Boolean</code>。如果这个键的值是NO，明确音乐内容，电影，和播客是不允许的。</li>
<li><code>com.apple.content-rating.AppRating</code> <code>NSNumber</code>。这个键的值在0到1000的范围内。一个APP的等级比这个当前的键值高是不被允许的。</li>
<li><code>com.apple.content-rating.MovieRating</code> <code>NSNumber</code>。这个键的值在0到1000的范围内。一个电影的等级比这个当前的键值高是不被允许的。</li>
<li><code>com.apple.content-rating.TVShowRating</code> <code>NSNumber</code>。这个键的值在0到1000的范围内。一个电视节目的等级比这个当前的键值高是不被允许的。</li>
</ul>


<p><code>Note:关于一个指定的键如果objectForKey:返回nil，它意味着关于这个特定限制的信息是无法拿到的。在这种情况下，你的APP能够使用它自己的策略去确定适当的分级。</code></p>

<p>去发现用户对限制的改变，注册<code>NSUserDefaultsDidChangeNotification</code>通知。当发现一个持久域中本地偏好设置改变这个共享对象<code>standardUserDefaults</code>发送这个通知到你的APP。</p>

<h2>支持多个iOS版本(Supporting Multiple Versions of iOS)</h2>

<p>一个APP支持最新的iOS版本加一个或者多个以前的版本必须使用运行时检查去阻止在旧的iOS版本上使用新的APIs.当你的APP尝试使用一个在当前操作系统上不能获得的特性时运行时检查防止你的APP崩溃。</p>

<p>这些是几种你能做的检查类型：</p>

<ul>
<li>去确定是否一个类存在，看是否<code>Class</code>对象返回<code>nil</code>。链接器对于所有未知的类对象都返回<code>nil</code>,使用一个条件检查就像以下这样：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="bp">UIPrintInteractionController</span> <span class="k">class</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Create an instance of the class and use it.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// The print interaction controller is not available so use an     alternative technique.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>去确定一个方法在一个现有的类是否可以获取，使用<code>instancesRespondToSelector:</code>类方法或者<code>respondsToSelector:</code>实例方法。</li>
<li>去确定一个基于C的函数是否可以使用，执行这个函数去和<code>NULL</code>比较返回一个布尔值。如果不为<code>NULL</code>，你能调用这个函数。如下：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">UIGraphicsBeginPDFPage</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">UIGraphicsBeginPDFPage</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>保存你的APP的视觉外观(Preserving Your App’s Visual Appearance Across Launches)</h2>

<p>即使你的APP支持后台执行，它也不可能永远运行。在一些点，系统可能需要终结你的APP释放内存给当前的前台APP使用。无论如何，用户应该绝不关心一个APP已经运行还是已经终结。从用户的角度看，退出一个APP应该恰恰看起来像是一个临时中断。当用户返回到一个APP时，APP应该总是返回到用户使用这个APP的最后位置，如此用户能继续运行中的任何任务。这个行为提供了一个好体验给用户，状态恢复支持内建到UIKit里面这个获得是相对容易的。
状态保存系统在UIKit里面提供一个简单但是灵活的结构用于保存和恢复你的APP的视图控制器和视图状态。这个结构的工作是在适当的时间去驱动保存和恢复处理。做这个，UIKit需要你的APP的帮助。只有你了解你的APP的内容，如此只有你能写去保存和恢复这个内容的代码。当你更新你的APP用户界面时，只有你知道如何在你的界面去映射旧的保存内容到一个新的对象。</p>

<p>这里是三个地方，在这里你去考虑状态保存在你的APP里。</p>

<ul>
<li>你的APP代理对象，管理APP的最高级别的状态</li>
<li>你的APP视图控制器对象，管理你APP全部的用户界面状态。</li>
<li>你的APP的自定义视图，可能有一些你需要保存的自定义数据。</li>
</ul>


<p>UIKit允许你去选择你想保存的用户界面部分。如果你已经有自定义的代码关于操作状态保存，你能继续使用这个代码和作为需要你能迁移部分代码到UIKit保存系统。</p>

<h3>在你的APP中启用状态保存和恢复（Enabling State Preservation and Restoration in Your App）</h3>

<p>状态保存和恢复不是一个自动特性，APP必须选择去使用它。APP表明自己支持这个特性通过在它们的APP代理中实现以下的几个方法：</p>

<ol>
<li><code>application:shouldSaveApplicationState:</code></li>
<li><code>application:shouldRestoreApplicationState:</code></li>
</ol>


<p>通常的，你实现这些方法只有返回<code>YES</code>才能表明状态保存和恢复能够发生。当然也能返回<code>NO</code>，不过状态保存和恢复不会发生。例如你的APP无法有效的去恢复状态来自一个以前的版本你就可以在<code>application:shouldRestoreApplicationState:</code>方法里返回<code>NO</code>。</p>

<h3>保存和恢复过程(The Preservation and Restoration Process)</h3>

<p>状态保存和恢复是一个可选的特性，工作需要你的APP的帮助。你的APP标识应该保存的对象，UIKit在合适的时间去做保存和恢复这些对象的工作，因为UIKit处理这么多的过程，它帮你你去明白他在幕后做了什么，如此你知道如何实现你的自定义代码去契合这个总体的方案。</p>

<p>当思考关于状态保存和恢复时，它首先帮助你去分离这两个过程。UIkit在适当的时间保存你的APP状态，例如当你APP从前台移动到后天的时候。当UIkit确定新的状态信息是必要的时候，它审视你的APP视图和视图控制去看哪一个应该被保存。关于这些对象的每一个，UIkit写保存相关的数据到一个磁盘上的加密文件。在下次你的APP重新开始启动，UIkit找到这个文件，如果它是存在的，使用它去尝试恢复你的APP状态。因为这个文件是加密的，只有在这个设备解锁的状态下状态保存和恢复才会发生。</p>

<p>在恢复过程期间，UIkit使用保存数据去重新构造你的界面但是实际对象的创造是通过你的代码操作的。因为你的APP可能自动加载一个对象来自<code>storyboard</code>文件，只有你的代码知道哪一个对象需要去创建和哪一个可能已经存在能够简单的返回。创建每一个对象之后，UIkit用保存的状态信息初始化它们。</p>

<p>在保存和恢复处理期间，你的APP有少数的责任。</p>

<ul>
<li><p>在保存期间，你的APP的职责：</p>

<ol>
<li>告诉UIkit它支持状态保存。</li>
<li>告诉UIkit那个视图控制和视图应该保存。</li>
<li>为任何保存的对象编码相关的数据。</li>
</ol>
</li>
<li><p>在恢复处理期间，你的APP的职责：</p>

<ol>
<li>告诉UIkit它支持状态恢复。</li>
<li>提供(或创建)UIkit要求的对象。</li>
<li>解码你保存的对象状态和使用它去返回这个对象到它以前的状态。</li>
</ol>
</li>
</ul>


<p>你的APP的责任，最重要的是告诉UIkit那些对象要保存和之后的启动提供这些对象。这两个行为是在你设计你的APP的保存和恢复代码的时候应该花费你最多时间的地方。他们同样是你在这个实际过程中有最多控制的地方。去明白为什么是这个样子的。
UIkit只保存已经分配了恢复标识的对象。一个恢复标识是一个字符串，这个标识视图或者视图控制器，这个字符串的值仅仅对于你的代码有意义，但是这个字符串的存在告诉UIkit它需要去保存这个标记的对象。在保存处理期间，UIkit走你的APP视图控制器层级，保存所有的有恢复标识的对象。如果一个视图控制器没有一个恢复标识，这个视图控制器和所有它的视图和子视图控制器是不保存的。</p>

<p>根据你的APP，它可能有或者没有去保存每一个视图控制器的场景。如果一个视图控制器去呈现一个短暂的信息，你可能在恢复的时候不想返回到这个相同的点，而且选择返回到你的界面的一个稳定的点。</p>

<p>关于你选择去保存的每一个视图控制器，你同样需要去决定之后你想如何去恢复它。UIkit提供两个方法去重建对象。你能让你的APP代理重建它或者你能分配一个恢复类给这个视图控制器和让这个类重建它。一个恢复类(<code>restoration class</code>)实现<code>UIViewControllerRestoration</code>协议和它的职责是关于在恢复时间寻找或者创建一个指定的对象。这里有一些小技巧：</p>

<ul>
<li>如果视图控制器在启动时间总是从你的APP的主<code>storyboard</code>加载，不要分配一个恢复类。作为替代，让你的APP找到这个对象或者利用UIkit支持隐式查找恢复对象。</li>
<li>如果视图控制器在启动时间不从你的APP的主<code>storyboard</code>加载，分配一个恢复类。这个简单的选择是去为每一个视图控制器制作它自己的恢复类。</li>
</ul>


<p>在保存过程期间，UIkit标识这个对象去保存和写每一个受影响的对象状态到磁盘。每一个视图控制器对象给一个机会去写出任何他想要去保存的数据。</p>

<p>在下次APP启动后，UIkit照例加载APP的主<code>storyboard</code>或者<code>nib</code>文件，调用APP代理<code>application:willFinishLaunchingWithOptions:</code>方法，尝试去恢复APP以前的状态。这个第一件事是询问你的APP提供的视图控制器对象集合用于去匹配那个是保存了的。如果给的视图控制器有一个指定的恢复类，询问这个类去提供这个对象；否则，询问APP的代理提供这个对象。</p>

<h4>保存的处理流程(Flow of the Preservation Process)</h4>

<p>保存甚至发生之前，UIkit询问你的APP代理如果它应该发生就通过调用<code>application:shouldSaveApplicationState:</code>方法。如果这个方法返回值为<code>YES</code>，UIkit开始收集和编码你的APP视图和视图控制器。当这个过程结束，它写编码后的数据到磁盘。
在下次你的APP启动，系统自动找寻一个保存状态文件，如果存在，使用它去恢复你的界面。因为这个状态信息是只与你的APP在以前状态和当前启动周期相关的，这个文件在你的APP结束启动之后通常会被丢弃。这个文件同样在任何时间恢复你的APP有一个错误发生时被丢弃。例子，如果你的APP在恢复处理期间崩溃，系统自动扔掉这个状态信息避免在下一次启动周期再次发生崩溃。</p>

<h4>恢复的处理流程(Flow of the Restoration Process)</h4>

<p>在标准初始化和UI加载完成之后，UIkit询问你的APP代理，如果状态恢复应该发生通过调用<code>application:shouldRestoreApplicationState:</code>方法。这个是你的APP代理去检查保存数据和确定状态恢复是否可能的机会。如果它是，UIkit使用APP代理和恢复类去获取到你的APP视图控制器的引用。每一个对象去提供它需要的数据去恢复它自己到它以前的状态。
尽管UIkit帮助恢复单独的视图控制器，它不自动恢复这些视图控制器之间的联系。作为替代，每一个视图控制器有责任去编码足够多的状态信息用于返回它自己到以前的状态。例子，一个导航控制器编码信息关于在它的导航栈上视图控制器的顺序。它使用这个信息在之后去返回这些视图控制器到它们以前在导航栈的位置。其他的视图控制器有嵌入子视图控制器有同样的责任关于编码任何它们需要的信息用于之后去恢复它们的子类。</p>

<p><code>Note:不是所有的视图控制器需要去编码它们的子视图控制器，例如tab bar控制器就不.作为替代，它假设你的APP遵循通常的模式，在创建tab bar控制器之前创建恰当的子视图控制器.</code></p>

<p>因为你的的职责是关于重建你的APP视图控制器，在恢复处理期间你有一定的灵活性趣改变你的界面。例如，你能够重排序一个<code>tab bar</code>控制器中的<code>tab</code>和仍然使用保存数据去返回每一个<code>tab</code>到它以前的状态。当然，如果你对你的视图控制器层级做了巨大的更改，例如在一个应用程序更新期间，你可能不能使用保存数据。</p>

<h3>当你被逐出了视图控制器组时发生了什么(What Happens When You Exclude Groups of View Controllers?)</h3>

<p>当一个视图控制器的标识符为<code>nil</code>,这个视图控制器和它管理的任何子视图控制器是不自动保存的。</p>

<p>即使你决定不保存视图控制器,这么做不意味着这些所有的视图控制器完全从视图层级消失。在启动时间，你的APP可能仍然创建这个视图控制器作为默认设置的一部分。例如，如果任何视图控制器是自动加载来自于你的APP的<code>storyboard</code>文件，他们将仍然出现，虽然是在他们默认的配置(或者说状态).</p>

<p>有些事需要了解的是，即使一个视图控制器没有自动保存，你还可以编码对这个视图控制器的引用然后手动保存它。</p>

<h3>实现状态保存和恢复清单(Checklist for Implementing State Preservation and Restoration)</h3>

<p>支持状态保存和恢复需要修改你的APP的代理和视图控制器对象去编码和解码这个状态信息。如果你的APP有任何自定义的视图并且同样有可保存的状态信息，你也需要去修改这些对象。</p>

<p>当添加状态保存和恢复到你的代码的时，使用以下列表来提醒你需要些的代码.</p>

<ul>
<li>(必须)在你的APP代理实现<code>application:shouldSaveApplicationState:</code>和<code>application:shouldRestoreApplicationState:</code>方法.</li>
<li>(必须)分配恢复标识符到每一个你想去保存的视图控制器，做法是分配一个非空字符串到它们的<code>restorationIdentifier</code>属性.如果你也想去保存指定视图的状态，分配非空字符串到它们的<code>restorationIdentifier</code>属性.</li>
<li>(必须)在你的APP代理<code>application:willFinishLaunchingWithOptions:</code>方法中显示你的<code>window</code>.这个状态恢复系统需要这个<code>window</code>，如此它能恢复滚动位置和另外的与你的界面相关的一些东西。</li>
<li>指定对恰当视图控制器的恢复类.(如果没有这个，你的APP代理在恢复时间被询问去提供相应的视图控制器).</li>
<li>(推荐)编码和解码你的视图和视图控制器的状态，使用这些对象的<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法.</li>
<li>对于你的APP的任何版本信息或者额外的状态信息进行编码和解码，使用你的APP的代理<code>application:willEncodeRestorableStateWithCoder:</code>和<code>application:didDecodeRestorableStateWithCoder:</code>方法.</li>
<li>作为<code>table view</code>和<code>collection view</code>数据源的对象应该实现<code>UIDataSourceModelAssociation</code>协议.尽管这不是必须的，这个协议帮助保存在这些视图类型中的选中项和显示项.</li>
</ul>


<h3>保存你的视图控制器状态(Preserving the State of Your View Controllers)</h3>

<p>保存你的APP视图控制器状态应该是你主要的目标.视图控制器定义你的用户界面的结构.它们管理需要在界面上呈现的视图和协调支持的视图的数据的获取和设置.去保存一个单独的视图控制器状态，你必须做以下这些：</p>

<ul>
<li>(必须)分配一个恢复标识符到这个视图控制器.</li>
<li>(必须)在启动时间提供代码去创建或者定位新的视图控制器.</li>
<li>(可选)实现<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法去编码和恢复在下一次启动期间不能再现的状态信息.</li>
</ul>


<h4>标记你要保存的视图控制器(Marking Your View Controllers for Preservation)</h4>

<p>UIkit仅仅保存在视图控制器<code>restorationIdentifier</code>属性包含一个有效字符串对象的视图控制器.你知道你想去保存的视图控制器，当你初始化这个视图控制器对象时设置这个属性值.如果你的视图控制器是加载来自一个<code>storyboard</code>或者<code>nib</code>文件，你能在哪里设置这个恢复标识.</p>

<p>选择一个恰当的值作为恢复标识(<code>restoration identifiers</code>)是重要的.当这个恢复处理期间，你的代码使用这个恢复标识去确定那个视图控制器去寻回(<code>retrieve</code>)或者创建.如果每一个视图控制器对象是基于一个不同的类，你能使用类名作为恢复标识。无论如何，如果你的视图控制器层级包含了一个相同类的多个实例，你可能需要对每个视图控制器使用去选择不同的名字。</p>

<p>当它请你去提供一个视图控制器时，UIkit提供给你视图控制器对象的恢复路径.一个恢复路径是在根视图控制器开始的恢复标识序列，它沿着视图控制器层级向下直到你的当前的对象。例如，假如你有一个<code>tab bar controller</code>其标识符是<code>TabBarControllerID</code>，这个第一个<code>tab</code>包含了一个导航控制器其标识符是<code>NavControllerID</code>并且其根视图控制器标识是<code>MyViewController</code>.这个根视图控制器完整的恢复路径将是<code>TabBarControllerID/NavControllerID/MyViewController</code>.</p>

<p>每一个对象的恢复路径是唯一的。如果一个视图控制器有两个子视图控制器，每一个子视图控制器必须有一个不同的恢复标识。然而，两个视图控制器有两个不同的父对象可以使用相同的恢复标识符，因为这个恢复路径的剩余部分提供了需要的唯一性。一些UIkit视图控制器，例如导航控制器，自动消除它们子视图控制器的歧义，允许你对每一个子视图控制器使用相同的恢复标识。更多关于一个给定视图控制器的行为，去看相应的类参考。</p>

<p>在恢复时间，你使用提供的恢复路径去确定那些视图控制器返回给UIkit。</p>

<h4>在启动时间恢复你的视图控制器(Restoring Your View Controllers at Launch Time)</h4>

<p>在恢复处理期间，UIkit要求你的APP去创建(或者定位)视图控制器对象这些由你保存的用户界面组成。当尝试去定位视图控制器时UIkit坚持以下的过程:</p>

<ol>
<li>如果视图控制器有一个恢复类，UIkit要求这个类去提供这个视图控制器.UIkit调用这个关联的恢复类的<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法去找回这个视图控制器。如果这个方法返回<code>nil</code>，他是假定APP不想去重建这个视图控制器然后UIkit停止寻找它。</li>
<li>如果视图控制器没有一个恢复类，UIkit请求APP代理去提供这个视图控制器.UIkit调用你的APP代理的<code>application:viewControllerWithRestorationIdentifierPath:coder:</code>方法寻找一个没有恢复类的视图控制器.如果这个方法返回<code>nil</code>，UIkit视图去找到隐式视图控制器.</li>
<li>如果一个视图控制器的正确的恢复路径已经存在，UIkit使用这个对象.如果你的APP在启动时间创建视图控制器(以编程的方式或者通过加载它们来自一个资源文件)和分配了恢复标识符给它们，UIkit会通过它们的恢复路径隐式的找到它们。</li>
<li>如果视图控制器最初从一个<code>storyboard</code>文件加载，UIkit使用保存的<code>storyboard</code>信息去定位和创建它.UIkit保存关于在恢复档案内部存在的视图控制器相关的<code>storyboard</code>信息.在恢复时间，它使用这个信息去定位相同的<code>storyboard</code>文件和如果有视图控制器通过任何另外的方法没有被找到那么实例化相应的视图控制器.</li>
</ol>


<p>值得注意的是，如果你为一个视图控制器指定一个恢复类，UIkit不会试图隐式的去寻找你的视图控制器.如果你的恢复类的<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法返回<code>nil</code>，UIkit停止尝试去定位你的视图控制器。这给你控制是否真的想去创建这个视图控制器。如果你不指定一个恢复类，UIkit会做它能够找到这个视图控制器给你的任何事，当必要时从你的APP的<code>storyboard</code>文件创建它。</p>

<p>如果你选择去使用恢复类，你实现<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法应该创建恢复类的一个新实例，执行一些最小的初始化，返回所得的对象。以下代码是一个例子显示了你可能如何使用这个方法去从一个<code>storyboard</code>加载一个视图控制器。因为视图控制器是最初从<code>storyboard</code>加载的，这个方法使用<code>UIStateRestorationViewControllerStoryboardKey</code>键去获得来自档案文件(归档)的<code>storyboard</code>。注意此方法不试图去配置这个视图控制器的数据字段。当视图控制状态解码后这一步会发生。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">UIViewController</span><span class="o">*</span><span class="p">)</span> <span class="nf">viewControllerWithRestorationIdentifierPath:</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifierComponents</span>
</span><span class='line'>                      <span class="nf">coder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">MyViewController</span><span class="o">*</span> <span class="n">vc</span><span class="p">;</span>
</span><span class='line'>   <span class="bp">UIStoryboard</span><span class="o">*</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeObjectForKey</span><span class="p">:</span><span class="n">UIStateRestorationViewControllerStoryboardKey</span><span class="p">];</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PushViewController</span><span class="o">*</span><span class="p">)[</span><span class="n">sb</span> <span class="nl">instantiateViewControllerWithIdentifier</span><span class="p">:</span><span class="s">@&quot;MyViewController&quot;</span><span class="p">];</span>
</span><span class='line'>      <span class="n">vc</span><span class="p">.</span><span class="n">restorationIdentifier</span> <span class="o">=</span> <span class="p">[</span><span class="n">identifierComponents</span> <span class="n">lastObject</span><span class="p">];</span>
</span><span class='line'>      <span class="n">vc</span><span class="p">.</span><span class="n">restorationClass</span> <span class="o">=</span> <span class="p">[</span><span class="n">MyViewController</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">vc</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上当创建一个新的视图控制器时去重新分配一个恢复标识和恢复类是一个好的习惯。最简单的恢复这个恢复标识的方法是去抓住<code>identifierComponents</code>数据的最后一项把这项分配给你的新的视图控制器(如上代码所示).</p>

<p>关于在启动时间对象已经从你的APP主<code>storyboard</code>加载了，就不要为每一个对象创建一个新实例了。作为替代，实现你APP的<code>application:viewControllerWithRestorationIdentifierPath:coder:</code>方法和使用这个方法返回恰当的对象或者让UIkit隐式的找到这些对象。</p>

<h4>编码和解码你的视图控制器状态(Encoding and Decoding Your View Controller’s State)</h4>

<p>对于每一个计划保存的对象，UIkit调用对象的<code>encodeRestorableStateWithCoder:</code>去给它一个机会保存它的状态。在这个解码处理期间，UIKit调用<code>decodeRestorableStateWithCoder:</code>方法去解码这个状态和应用状态到这个对象。这些方法的实现是可选的，但是是被推荐的，对于你的视图控制器。你可以使用它们去保存和恢复以下的信息类型：</p>

<ul>
<li>对任何被展示的数据的引用(不是数据本身)</li>
<li>用于一个容器视图控制器，对它子视图控制器的引用</li>
<li>关于当前选择的信息</li>
<li>用于具有用户可配置视图的视图控制器，关于这个可配置视图的当前配置信息。</li>
</ul>


<p>在你的编码和解码方法里面，你能编码由编码器支持的任何值，包括其他的对象。对于除视图和视图控制器之外的所有对象，这个对象必须采用<code>NSCoding</code>协议和使用这个协议的方法去写它的状态。对于视图和视图控制器，编码器不使用<code>NSCoding</code>协议的方法去保存这个对象状态对象。作为代替，编码器保存这个对象的恢复标识和添加它到可保存的对象列表，这结果在该对象的<code>encodeRestorableStateWithCoder:</code>方法里面被调用。</p>

<p>你的视图控制器的<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法应该总是在它们实现的一些点调用<code>super</code>。调用<code>super</code>给父类一个机会去保存和恢复任何额外的信息。以下的代码简单的实现了这些方法，其保存一个用于去识别指定视图控制器的数字值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">encodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">super</span> <span class="nl">encodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">[</span><span class="n">coder</span> <span class="nl">encodeInt</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">MyViewControllerNumber</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">decodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">super</span> <span class="nl">decodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeIntForKey</span><span class="p">:</span><span class="n">MyViewControllerNumber</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编码和解码处理期间编码器对象不是共享的。每个对象的可保存状态接收它自己的编码器，如此它能使用去读或者写数据。这个独特的编码器使用方式使你不用去担心在你自己的对象之间关键的命名空间冲突。然而，你必须仍然避免使用一些UIkit提供的特定键名。具体的，每一个编码器包含<code>UIApplicationStateRestorationBundleVersionKey</code>和 <code>UIApplicationStateRestorationUserInterfaceIdiomKey</code>键，它们提供了关于包版本(<code>bundle version</code>)和当前用户界面风格(<code>idiom</code>).编码器关联的视图控制器可能同样包含了<code>UIStateRestorationViewControllerStoryboardKey</code>键，这个识别视图控制器来源于哪一个<code>storyboard</code>.</p>

<h3>保存你的视图的状态(Preserving the State of Your Views)</h3>

<p>如果视图有状态值得保存，你能够保存你的APP视图控制器的剩余部分状态。因为它通常是由拥有它的视图控制器配置,大部分视图不需要保存状态信息。你唯一需要保存一个视图状态的时间是当视图能够被用户通过一种方式改变，并且这个改变是独立于它的数据和拥有它的视图控制器的。例如,<code>scroll</code>视图保存了当前的滚动位置，这个信息对于视图控制器是没有趣的但是这个会影响这个视图如何去呈现它自己。</p>

<p>指定一个视图状态应该保存，你要做以下的：</p>

<ul>
<li>分配一个有效的字符串到视图的<code>restorationIdentifier</code>属性</li>
<li>使用来自视图控制器的视图同样有一个有效的恢复标识符</li>
<li>对于<code>table views</code>和<code>collection views</code>,分配一个采用了<code>UIDataSourceModelAssociation</code>协议的数据源</li>
</ul>


<p>与视图控制器一样，分配一个恢复标识符到一个视图告诉系统这个视图有你的APP想去保存的状态。之后这个恢复标识符能同样被使用去定位这个视图。</p>

<p>像视图控制器，视图定义方法关于编码和解码它们自定义状态。如果你创建一个它的状态值得保存的视图，你能使用这些方法去读和写任何相关的数据。</p>

<h4>有可保存状态的UIKit视图(UIKit Views with Preservable State)</h4>

<p>为了保存任何视图的状态，包括自定义和标准系统视图两种，你必须分配一个恢复标识符给这个视图。视图没有一个恢复标识符UIKit是不会把它加入一个可保存对象列表的。</p>

<p>以下的UIKit视图有能被保存的状态信息：</p>

<ul>
<li><code>UICollectionView</code></li>
<li><code>UIImageView</code></li>
<li><code>UIScrollView</code></li>
<li><code>UITableView</code></li>
<li><code>UITextField</code></li>
<li><code>UITextView</code></li>
<li><code>UIWebView</code></li>
</ul>


<p>其他的框架可能同样有可保存状态的视图。关于视图是否保存状态信息和保存什么状态信息，可以看相应类的参考。</p>

<h4>保存自定义视图的状态(Preserving the State of a Custom View)</h4>

<p>如果你实现一个有可恢复状态的自定义视图，实现<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法和使用它们去编码和解码这个状态。使用这些方法去保存只有在通过其他的方式不能很容易的被重新配置的数据。例如，使用这些方法去保存用户与视图交互被修改的数据。不要使用这些方法去保存由视图去呈现的数据或者所属视图控制器能够很容易配置的任何数据。</p>

<p>如下代码显示如何去保存和恢复一个包含可编辑文本的自定义视图的选择。在这个例子里，这个选择范围是使用<code>selectionRange</code>和<code>setSelectionRange</code>去访问，这些是自定义方法，视图使用这些方法去管理选择范围。编码这些数据只需要写它们到一个提供的编码器(<code>coder</code>)对象。恢复数据需要读取这个编码器(<code>coder</code>)对象然后应用数据到这个视图。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// Preserve the text selection</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">encodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">encodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSRange</span> <span class="n">range</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">selectionRange</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">coder</span> <span class="nl">encodeInt</span><span class="p">:</span><span class="n">range</span><span class="p">.</span><span class="n">length</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLength</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">coder</span> <span class="nl">encodeInt</span><span class="p">:</span><span class="n">range</span><span class="p">.</span><span class="n">location</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLocation</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Restore the text selection.</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">decodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">super</span> <span class="nl">decodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">([</span><span class="n">coder</span> <span class="nl">containsValueForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLength</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>           <span class="p">[</span><span class="n">coder</span> <span class="nl">containsValueForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLocation</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSRange</span> <span class="n">range</span><span class="p">;</span>
</span><span class='line'>      <span class="n">range</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeIntForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLength</span><span class="p">];</span>
</span><span class='line'>      <span class="n">range</span><span class="p">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeIntForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLocation</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>         <span class="p">[</span><span class="nb">self</span> <span class="nl">setSelectionRange</span><span class="p">:</span><span class="n">range</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>实现友好保存数据源(Implementing Preservation-Friendly Data Sources)</h4>

<p>因为通过<code>table</code>或者<code>collection</code>视图显示的数据可以更改，只有这两个类实现了<code>UIDataSourceModelAssociation</code>协议才会保存当前选中项和当前显示的<code>cell</code>信息。这个协议提供了一个关于<code>table</code>或者<code>collection</code>视图去识别它所包含的不依赖该内容的索引路径(<code>index path</code>)的内容。如此，在下一个启动周期期间不管这个数据源(<code>data source</code>)放置一个项(<code>item</code>)在哪里，这个视图仍然有所有的它需要去定位相应项(<code>item</code>)的信息。</p>

<p>为了成功的实现<code>UIDataSourceModelAssociation</code>协议，你的数据源对象必须能确定在APP随后启动之间的项(<code>items</code>).这个意味着你设计的任何识别方案对于一个给定的数据块必须是不变的。这个是必不可少的，因为数据源(<code>data source</code>)每次请求同样的标识符必须能寻回同样的数据块。实现这个协议本身是一个数据项到它唯一<code>ID</code>的关系映射，之后通过这种映射再次返回相应项。</p>

<p>APP使用<code>Core Data</code>利用对象标识符能实现这个协议。每一个对象在<code>Core Data</code>里储存有一个唯一对象标识符，这个能够被转换成一个<code>URL</code>，之后可以使用这个<code>URL</code>去定位这个对象。如果你的APP不使用<code>Core Data</code>，如果你想去支持你视图的状态保存那么你需要去设计你自己唯一标识的形式。</p>

<p><code>Note:记住实现UIDataSourceModelAssociation协议是只必须(only necessary)去保存属性(attributes)例如在一个table或者collection视图的当前选择项。这个协议不用于保存由你的数据源(data source)管理的实际数据。这个是你APP的责任，去确保它的数据在恰当的时间保存。</code></p>

<h3>保存你的APP高等级状态(Preserving Your App’s High-Level State)</h3>

<p>除了由你的APP的视图控制器和视图保存数据之外，UIkit提供钩子给你去保存任何你的APP所需要的各种各样的数据。具体的,<code>UIApplicationDelegate</code>协议包含了以下的方法给你覆盖：</p>

<ul>
<li><code>application:willEncodeRestorableStateWithCoder:</code></li>
<li><code>application:didDecodeRestorableStateWithCoder:</code></li>
</ul>


<p>如果你的APP包含的状态不被视图控制器所拥有，但是需要去保存，你能使用前面的方法去保存和恢复它。<code>application:willEncodeRestorableStateWithCoder:</code>方法在保存过程一开始被调用，如此你能写出任何高级别的APP状态，例如你的用户界面的当前版本。<code>application:didDecodeRestorableStateWithCoder:</code>方法在恢复状态结束时被调用，如此你能解码任何数据和执行任何你的APP需要的最后的清理。</p>

<h3>保存和恢复状态信息技巧(Tips for Saving and Restoring State Information)</h3>

<p>当你添加状态保存和恢复到你的APP，考虑以下的指导：</p>

<ul>
<li>编码版本信息以及你的APP状态的其余部分。当保存过程期间，建议你编码一个版本字符串或者数字作为标识你的APP用户界面的当前版本。你能在你的APP代理<code>application:willEncodeRestorableStateWithCoder:</code>方法中编码这个状态。当你的APP代理 <code>application:shouldRestoreApplicationState:</code>方法被调用，你能从提供的编码器(<code>coder</code>)找回这个信息和使用它去确定是否状态保存是可能的。</li>
<li>在你的APP状态里不要包含来自你数据模型(<code>data model</code>)的对象.APP应该继续去保存它们的数据分别在云(<code>iCloud</code>)或者在磁盘上的本地文件。绝不使用状态恢复系统去保存这个数据。在一个恢复操作期间如果有问题发生保存的界面数据可能被删除。因此，任何你写到磁盘的保存相关的数据应该考虑清除。</li>
<li>状态保存系统期望你按照这种方式去使用视图控制器，它们是设计去被使用的。视图控制器层级是通过一个视图控制器包含的组合创建的，并由另一个视图控制器去呈现一个视图控制器。如果你的APP通过另外一种方式显示一个视图控制器的视图，例如添加它到一个另外的视图且没有在相应的视图控制器中间创建包含关系——这个保存系统将不能去找到你的视图控制器去保存它。</li>
<li>记住，你可能不想去保存所有的视图控制器。有时候，它可能没有去保存一个视图控制器的意义。例如，当显示一个视图控制器去改变用户密码的时候，如果用户离开了你的APP，你可能想去取消这个操作和恢复APP到以前的屏幕。在这种情况，你将不保存那个要求新密码信息的视图控制器。</li>
<li>在恢复过程期间避免交换视图控制器类。状态保存系统编码它保存的视图控制器类。在恢复期间，如果你的APP返回一个对象，这个对象的类和(或者不是一个子类)这个原来的对象不匹配，这个系统不要求视图控制器去解码任何状态信息。如此，将旧的视图控制器换成一个完全不同的视图控制器并且不恢复这个对象的全部状态。</li>
<li>当用户强制退出这个APP时系统自动删除APP保存的状态。当APP被终结(<code>killed</code>)时删除保存的状态信息是一个安全的预防措施。(作为一种安全的预防措施，如果APP在启动期间崩溃两次系统同样删除保存的状态)，如果你想去测试你的APP恢复状态的能力，在调试时(<code>debugging</code>)你不应该使用多任务栏(<code>multitasking bar</code>)去终结这个APP。作为替代，使用<code>Xcode</code>去<code>Kill</code>这个APP或者通过安装一个临时命令以编程的方式<code>kill</code>这个APP或者手势去调用<code>exit</code>根据需要.</li>
</ul>


<p><img src="state_vc_hierarchy_preserve.png" alt="图片" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用工具规范OC代码样式]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/29/yong-gong-ju-gui-fan-ocdai-ma-yang-shi/"/>
    <updated>2016-07-29T15:13:14+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/29/yong-gong-ju-gui-fan-ocdai-ma-yang-shi</id>
    <content type="html"><![CDATA[<h1>规范OC代码样式</h1>

<p>在团队开发过程中，可能你team里面的每个成员都有自己不同的代码风格，其实代码风格到不是一定要很规范，但是一定要很统一，这样整体的代码在是视觉上就不会显得很混乱，而且互相阅读代码的时候也会很自然。这篇文章是来安装适当的工具强制team成员形成统一的代码样式。</p>

<h2>安装Xcode插件用于格式化你的代码到相应的范式</h2>

<p><a href="https://github.com/benoitsan/BBUncrustifyPlugin-Xcode">这里</a>这里有一个插件，安装完后你就可以在Xcode的菜单中找到响应的格式化命令了。安装可以选择在终端运行</p>

<pre><code>    curl -SL https://raw.githubusercontent.com/benoitsan/
    BBUncrustifyPlugin-Xcode/master/install.sh | sh
</code></pre>

<p>自动下载安装。(也可以使用插件目录中提到的另外两种安装方法)</p>

<p>安装完成后，如果重启Xcode可以看到菜单<code>Edit &gt; Format Code</code>中的以下命令：</p>

<ol>
<li>使用<code>Format Selected Files</code>去格式化在项目导航中选定的文件。</li>
<li>使用<code>Format Active File</code>去格式化在编辑器中实际打开的文件。</li>
<li>使用<code>Format Selected Lines</code>去格式化选中的代码行(多行选中时支持的)。如果选中的行没有满选会自动扩展的整行，如果没有选中任何行，就会使用光标下的行作为格式化。</li>
<li>使用<code>Edit Configuration</code>在一个额外的编辑器去配置这个格式化程序。</li>
<li>使用<code>BBUncrustifyPlugin Preferences</code>去改变插件参数配置。</li>
</ol>


<h2>UncrustifyX可视化配置你的代码规范</h2>

<p>你想要的代码规范是怎么样的，你可以参考<a href="http://uncrustify.sourceforge.net/">这里</a>去直接编辑文件设置你要的格式，你也可以使用UncrustifyX这个可视化工具配置，推荐后者，这样会有感官。你可以到<a href="https://github.com/ryanmaxwell/UncrustifyX/releases">这里</a>下载最新版本安装。</p>

<h2>git commit hooks(这里使用Git版本控制)</h2>

<p><a href="https://github.com/githubbrowser/Pre-commit-hooks">这里</a>有已经写好的<code>pre-commit-uncrustify(rename为pre-commit)</code>、<code>canonicalize_filename.sh(一个定位路径输出的文件)</code>可以下载，把这个两个文件<code>copy</code>到你的本地项目仓库的<code>.git/hooks</code>文件夹下面,值此就可以生效了，不过别忘了做一下配置，像如下的：</p>

<ol>
<li>设置uncrustify的路径像我这里的的路径为<code>/Applications/UncrustifyX.app/Contents/Resources/uncrustify</code>.</li>
<li>设置uncrustify配置位置，我这里路径为<code>$HOME/.uncrustify/uncrustify.cfg</code>.</li>
</ol>


<h2>git receive hooks</h2>

<p><code>commit</code>可能还不能满足要求，我们为了统一代码规范，需要在<code>git</code>服务端检查，规范不符合我们团队的我们就拒绝<code>push</code>,所以需要在<code>receive</code>的时候也触发调用。<a href="">这里</a>这里有我自己参考资料改的一个<code>pre-receive</code>文件可以达到上述要求，你下载完成后把<code>pre-receive</code>、<code>canonicalize_filename.sh</code>一并<code>copy</code>到服务端你的项目仓库的hooks目录下面,至此就会生效了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理APP状态转换的策略]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/22/chu-li-appzhuang-tai-zhuan-huan-de-ce-lue/"/>
    <updated>2016-07-22T16:01:54+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/22/chu-li-appzhuang-tai-zhuan-huan-de-ce-lue</id>
    <content type="html"><![CDATA[<h1>处理APP状态转换的策略(Strategies for Handling App State Transitions)</h1>

<p>  对于每一个APP可能的运行时状态，你的APP在进入每一个状态的时候系统都有不同的预期。但状态迁移发生时，系统通知这个APP对象，这个APP对象通知它自己的代理对象。你能使用<code>UIApplicationDelegate</code>协议的状态迁移方法去发现这些状态的改变和作出适当的响应。</p>

<h2>在APP启动时间做些什么(What to Do at Launch Time)</h2>

<p>  当你的APP已经启动(无论是进入前台和是后台)，使用你的APP代理方法<code>application:willFinishLaunchingWithOptions:</code>和 <code>application:didFinishLaunchingWithOptions:</code>去做一下这些。</p>

<ul>
<li>检查启动选项字典的内容得到关于为什么这个APP已经启动信息并作出适当的响应。</li>
<li>初始化你的APP关键的数据结构。</li>
<li><p>准备你的APP作为显示的窗体(window)和视图(views)</p>

<p>在启动时间，系统自动加载你的APP的主故事板(storyboard)文件和加载初始的视图控制器(view controller)。关于APP支持的状态恢复，在调用<code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法中间，APP状态恢复机械的恢复你的界面到以前的状态。使用<code>application:willFinishLaunchingWithOptions:</code>方法去显示你的APP窗体(window)和去确定状态恢复是否全部发生。使用<code>application:didFinishLaunchingWithOptions:</code>方法去对你的APP界面做最后的调整。</p>

<p>你的<code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法中应该做尽可能少的事情去减少你的APP的启动时间。APP是预期去启动初始化它们自己并在五秒之内开始处理事件。如果一个APP没有及时的结束它的启动周期，系统会终止它。所以，任何可能减慢你的启动的任务(例如访问网络)应该安排它执行在一个次要的线程上。</p></li>
</ul>


<h3>启动周期(The Launch Cycle)</h3>

<p>  当你的APP已经启动，它从没运行状态(not running)进入到活动状态(active)或者后台状态(background)，迁移短暂的进入到不活动状态作为过渡(inactive)。作为启动周期的一部份，系统为你的APP创建一个过程和主线程并在主线程上调用你APP的主函数(main function)。进来这个默认的主函数随着你的Xcode项目迅速的传递控制到UIKit框架上面，这个主函数大部分的工作是初始化你的APP和为APP运行做准备。
  当你的APP启动进入后台(background)时-通常去处理一些后台事件类型，和启动进入前台主要不同的是你的APP不是活动的(active),它进入后台状态去操作事件，在操作完时间之后可能会在任何时间挂起。当启动进入后台时，系统任然加载你的APP用户界面文件但是它不显示APP窗体(window)。
   去确定你的APP是进入前台还是后台，在你的<code>application:willFinishLaunchingWithOptions:</code>或者<code>application:didFinishLaunchingWithOptions:</code>代理方法中检查共享的<code>UIApplication</code>对象的<code>applicationState</code>属性值。当你的APP是进入的前台，这个属性值是<code>UIApplicationStateInactive</code>。当你的APP启动进入了后台，这个属性值是<code>UIApplicationStateBackground</code>，你能使用这个值去调整你的代理方法做相应的启动时间行为。</p>

<h3>横屏模式启动(Launching in Landscape Mode)</h3>

<p>  APP只有使用横屏模式启动它们的界面必须明确的告诉系统这个APP的启动方向。通常的，APP启动在竖屏模式然后界面旋转匹配设备需要的方向。关于APP支持的竖屏和横屏方向，你应该总是配置你的视图到横屏模式然后让你的视图控制器去操作任何的旋转。如果APP支持横屏单不支持竖屏方向，执行以下的几个任务去制作它初始横屏启动。</p>

<ul>
<li> 添加<code>UIInterfaceOrientation</code>键到你的APP的<code>Info.plist</code>文件，设置这个键的值为 <code>UIInterfaceOrientationLandscapeLeft</code>或者<code>UIInterfaceOrientationLandscapeRight</code>其中一个。</li>
<li> 布局你的视图在横屏模式，确保它们的布局或者自动尺寸选项是设置正确的。</li>
<li><p> 覆盖你的视图控制器的<code>shouldAutorotateToInterfaceOrientation:</code>方法，当旋转到横屏方向的left或者right时返回YES，当旋转到竖屏方向是返回NO。</p>

<pre><code>    Important:APP应该总是使用视图控制器去管理它们基于窗口的内容
</code></pre></li>
</ul>


<p>  这个<code>UIInterfaceOrientation</code>键在<code>Info.plist</code>文件告诉iOS它应该配置APP的状态栏的方向(如果有一个显示的)此外通过视图控制器在启动时间管理视图的方向。视图控制器考虑这个键然后设置他们的视图的初始方向去匹配。使用这个键等同于在早期的 <code>applicationDidFinishLaunching:</code>方法中调用UIApplication对象的<code>setStatusBarOrientation:animated:</code>方法。</p>

<h3>在第一次启动安装APP特定的数据文件(Installing App-Specific Data Files at First Launch)</h3>

<p>  你能利用你的APP第一次启动周期去建立任何数据和需要去运行的配置文件。APP特定的数据文件应该创建在你的APP沙盒的Library/Application Support/<bundleID>/目录，<bundleID>是你的APP包(bundle)标识。你能进一步细分这个目录去组织你需要的数据文件。你能同样创建文件在另外的目录，例如你的APP iClound容器目录或者本地Documents目录，这个主要根据你的需要。
   如果你的APP包(bundle)包含了你计划去改变的文件，复制这些文件到一个可以修改文件的目录，如果你直接在包(bundle)里面修改它们，那么你的APP的签名会无效，因为APP包(bundle)是代码签名了的，签名无效以为着你的APP在将来启动的时候回被系统阻止，你唯一方法是把这些要修改的文件复制到应用程序沙盒支持的可写的目录然后才能安全的使用这些文件。</p>

<h2>当你的APP暂时的中断时干些什么(What to Do When Your App Is Interrupted Temporarily)</h2>

<p>一个基于提醒的中断导致你的APP暂时失去控制，你的APP继续运行在前台，但是不接收任何来自系统的触摸事件(它不继续去接收通知和另外的事件类型，例如加速计事件)。去响应这个改变，你的APP应该在<code>applicationWillResignActive:</code>方法中做一下的事。</p>

<ul>
<li>保存数据和任何相关的状态信息.</li>
<li>停止计时器和另外的定期任务.</li>
<li>停止运行任何元数据查询.</li>
<li>不开始任何新任务。</li>
<li>暂停电影播放(通过AirPlay播放除外).</li>
<li>如果是游戏就使游戏进入一个暂停状态。</li>
<li>调节减慢OpenGL ES帧速率.</li>
<li><p>暂停任何调度队列(dispatch queues)或者操作队列(operation queues)去执行非关键的代码。(你能继续处理网络请求和另外时间灵敏的后台任务在不活动状态(inactive)).</p>

<p>当你的APP迁移回活动(active)状态，它的<code>applicationDidBecomeActive:</code>方法应该反转在<code>applicationWillResignActive:</code>方法中做得任何步骤，你的APP应该重新启动计时器，恢复调度队列，加速OpenGL ES帧速率。无论如何，游戏不应该自动恢复，它们应该保持在暂停状态知道用户选择去恢复它们。</p></li>
</ul>


<p> 当用户按压休眠/唤醒按钮，APP设置了<code>NSFileProtectionComplete</code>保护选项保护文件，这时必须关闭所有对这些文件的引用。设备配置一个适当的密码，按压休眠/唤醒按钮锁定屏幕会强制系统扔掉文件的解密秘钥使其能起到完整的保护。在这个屏幕锁定期间，任何企图去访问相应的文件将失败。如此如果你有这样的文件，你应该在你的<code>applicationWillResignActive:</code>方法中关闭任何对这些文件的引用和在你的<code>applicationDidBecomeActive:</code>方法中打开新的引用。</p>

<pre><code>    Important:总是在你的APP的适当的检查点保存数据，尽管你能使用APP状态迁移去强制对象去写未保
    存的数据到磁盘，但是绝不等到一个APP的状态迁移去保存数据。例如，一个视图控制器管理用户数据应
    该在它离开(dismissed)时保存数据
</code></pre>

<h3>暂时中断的响应(Responding to Temporary Interruptions)</h3>

<p>当一个基于提醒的中断发生，例如你一个进来的电话，APP暂时移动到不活动状态如此系统能提示这个用户如何继续下去。APP停留在这个状态直到用户关闭了这个提醒(alert)。在这一点上，APP返回到活动状态或者后台状态。</p>

<p>设置通知作为横幅显示的不会是你的APP不活动(不影响你APP)，基于提醒的APP才会影响(如上)，这个横幅显示在APP窗体顶部的边缘，你的APP可以继续接收触摸事件就像以前一样。无论如何，如果用户拉下这个横幅去显示这个通知中心，你的APP会移动到不活动状态就像发生了一个基于提醒的通知一样。你的APP保持在这个不活动状态直到用户消散(或者关闭反正就是不显示在屏幕上了)了这个通知中心或者启动了另外的APP。在这些情况上，你的APP移动到相应的活动或者后台状态。用户能够使用设置APP(Settings app,就是手机上设置你可以单独设置每个应用的设置地方)去配置那个显示横幅方式的通知和那个显示基于提醒的通知。</p>

<p>按休眠/唤醒按钮是另外一种中断类型，这个引起你的APP临时不活动。当用户按了这个按钮，系统使触摸事件失效(就是系统整个不再接收触摸事件)，移动APP到后台，设置APP的<code>applicationState</code>属性值为<code>UIApplicationStateBackground</code>和锁定屏幕。锁定屏幕对于APP来说是额外的后果，用户数据会保护到加密文件。</p>

<h2>当你的APP进入前台状态时做什么(What to Do When Your App Enters the Foreground)</h2>

<p>返回到前台状态你的APP有机会去重新启动在它移动到后台时停止的任务。</p>

<pre><code>Note:当你的APP重新进入前台这个UIApplicationWillEnterForegroundNotification
通知是可以获得的。在你的APP里的对象可以去使用默认的通知中心注册这个通知。
</code></pre>

<h3>准备处理排队通知(Be Prepared to Process Queued Notifications)</h3>

<p>  一个APP在挂起状态当它返回到前台或者后台执行状态时必须准备好去处理任何排队通知。一个挂起的APP不处理任何代码，因此也不能处理通知相关方向的改变，时间的变化，偏好的变化，和许多会影响APP外观和状态的变化。确保这些改变没有丢失，系统排队了许多相关的通知，直到APP再一次开始执行代码才交付这些通知给APP（前台或者后台任意一个状态）。为了防止当APP恢复时通知过多时APP发生过载，系统合并事件（每一个相关的事件），这些事件反映的是是你的APP自暂停以来的净变化(net change).</p>

<p>下表中的通知可以合并和交付到你的APP的。大部分这些通知是直接交付到你注册的观察者。像这些与设备方向改变相关的，是典型的通过系统框架拦截然后用另外的方法交付给你的APP。</p>

<table>
<thead>
<tr>
<th>事件 </th>
<th> 通知</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个配件连接或者断开连接 </td>
<td> EAAccessoryDidConnectNotification与EAAccessoryDidDisconnectNotification</td>
</tr>
<tr>
<td>设备方向改变 </td>
<td> UIDeviceOrientationDidChangeNotification除了这个通知，视图控制器自动的更新他们的界面方向</td>
</tr>
<tr>
<td>一个有重大意义(significant)的时间变化 </td>
<td> UIApplicationSignificantTimeChangeNotification</td>
</tr>
<tr>
<td>电池电量等级改变(The battery level)或者电池状态改变 </td>
<td> UIDeviceBatteryLevelDidChangeNotification与UIDeviceBatteryStateDidChangeNotification</td>
</tr>
<tr>
<td>接近状态改变(例如接近传感器) </td>
<td> UIDeviceProximityStateDidChangeNotification</td>
</tr>
<tr>
<td>文件保护状态改变 </td>
<td> UIApplicationProtectedDataWillBecomeUnavailable与UIApplicationProtectedDataDidBecomeAvailable</td>
</tr>
<tr>
<td>一个外部的显示连接或者断开连接 </td>
<td> UIScreenDidConnectNotification与UIScreenDidDisconnectNotification</td>
</tr>
<tr>
<td>屏幕显示模式改变 </td>
<td> UIScreenModeDidChangeNotification</td>
</tr>
<tr>
<td>你的APP偏好通过Settings app暴露出来被更改 </td>
<td> NSUserDefaultsDidChangeNotification</td>
</tr>
<tr>
<td>当前语言或者区域设置改变 </td>
<td> NSCurrentLocaleDidChangeNotification</td>
</tr>
<tr>
<td>用户的云账户状态改变 </td>
<td> NSUbiquityIdentityDidChangeNotification</td>
</tr>
</tbody>
</table>


<p>  排队通知是交付到你的APP的主运行循环(run loop)并且通常是交付在任何触摸事件或者另外的用户输入以前。大部分APP应该尽可能足够快的去处理这些事件那样在恢复时才将不会引起任何明显的滞后。无论如何，当你的APP从后台状态返回如果它出现了迟钝，使用Instruments去确定是是否你的通知处理代码引起了延迟。
  一个APP返回到前台同样接收任何视图的视图更新通知，这些是自从最后一次更新以来需要重新更新的视图。一个APP运行在后台任然可以调用<code>setNeedsDisplay或setNeedsDisplayInRect:</code>方法去请求视图的更新。因外这个视图没有显示，系统合并这些请求当APP返回到前台后更新。</p>

<h3>处理云(iClound)变化(Handle iCloud Changes)</h3>

<p>  处于任何理由的iClound状态改变，系统交付 <code>NSUbiquityIdentityDidChangeNotification</code>通知给你的APP。当用户登录或者登出一个iClound账户或者启用或者禁用文档和数据同步这个iClound状态会改变。这个通知是提示你的APP去更新缓存和任何iClound相关的用户界面元素去适应这个改变。例子，当用户登出iClound，你应该移除所有基于iClound文件或者数据的引用。
  如果你的APP已经提示用户是否去存储文件到iClound，当iClound状态改变是不会再次提示用户。在第一次提示用户之后，存储用户的选择到你的APP的本地偏好里面。你可能接下来想使用一个设置包(Settings bundle)或者作为在你APP里面的一个选项去暴露这个偏好。但是再次重复提示除非偏好目前没有在你的用户默认数据库里面。</p>

<h3>处理区域变化(Handle Locale Changes)</h3>

<p> 在你的APP挂起期间如果用户改变了当前的区域，当你的APP返回到前台时你能使用<code>NSCurrentLocaleDidChangeNotification</code>通知去强制更新任何视图包含了区域敏感(locale-sensitive)信息，例如时间，计时器，和数字。当然，最好的避免区域相关问题方法是去用你的方式写代码去制作它简单的更新视图。</p>

<h3>处理改变你的APP设置(Handle Changes to Your App’s Settings)</h3>

<p>如果你的APP的设置是通过Settings app管理的，他观察 <code>NSUserDefaultsDidChangeNotification</code>通知。应为用户能改变设置在你的APP挂起或者进入后台期间，你能够使用这个通知去响应那些设置中重大的改变。有时候，响应这个通知能够帮助你关闭一个潜在的安全漏洞。例子，一个邮件程序应该响应用户账户信息的改变。未能监测这些变化可能会引起隐私或者安全问题。典型的，当前的用户可能能够使用旧的账户信息去发送邮件，甚至这个账户不在属于这个用户了。
根据接收这个<code>NSUserDefaultsDidChangeNotification</code>通知，你的APP应该重新载入任何相关的设置，必要时，适当重置它的用户界面。如果密码或者另外的安全相关的信息改变了，你应该同样隐藏任何先前的显示信息，强制用户去键入新的密码。</p>

<h2>当你的APP进入后台时做什么(What to Do When Your App Enters the Background)</h2>

<p>当从前台移动到后台执行，使用你的app代理的<code>applicationDidEnterBackground:</code>方法去做以下的事:</p>

<ul>
<li>准备去拿你APP的照片。当你的<code>applicationDidEnterBackground</code>方法返回时，系统拿你的APP用户界面的图片去使用这个结果图片做动画迁移。如果你的用户界面的视图包含了任何的敏感信息，在调用<code>applicationDidEnterBackground</code>方法返回之前你应该隐藏或者修改这些视图。如果你添加了新的视图到你的视图层级并作为这个过处理的一部分，你必须强制这些视图去绘制。</li>
<li>保存任何APP相关的状态信息。在进入后台之前，你的APP应该已经保存了所有的用户关键数据。使用迁移到后台去保存任何最后一分钟的变化到你的APP状态。</li>
<li>根据需要释放内存。释放任何你不需要的缓存数据和做任何简单的清理，这个能够减少你APP的内存占用。APP占用太大的内存系统会第一个终止它，如此释放你不需要的图片资源，数据缓存，和任何另外的对象。</li>
</ul>


<p>你的APP代理<code>applicationDidEnterBackground</code>方法有大约五秒钟去结束任何未完成的任务然后返回，事实上，这个方法应该尽可能快的返回。如果这个方法在时间耗尽以前还没有返回，你的APP会被终止占用的内存会被释放。如果你任然需要更多的时间去执行任务，调用<code>beginBackgroundTaskWithExpirationHandler</code>方法去请求更多的后台执行时间，还有就是开启一个长运行任务在次要的线程。不管你是否启动任何后台任务，<code>applicationDidEnterBackground</code>方法在五秒钟之内任然必须退出。</p>

<pre><code>    Note:系统除了调用applicationDidEnterBackground方法之外还发送
    UIApplicationDidEnterBackgroundNotification通知，你可以使用这个通知去分布清理任
    务到你的APP的另外的对象
</code></pre>

<h3>后台迁移周期(The Background Transition Cycle)</h3>

<p>当用户按了Home键，按了休眠/唤醒键，或者系统启动了另外一个APP，当前的前台APP迁移到不活动状态接着迁移到后台状态。这些迁移结果导致调用APP的代理<code>applicationWillResignActive:</code> 和<code>applicationDidEnterBackground:</code>方法<code>applicationDidEnterBackground:</code>方法返回后，不久后大部分的APP移动到挂起状态。APP可以请求指定的后台任务(例如音乐播放)或者请求一点额外执行时间让这个APP就能够继续运行一段时间。</p>

<h3>准备APP快照(Prepare for the App Snapshot)</h3>

<p>APP的<code>applicationDidEnterBackground:</code>方法返回后不久，系统拿一个APP窗体的快照。同样的，当一个APP唤醒去执行后台任务时，系统可能拿一个快照去反映任何相关的改变。
如果你制造改变在APP马上进入后台时，你能调用主视图的<code>snapshotViewAfterScreenUpdates:</code>方法去强制这些改变去渲染。关于快照调用一个视图的<code>setNeedsDisplay</code>方法是无效的因为快照是拿下一个绘制周期以前的，因此阻止任何改变被渲染。调用<code>snapshotViewAfterScreenUpdates</code>并传入参数YES强制立即更新到基础缓冲区给快照机器使用(the snapshot machinery uses.)。</p>

<h3>降低你的内存占用(Reduce Your Memory Footprint)</h3>

<p>每个APP在马上进入后台时应该释放许多的内存这种做法是实用的。系统在同一时间视图保持许多的APP在内存里当它可以能够如此的话，但是当内存运行比较低的时候系统会终止挂起的APP来回收内存。当在后台期间APP消耗大量的内存那么它会第一个被终止。
实际上来说，当你的APP不在对这个对象需要时你的APP应该移除对这个对象的强引用，移除强引用给编译器有能力去立即释放这个对象，如此相应的内存能够回收。无论如何，如果你想去缓存一些对象去改善性能，你能等到直到APP迁移到后台以前移除对这些对象的引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac上安装Visual Studio Code开发Asp.Net应用程序]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/21/zai-macshang-an-zhuang-visual-studio-codekai-fa-asp-dot-netying-yong-cheng-xu/"/>
    <updated>2016-07-21T11:02:25+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/21/zai-macshang-an-zhuang-visual-studio-codekai-fa-asp-dot-netying-yong-cheng-xu</id>
    <content type="html"><![CDATA[<p>  现在微软出了新的跨平台编译器Visual Studio Code，能够横跨Linux、Mac、Windows并在其上面进行web开发，现在ASP.NET已经出到了5.0了而且MVC框架也已近出到6.0.下面我就来写我在Mac上安装Visual Studio Code和与其依赖的环境。</p>

<h2>安装Visual Studio Code</h2>

<p>  可以在<a href="https://code.visualstudio.com/c?utm_expid=101350005-24.YOq70TI1QcW9kAbMwmhePg.2">这里</a>下载Visual Studio Code的安装包，下载到硬盘后把下载的包拖到你机器的Application目录中就安装完成了，现在的最新版本是Visual Studio Code 1.3。
  下载完成后你可以安装相应的扩展（除了第一个强烈要求安装外其余的可以看各自需要）：
  * C# for Visual Studio Code (powered by OmniSharp)(启动VS Code按(⌘+P)快捷键然后复制ext install csharp命令到扩展查询框中接着按enter键。这个扩展提供了高亮语法，Debugging等的支持)
  * Auto Close Tag(安装方法类似上面的)</p>

<h2>安装.NET Core SDK</h2>

<p>  Net Core是什么，其实可以看做是一个所有微软框架的基础，他是.Net Framework和跨平台框架mono(mono其实是更具.Net Framework重新实现的跨平台版本)的基石，以前的.Net Framework框架和mono是两个独立的框架，那么可能有些与跨平台无关的代码重复实现了，现在有Net Core框架，他是所有的微软框架的技术栈，都是依托它搭建起来，当然现在还才开始，Net Core实现的内容还不多，不过微软以后的趋势就是这样的。</p>

<h3>安装.NET Core前必须确保安装了openssl的最新版本，用brew安装可以用以下命令</h3>

<pre><code>    brew install openssl
    brew link --force openssl
</code></pre>

<p>然后在<a href="https://download.microsoft.com/download/0/A/3/0A372822-205D-4A86-BFA7-084D2CBE9EDF/dotnet-dev-osx-x64.1.0.0-preview2-003121.pkg">这里</a>下载安装.NET Core就可以了。</p>

<p><code>注意：如果你安装了oh-my-zsh，你可能会遇到一个错误，安装完.NET Core后它的dotnet命令没有在你的PATH里面，你可以用命令(sudo ln -s /usr/local/share/dotnet/dotnet /usr/local/bin)修复它</code></p>

<h3>现在你可以初始化一些代码了</h3>

<p>用以下命令初始化一个简单的Hello World应用</p>

<pre><code>    mkdir hwapp
    cd hwapp
    dotnet new
</code></pre>

<h3>运行应用程序</h3>

<p>下面的第一个命令将恢复指定在project.json文件中的包，第二个命令将运行实际的项目。</p>

<pre><code>    dotnet restore
    dotnet run
</code></pre>

<h3>你可以创建一个web站点</h3>

<ol>
<li>就利用上面的项目，你可以更新上面的项目的project.json文件，在中间添加一行依赖于Kestrel HTTP服务包，加入后记得运行dotnet restore命令去恢复包，加入后大概类似以下部分。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0-*&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;buildOptions&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;debugType&quot;</span><span class="p">:</span> <span class="s2">&quot;portable&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;emitEntryPoint&quot;</span><span class="p">:</span> <span class="kc">true</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{},</span>
</span><span class='line'>  <span class="nt">&quot;frameworks&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;netcoreapp1.0&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;Microsoft.NETCore.App&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>          <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;platform&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="nt">&quot;Microsoft.AspNetCore.Server.Kestrel&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>      <span class="nt">&quot;imports&quot;</span><span class="p">:</span> <span class="s2">&quot;dnxcore50&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>添加一个Startup.cs(这个文件是所有的web的入口，是必须的)文件去定义请求逻辑，类似以下：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Builder</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Hosting</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Http</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">aspnetcoreapp</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">app</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="n">context</span> <span class="p">=&gt;</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="s">&quot;Hello from ASP.NET Core!&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>更新修改Program.cs去建立和启动这个Web主机(host):</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Hosting</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">aspnetcoreapp</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebHostBuilder</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseKestrel</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span><span class='line'>            <span class="n">host</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>运行这个APP(这个dotnet run命令在这个APP有改动的时候自动编译它再运行)</p>

<pre><code> dotnet run
</code></pre></li>
<li><p>在浏览器键入<a href="http://localhost:5000">http://localhost:5000</a>打开这个web网站(你可以用Ctrl+C停止这个服务)</p></li>
</ol>


<h2>利用Yeoman来生成一个项目模板</h2>

<p>Yeoman是一个完整项目生成器，他是一个开源的工具，他可以生成出来像一个Visual Studio项目模板等等。</p>

<h3>安装Yeoman</h3>

<p>首先要安装Yeoman所依赖的Node.js,你可以<a href="https://nodejs.org/en/">这里</a>下载安装Node.js.然后要安装npm,可以在<a href="https://www.npmjs.com">这里</a>下载安装。接下来用npm安装Yeoman,bower,grunt和gulp</p>

<pre><code>    sudo npm install -g yo bower grunt-cli gulp
</code></pre>

<p>安装ASP.NET模板生成器（-g标识是全局生成器，可以再任何路径使用）</p>

<pre><code>    sudo npm install -g generator-aspnet
</code></pre>

<h3>创建一个ASP.NET应用</h3>

<p>键入如下命令</p>

<pre><code>    mkdir src
    cd src
    yo aspnet
</code></pre>

<p>选中Web Application选项按enter，键入项目名字mywebapp,然后键入一下命令</p>

<pre><code>    dotnet restore
</code></pre>

<p>编译和运行可以键入一下命令,其中dotnet build是可选命令，每次运行时都会重新编译一下。</p>

<pre><code>    dotnet build
    dotnet run
</code></pre>

<p>打开浏览器，导航到<a href="http://localhost:5000">http://localhost:5000</a>可以看界面。至此一个简单web站点搭建成功。</p>

<h3>利用yo可以添加类到现存项目中</h3>

<p>进入如下命令</p>

<pre><code>    yo aspnet:Class Person
</code></pre>

<p>结果是一个命名为Person.cs的文件被建立，如下Person:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">MyNamespace</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="nf">Person</span><span class="p">()</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>扩展</h2>

<p>  ASP.NET 5.0已经正式更名为 ASP.NET CORE,现在都存在于.NET Core SDK中。
  关于Kestrel,它是一个跨平台的web服务是基于<a href="https://github.com/libuv/libuv">libuv</a>的，你添加Kestrel的支持必须添加Microsoft.AspNetCore.Server.Kestrel到你的项目的project.json依赖列表中。Kestrel他是跑到一个代理服务后面的(例如IIS或者Nginx),它自己是不面向网络的，你可以在一个服务中配置代理请求转发到Kestrel处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展App的行为]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/kuo-zhan-appde-xing-wei/"/>
    <updated>2016-07-12T18:30:04+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/kuo-zhan-appde-xing-wei</id>
    <content type="html"><![CDATA[<h1>引言</h1>

<p>此篇文章几乎是对照着Apple文档翻译，某些地方是按照自己理解翻译的，难免有理解和翻译不当的地方，在此告知。</p>

<h1>扩展APP行为</h1>

<p>每一个新的Xcode项目从配置好到马上运行在iOS模拟器或者设备上。但是简单的能够运行在一个设备上并不意味着你的APP准备好传送到APP Store上。每一个APP都需要一定量的定制去确保给用户一个好的用户体验。定制的范围从给APP一个图标到制作一个建筑级别决定你的APP如何去呈现和使用信息。这些定制的行为可以再APP的计划过程中尽早的考虑。</p>

<h1>具体的可以分为以下几项</h1>

<h2>提供所需的资源</h2>

<h3>你创建每一个APP都必须有接下来的资源集合和元数据如此它才能正确的显示在设备上。</h3>

<ol>
<li>一个信息属性列表文件。这个Info.plist文件包含了你的APP的元数据，系统使用这些信息去和你的APP交互。Xcode会自动的基于你的项目的配置和设置创建这个文件。如果你想直接的查看或者修改这个内容，你能操作你的项目的Info选项卡。</li>
<li>一个APP所需能力的声明。每一个APP必须声明它运行时所需要的硬件能力或者特性.APP Store使用这个信息确定是否能够在一个特定的设备上运行你的APP。你能够在Info选项卡的"Required device capabilities"条目上编辑你的APP需要量列表。</li>
<li>一个或者多个图标。系统在用户设备主屏幕上显示的你的APP的图标。系统可能显示在设置应用上或者一个查询结果上使用的是你图标其他的版本。</li>
<li>一个或者多个启动图片。当一个APP启动时，系统显示一个临时的图片直到这个APP能够呈现它的用户界面为止。这个临时的图片是你的APP的 启动图片他提供给用户及时的反馈你的APP是正在启动和将要马上准备好了。你必须提供至少一个启动图片，你可能提供了额外的启动图片去解决不同的场景。</li>
</ol>


<p>以上的这些资源是所有的APP必须的但是你包含的应该不仅仅是这些资源。有更多的键Xcode默认没有包含在你的APP的Info.plist文件中。更多额外的键仅仅是当你的APP包含了特定的特性时加入。</p>

<h1>APP包(Bundle)</h1>

<p>当你建立你的APP的时候，Xcode包装它作为一个包(Bundle).一个包(Bundle)在文件系统中是一组相关的资源放在一个地方的目录。一个iOS App包(Bundle)包含一个APP执行文件和所支持的资源文件例如应用程序图标，图片文件，和本地化内容。</p>

<h1>支持用户隐私</h1>

<p>当你设计你的APP的时候保护用户隐私应该作为一个重要考虑。大部分iOS设备包含了用户和设备数据用户可能不想暴露这些数据到应用和外部实体。请记住如果你用一个不恰当的方法去使用数据用户可能会删除你的APP。
访问用户或者设备数据仅仅是当用户了解同意并和适当的法律一致时。另外，采取适当的步骤去保护用户和设备数据清晰的告诉用户你要如何使用这些数据。你可以采用下面的一些好的实践。</p>

<ol>
<li>可以和公司的法律顾问一起看一些来自政府或者行业关于保护移动用户隐私的文档。</li>
<li>请求访问用户或者设备数据有时候是需要的，这个数据是受iOS系统授权设置保护的。考虑在你的Info.plist文件里供应一个用法描述字符串用来解释为什么APP需要用到这个数据。受iOS系统授权设置保护的数据包含位置数据，联系人，日历事件，备忘录，照片和媒体。</li>
<li>明确的告诉用户你将要如何去使用这些数据。</li>
<li>给用户控制这些用户和设备数据。提供设置如此用户能够禁止访问某些需要的敏感数据。</li>
<li>请求使用需要的最少量的用户或者设备数据去完成一个给定的任务。如果不明显的原因或者不必要的原因或者因为你觉得这些数据以后会有用等等这些情况都不要去访问查寻或者收集数据。</li>
<li>采用合理的步骤去保护收集在你的APP中的用户和设备数据。当存储这些信息在本地时，尝试使用iOS数据保护特性 (described in Protecting Data Using On-Disk Encryption)去存储它为一个加密的格式。当你要经过网络发送用户或者设备数据时尝试采用HTTPS连接。</li>
<li>如果你的APP使用了ASIdentifierManager类，你必须考虑它的advertisingTrackingEnabled属性值。如果用户设置这个属性值为NO，使用这个类仅仅是有限的广告目的。</li>
<li>如果你还没有这么做得话，停止使用UDID。这个属性在iOS 5.0已经废弃了。App Store不接受新的APP或者APP更新使用这个标识。作为替代，ASIdentifierManager类的advertisingIdentifier属性是适合的。</li>
<li>如果你的APP支持音频输入，那么仅仅在你实际上计划要开始录音的地方配置你的录音回话（audio session）。如果你没有计划立即录音不要在启动的时候配置你的录音回话（audio session）。在iOS7中，当APP配置他们的录音的录音回话（audio session）时系统会提醒用户，并给用户一个禁用录音的选项。</li>
</ol>


<h1>APP国际化</h1>

<p>因为APP分布在许多的国家，本地化你的APP能帮助你联络到更多的用户。当APP被本地化为他们的母语时，更多的用户可能会使用这个APP。当你把面向用户的内容作为因素插入到资源文件时，本地化这个内容是一个相对简单的过程。
在你可能本地化你的内容以前，你必须使你的APP国际化这样是为了便利本地化的过程。国际化APP牵涉的因素有任何面向用户的内容插入到本地化的资源文件和提供存储内容特定语言项目目录。当使用特定语言和特定地区内容工作时它同样意味着使用恰当的技术（例如时间和数字格式化）
一个完全国际化的APP，本地化过程创建一个新的特定语言资源文件添加到你的项目。一个典型的iOS应用需要接下来这些资源文件类型的本地化版本。</p>

<ol>
<li>Storyboard文件(或者nib文件)-Storyboard能包含文本标签和另外的需要本地化的内容。你可能同样想调整界面项的位置去适应文本长度的改变。（同样的，nib文件能包含你需要本地化的文本或者你需要去更新的布局）</li>
<li>Strings文件-Strings文件（如此命名是因为他们的.strings文件名扩展）包含你的APP显示的静态文本的本地化版本。</li>
<li>Image文件-你应该避免本地化图片除非图片包含了特定的文化内容。在任何时候，你应该避免直接的存储文本在你的图片文件里面。从你的APP里面加载和使用图片，存储文本到一个strings文件，在运行时，把文字内容和图片内容整合在一起。</li>
<li>录像和录音文件-你应该避免本地化多媒体文件，除非他们包含了特定语言或者特定文化的内容。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APP生命周期与后台执行]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/appsheng-ming-zhou-qi-yu-hou-tai-zhi-xing/"/>
    <updated>2016-07-12T18:20:42+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/appsheng-ming-zhou-qi-yu-hou-tai-zhi-xing</id>
    <content type="html"><![CDATA[<h1>引言</h1>

<p>此篇文章几乎是对照着Apple文档翻译，某些地方是按照自己理解翻译的，难免有理解和翻译不当的地方，在此告知。</p>

<h1>APP生命周期（The App Life Cycle）</h1>

<p>APP是在你的自定义代码和系统框架中间复杂的相互作用。这个系统框架提供了所有的APP运行需要的基础结构，你提供的代码需要去定制这个结构和给APP一个样子和你想要的感觉。有效的做这个，它帮助你了解一点点关于iOS的结构和它如何工作的
iOS框架依赖于设计模式，例如MVC和代理在他里面的实现。了解这些设置模式是成功创建一个APP的关键。他同样帮助你熟悉objective-c语言和它的特性。</p>

<h1>APP的结构（The Structure of an App）</h1>

<p>在启动的时候，这个UIApplicationMain函数建立几个关键的对象和开始这个APP运行。每一个APP的核心是UIApplication对象，它的工作是在APP中去便利系统和另外对象的交互。iOS应用都采用了mvc结构，这个模式用来数据视觉呈现时的数据和业务逻辑的分离。这个是去创建APP运行在不同的设备的不同屏幕尺寸上的关键结构。</p>

<h2>iOS应用中各个对象的角色</h2>

<h3>UIApplication对象</h3>

<p>UIApplication对象管理事件的循环和另外的高等级的行为。它同样传达关键的APP迁移和一些特定的事件（例如正到来的推送通知）给它的代理。</p>

<h3>App delegate对象</h3>

<p>这个App delegate是你自定义代码的核心。这个对象和UIAplication对象协力去操作APP的初始化，状态迁移，和许多高等级APP事件。这个对象同样保证在每一个APP中仅仅一个，如此它通常用来建立APP的初始数据结构。</p>

<h3>Documents和data model对象</h3>

<p>Data model对象存储了你的APP内容并且是特定于你的APP的。APP能同样使用document对象（自定义UIDocument子类）去管理一些或者所有的他们的data model对象。Document对象不是必须的，但是它提供一种方便的方法去组织你的数据到一个单个的文件或者文件包中。</p>

<h3>View controller</h3>

<p>UIViewController是所有View controller对象的基类。它提供了默认的功能关于加载视图，呈现他们，旋转他们去响应设备的旋转，和几个另外的标准的系统行为。UIKit和另外的框架定义了额外的View controller类去实现标准的系统界面，例如图片选择器（image picker），tab bar界面和导航界面。</p>

<h3>UIWindow对象</h3>

<p>UIWindow对象协调一个或多个视图的显示。大部分的APP只有一个window，它在主屏幕上呈现内容，但是APP可能有一个额外的视图关于显示内容到一个外部的显示。
去改变你的APP的内容，你使用view controller去改变视图在相应的window里的显示。你永远不可能替换window本身。
除了承载视图，Windows和UIApplication一起工作去交付事件给你的视图和view controllers。</p>

<h3>View对象，control对象和layer对象</h3>

<p>Views和controls提供你的APP的内容的视觉表现。一个view是一个对象，它绘制内容在一个指定的矩形区域，响应这个指定的矩形区域中的事件。Controls是一个专门的view类型，负责实现熟悉的界面对象，例如buttons、text field和toggle switches。</p>

<h1>APP执行状态（Execution States for Apps）</h1>

<p>在任何一个给定的时刻，你的APP都是在下面的任意一个状态。系统在整个系统运行期为了响应动作的发生去迁移你的APP从一个状态到另外一个状态。例如用户按了home键，一个电话打进来或者任何几个其他的中断发生，当前运行的APP响应后去改变自己的状态。一下是一些APP各状态描述。</p>

<h2>没有运行（Not running）</h2>

<p>这个APP没有启动或者在运行但是通过启动终结了。</p>

<h2>未活动（Inactive）</h2>

<p>这个APP运行在前台但是现在不接受事件。（它可能执行另外的代码）一个APP通常只停留在这个状态一瞬间然后他迁移到不同的状态。</p>

<h2>活动(Actice)</h2>

<p>APP运行在前台并且接受事件。这个是一个前台APP标准的模式。</p>

<h2>后台（Background）</h2>

<p>APP后台和执行代码，大部分APP进入这个转态一瞬间就被系统挂起。无论如何，一个APP请求一个额外的执行时间能够保持在这个状态一段时间。另外，一个APP启动时直接进入后台状态而不是未活动（Inactive）状态.</p>

<h2>挂起（Suspended）</h2>

<p>APP进入后台但是没有执行代码，系统自动移动APP到挂起状态并且做这个的时候没有通知。在挂起的期间，APP保持在内存里但是不执行任何代码。
当一个低内存状况发生，系统可能净化挂起的APP去制造更多的空间给前台APP并且做这个的时候没有通知。
大部分的状态迁移都伴随着APP代理方法的调用。这些方法是给你机会用一些适当的方式去响应状态的改变。以下是这些方法的列表。</p>

<h3>application:willFinishLaunchingWithOptions:</h3>

<p>这个方法是在APP启动时第一次机会去执行代码。</p>

<h3>application:didFinishLaunchingWithOptions:</h3>

<p>这个方法是你的APP显示给用户之前运行你执行任何最终的初始化处理。</p>

<h3>applicationDidBecomeActive:</h3>

<p>让你知道你的APP已经变为了前台APP。这个方法给你最后一分钟的准备。</p>

<h3>applicationWillResignActive:</h3>

<p>让你知道你的APP将迁移离开前台APP，使用这个方法把你的APP变为一个静态状态。</p>

<h3>applicationDidEnterBackground:</h3>

<p>让你知道你的APP现在运行在后台状态并且随时可能挂起。</p>

<h3>applicationWillEnterForeground:</h3>

<p>让你知道你的APP已经移动退出了后台状态和返回进入了前台，但是这个还不是活动的状态。</p>

<h3>applicationWillTerminate:</h3>

<p>让你知道你的APP开始终结。如果你的APP挂起了，那么不会调用这个方法。</p>

<h1>后台执行（Background Execution）</h1>

<p>当用户没有积极的使用你的app时，系统会移动这个app到后台状态，许多的APP，在后台状态事实是驻留一瞬间就被系统迁移到挂起状态了。挂起APP这个做法是为改善电池寿命和把系统的重大资源用于新的前台APP以用于吸引用户的手段。
大部分的APP能够相当容易的迁移到挂起状态但是也同样有正当的持续在后台运行的理由。例如一个徒步旅行APP可能想要追踪用户在任何时间的位置这样能够显示航线在徒步旅行地图上面。一个音频APP可能需要在锁屏的时候继续播放音乐。另外一些APP可能需要在后台下载内容如此它能以最小的延迟展现这个内容给用户。当你认为需要你的APP能够在后台运行，iOS帮助你有效的做这些并不耗尽系统资源和用户电池。这个技术通过iOS分成三类提供。</p>

<ol>
<li>APP在前台启动一个短的任务，当APP迁移到后台时能够请求时间去结束这个任务。</li>
<li>APP在前台开始下载能够挪动那些下载的管理给系统管理，从而在下载期间允许APP挂起或者终结。</li>
<li>APP需要在后台运行指定的任务类型，可以声明他们要支持的一个或者多个后台任务模式。</li>
</ol>


<p>总是试图去避免做任何后台工作，除非这么做能够改善整体的用户体验。一个APP迁移到后台的可能的原因有用户启动了一个不同的APP或者因为用户锁定了设备和此时没有使用这个APP.在这两种情况，用户此时不需要你的APP做任何有意义的工作。在这样的条件下继续运行你的APP仅仅是耗尽电池和可能导致用户去强制完全退出你的APP。如此记住在后台你做的工作当你能避免的时候避免。</p>

<h1>执行有限长度的任务（Executing Finite-Length Tasks）</h1>

<p>APP迁移到后台是预期把自己尽可能快的进入到一个静止的转态，如此系统能够暂停他们。如果APP是在一个任务运行的中间和需要一点时间去完成这个任务，它能够调用UIApplication对象的 beginBackgroundTaskWithName:expirationHandler: 或者beginBackgroundTaskWithExpirationHandler:方法去请求一些额外的执行时间。调用这两个方法中的任何一个都可以暂时去延迟你的APP的挂起，给它一点额外的时间去结束这个工作。到这个工作完成的时候，你的APP必须调用endBackgroundTask:方法去让系统知道任务结束了系统能够挂起这个APP了。
每次调用beginBackgroundTaskWithName:expirationHandler: 或者beginBackgroundTaskWithExpirationHandler:方法生成一个唯一的令牌（token）去关联相应的任务。但你的APP完成了一个任务的时候，它必须用相应任务的令牌（token）作为参数去调用endBackgroundTask:方法去让系统知道这个任务完成了。失败去调用endBackgroundTask:方法关于一个后台任务将导致你的应用程序终结。当开始这个任务如果你提供了一个到期终止处理（expiration handler）,这个系统调用这个到期终止处理（expiration handler）给你一个最后的机会去结束任务和避免APP终结。
你不需要去等到你的APP迁移到后台的时候再去指派后台任务。开始一个任务之前，一个更有用的设计是调用beginBackgroundTaskWithName:expirationHandler: 或者 beginBackgroundTaskWithExpirationHandler:方法。等到你的任务结束就调用endBackgroundTask:方法。</p>

<p>在你自己的到期终止处理（expiration handler）中，你能够包含额外的需要去关闭你的任务的代码。你包含的任何代码不能拿太长时间去执行，因为到你调用到期终止处理（expiration handler）时候，你的APP已经很靠近它的时间限制了。因为这个原因，仅仅执行极少的你的状态信息的清理和结束这个任务。</p>

<h1>在后台下载内容（Downloading Content in the Background）</h1>

<p>但下载文件时，APP应该使用一个NSURLSession对象去开始一个下载，如果这个APP挂起或者终结此时系统能拿到这个下载处理的控制。当你配置一个NSURLSession对象作为后台传输用，系统在一个独立的处理里面管理那些传输和以通常的方式报告状态给你的APP。当以传输在进行期间如果你的APP终结了，系统在后台继续这个传输，当这个传输结束或者当一个或多个任务需要你的APP的注意，启动这个APP（当适当的时候）。
去支持后台传输，你必须适当的配置你的NSURLSession对象，去配置这个回话（session），你必须首先创建一个NSURLSessionConfiguration对象和设置这个对象的几个属性到适当的值。当创建这个回话（session）的时候，你接着传递那个配置对象到NSURLSession的适当的初始化方法。</p>

<p>创建支持后台下载配置对象的过程如下：</p>

<ol>
<li>使用NSURLSessionConfiguration的 backgroundSessionConfigurationWithIdentifier: 方法创建配置对象。</li>
<li>设置配置对象的sessionSendsLaunchEvents属性值为YES.</li>
<li>如果你的APP在前台期间启动的下载，推荐你同样设置配置对象的discretionary属性值为YES。</li>
<li>配置这个配置对象任何其他的属性值到适当的值。</li>
<li>使用这个配置对象去创建你的NSURLSession对象。</li>
</ol>


<p>一单配置，你的NSURLSession对象在适当的时候无缝移交这个上传和下载任务给系统。在APP仍然在运行的时候如果你的任务结束（前台和后台任其一的状态），这个回话（session）对象以通常的方式通知它的代理（delegate）。如果这个任务尚未完成此时系统终结了你的APP，这个系统自动的在后台继续管理这个任务。如果用户终结了你的APP，系统取消所有的待执行的任务。</p>

<h1>实现长运行任务（Implementing Long-Running Tasks）</h1>

<p>对于需要更多执行时间去实施的任务，你必须请求指定的许可（specific permissions ）在后台去运行他们，没有他们APP在后台会被暂停。iOS中，只有特定的APP类型能被允许在后台运行：</p>

<ol>
<li>在后台播放有声音的内容给用户的APP，例如音乐播放APP。</li>
<li>在后台录制音频内容的APP。</li>
<li>让用户随时了解他们的位置的APP，例如导航APP。</li>
<li>支持VoIP（Voice over Internet Protocol）的APP。</li>
<li>接收来自外部附件定期更新的APP。</li>
</ol>


<p>实现这些服务（services）的APP必须声明相应的服务，他们支持和使用系统框架去实现那些服务相关的方面。声明服务让系统知道你使用了哪一种服务，但在某些情况下，系统框架实际阻止了你的APP被暂停。</p>

<h2>声明你APP支持的后台任务（Declaring Your App’s Supported Background Tasks）</h2>

<p>支持一些后台执行类型必须通过你的APP提前声明使用它们。在Xcode5以后，你在你项目设置的“Capabilities”标签中声明你的APP所支持的后台模式。启用这个后台模式选项添加UIBackgroundModes键到你的APP的Info.plist文件中。选择一个或者多个检验盒（checkboxes ）添加相应的后台模式值到该键。你能指定以下的后台模式，Xcode会分配这个值到你的APP的Info.plist文件的UIBackgroundModes键中。</p>

<ol>
<li>Audio和AirPlay。</li>
<li>位置更新</li>
<li>VoIP(Voice over IP)</li>
<li>Newsstand下载。</li>
<li>外部附近通信。</li>
<li>使用蓝牙LE附件。</li>
<li>Acts as a Bluetooth LE accessory。</li>
<li>后台拉取。</li>
<li>远程通知。</li>
</ol>


<p>每一个前面的模式让你的系统知道你的APP应该在适当的时间唤醒或者启动去相应相关的事件。</p>

<h1>在后台获得用户的注意（Getting the User’s Attention While in the Background）</h1>

<p>通知是一个当你的APP挂起、在后台或者没有运行需要获得用户注意的方式。APP能够使用本地通知去显示通告，播放声音，以APP的图标为徽章显示，或者这三个的组合。
排定一个本地通知的交付，创建一个UILocalNotification类的实例，配置这个通知的参数，使用UIApplication类的方法计划他。</p>

<h1>选择退出后台执行</h1>

<p>如果你不想要你的APP在任何时候运行在后台，你能够通过添加UIApplicationExitsOnSuspend键（设置值为YES）到你的APP的Info.plist文件来明确的选择退出后台。当一个APP是这样设置的，它将循环在没有运行（not-running），未活跃的（inactive），和活跃（active）状态之间，并且从不进入后台或者挂起状态。当用户按了Home键去退出这个APP，这个APP的代理方法 applicationWillTerminate:会被调用，他终结以前APP大约有五秒时间去清理和退出，迁移到没运行（not-running）的状态。
选择退出后台执行时强烈反对的，但是可能在一定条件下是首选的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins+fastlane持续集成]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/jenkins-plus-fastlanechi-xu-ji-cheng/"/>
    <updated>2016-07-12T16:04:39+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/jenkins-plus-fastlanechi-xu-ji-cheng</id>
    <content type="html"><![CDATA[<h1>iOS持续集成</h1>

<p>用Jenkins配置job,在合适的时机自动触发从git上拉取最新代码、自动构建、自动运行Test最后通过slack通过发送通知形式把结果反馈给team成员。</p>

<h2>安装工具</h2>

<ol>
<li>更新brew包管理工具
$ sudo brew update</li>
<li>安装jenkins
$ sudo brew install jenkins</li>
<li>安装fastlane
$ sudo gem install fastlane</li>
<li>安装fir-cli
$ sudo gem install fir-cli</li>
</ol>


<p>brew error
You can use brew with sudo, but only if the brew executable is owned by root.
However, this is both not recommended and completely unsupported so do so at
your own risk.
解决
$ sudo chown -R root /usr/local
参考：<a href="http://raiko.in/tech/homebrew-cant-sudo/"></a>
<a href="http://lyo.is-programmer.com/posts/39956.html"></a></p>

<p>根证书过期，下载重新安装:
<a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer">根证书下载</a></p>

<h2>fastlane自动构建、自动测试等等</h2>

<ul>
<li>cd [your_project_folder]</li>
<li>fastlane init</li>
<li>Follow the setup assistant, which will set up fastlane for you</li>
<li>Edit Fastfile
<code>``
fastlane_version "1.81.0"
default_platform :ios
platform :ios do
before_all do
   ENV["SLACK_URL"] = "https://hooks.slack.com/services/..."
  #cocoapods
  #increment_build_number
  cocoaPods
  xcodebuild(workspace: "LHAlertCustomViewDevApp.xcworkspace",scheme: "LHAlertCustomViewDevApp",sdk: "iphonesimulator",destination: "platform=iOS Simulator,name=iPhone 6s")
  #gym(workspace: "LHAlertCustomViewDevApp.xcworkspace")
end
desc "Runs all the tests"
lane :test do
  xctest(scheme: "LHAlertCustomViewDevApp",destination: "platform=iOS Simulator,name=iPhone 6s",
    reports: [
      {
        report: "html",
        output: "build/reports/unit-tests.html"
      },
      {
        report: "junit",
        output: "build/reports/unit-tests.xml"
      }
    ],
    clean: nil)
  #scan
end
desc "Submit a new Beta Build to Apple TestFlight"
desc "This will also make sure the profile is up to date"
lane :beta do
  # match(type: "appstore") # more information: https://codesigning.guide
  #gym # Build your app - more options available
  #pilot
  # sh "your_script.sh"
  # You can also use other beta testing services here (run</code>fastlane actions`)
end
desc &ldquo;Deploy a new version to the App Store&rdquo;
lane :appstore do

<h1>match(type: &ldquo;appstore&rdquo;)</h1>

  # snapshot
  #gym # Build your app - more options available
  #deliver(force: true)
  # frameit
end

<h1>You can define as many lanes as you want</h1>

after_all do |lane|
  # This block is called, only if the executed lane was successful
   slack(
     message: &ldquo;Successfully test new App Update.&rdquo;
   )
end
error do |lane, exception|
   slack(
     message: exception.message,
     success: false
   )
end
end
```
在终端输入fastlane test测试自动构建，自动测试是否成功,也可以用xtool来构建和测试工程。

<h2>fir-cli</h2></li>
<li>进入slack.com注册自己的账号，可以自己创建team，也可以加入别的team。</li>
<li>进入<a href="https://ajiosteam.slack.com/services/B0ZRJH8UU?added=1%E7%94%9F%E6%88%90SLACK_URL%E3%80%82">https://ajiosteam.slack.com/services/B0ZRJH8UU?added=1%E7%94%9F%E6%88%90SLACK_URL%E3%80%82</a></li>
<li>设置Fastfile中的slack地址。</li>
</ul>


<h2>jenkins配置</h2>

<ol>
<li>创建job</li>
<li>打开<a href="http://localhost:8080">本地</a></li>
<li>Manage Jenkins > Manage Plugins > Available 安装插件

<ul>
<li>HTML Publisher Plugin</li>
<li>AnsiColor Plugin</li>
<li>Rebuild Plugin</li>
<li>GIT Plugin</li>
</ul>
</li>
<li>上一步结束点击 Back to Dashboard > New Item > 键入Item name > 选择Freestyle project > ok</li>
<li>配置job
<code>
 Source Code Management：/Users/liuhao/Documents/gittest/LHAlertCustomView
 Branches to build：*/master
 Add build step &gt; Execute shell
 Command:
 #!/bin/bash
    source ~/.bash_profile
    cd LHAlertCustomViewDevApp/
    fastlane test
    or
    #!/bin/bash
  export LC_ALL="en_US.UTF-8"
  fastlane test
</code>

<ul>
<li>Save job</li>
</ul>
</li>
<li>自动job

<ul>
<li>Build Triggers > Build periodically
<code>
在每周的工作日的每小时的前半个小时，每过十分钟触发一次
H(0-29)/10 * * * 1-5
</code></li>
</ul>
</li>
</ol>


<h2>参考</h2>

<p><a href="https://github.com/fastlane/fastlane">fastlane</a><br/>
<a href="https://github.com/fastlane/fastlane/blob/master/docs/Jenkins.md">Jenkins Integration</a></p>

<h2>Note</h2>

<h1>error:</h1>

<p>修改文件为可读可写：
<string>&ndash;httpListenAddress=0.0.0.0</string>替换<string>&ndash;httpListenAddress=127.0.0.1</string>
sudo chmod 666  ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</p>

<p>Mac-mini:~ dongmeiliang$ sudo chmod o-w /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Password:
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: Path had bad ownership/permissions
Mac-mini:~ dongmeiliang$ sudo chmod g-w /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded
Mac-mini:~ dongmeiliang$ sudo chmod o-w ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded
Mac-mini:~ dongmeiliang$ vim ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ vim /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ clear
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded</p>

<h2>注意</h2>

<p>如果fastlane编译测试成功
但Jenkins运行编译成功测试失败并报
或者：invalid byte sequence in US-ASCII (ArgumentError)[0m</p>

<p>timeout connect(2)只是以上错误引起的。</p>

<p>可以fix错误
    export LC_ALL=&ldquo;en_US.UTF-8"写到你的shell里面</p>

<pre><code>There are two ways to fix this. You can export language settings to your shell:
</code></pre>

<p>1：不推荐，这样会修改整个系统的设置。
export LANGUAGE=en_US.UTF-8
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
or you can put this into your Gemfile:
2：推荐这个 you can put this into your Gemfile:（可以把一下代码加到你的Gemfile的头部）
if RUBY_VERSION =~ /1.9/
  Encoding.default_external = Encoding::UTF_8
  Encoding.default_internal = Encoding::UTF_8
end
提醒：可以免密码登录
The authorized_keys file corresponds to the conventional ~/.rhosts file, and has one key per line, though the lines can be very
     long.  After this, the user can log in without giving the password</p>
]]></content>
  </entry>
  
</feed>
