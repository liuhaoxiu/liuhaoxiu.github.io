<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刘浩的技术博客]]></title>
  <link href="http://liuhaoxiu.github.io/atom.xml" rel="self"/>
  <link href="http://liuhaoxiu.github.io/"/>
  <updated>2016-07-29T15:14:45+08:00</updated>
  <id>http://liuhaoxiu.github.io/</id>
  <author>
    <name><![CDATA[刘浩]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用工具规范OC代码样式]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/29/yong-gong-ju-gui-fan-ocdai-ma-yang-shi/"/>
    <updated>2016-07-29T15:13:14+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/29/yong-gong-ju-gui-fan-ocdai-ma-yang-shi</id>
    <content type="html"><![CDATA[<h1>规范OC代码样式</h1>

<p>在团队开发过程中，可能你team里面的每个成员都有自己不同的代码风格，其实代码风格到不是一定要很规范，但是一定要很统一，这样整体的代码在是视觉上就不会显得很混乱，而且互相阅读代码的时候也会很自然。这篇文章是来安装适当的工具强制team成员形成统一的代码样式。</p>

<h2>安装Xcode插件用于格式化你的代码到相应的范式</h2>

<p><a href="https://github.com/benoitsan/BBUncrustifyPlugin-Xcode">这里</a>这里有一个插件，安装完后你就可以在Xcode的菜单中找到响应的格式化命令了。安装可以选择在终端运行<code>curl -SL https://raw.githubusercontent.com/benoitsan/BBUncrustifyPlugin-Xcode/master/install.sh | sh</code>自动下载安装。(也可以使用插件目录中提到的另外两种安装方法)</p>

<p>安装完成后，如果重启Xcode可以看到菜单<code>Edit &gt; Format Code</code>中的以下命令：</p>

<ol>
<li>使用<code>Format Selected Files</code>去格式化在项目导航中选定的文件。</li>
<li>使用<code>Format Active File</code>去格式化在编辑器中实际打开的文件。</li>
<li>使用<code>Format Selected Lines</code>去格式化选中的代码行(多行选中时支持的)。如果选中的行没有满选会自动扩展的整行，如果没有选中任何行，就会使用光标下的行作为格式化。</li>
<li>使用<code>Edit Configuration</code>在一个额外的编辑器去配置这个格式化程序。</li>
<li>使用<code>BBUncrustifyPlugin Preferences</code>去改变插件参数配置。</li>
</ol>


<h2>UncrustifyX可视化配置你的代码规范</h2>

<p>你想要的代码规范是怎么样的，你可以参考<a href="http://uncrustify.sourceforge.net/">这里</a>去直接编辑文件设置你要的格式，你也可以使用UncrustifyX这个可视化工具配置，推荐后者，这样会有感官。你可以到<a href="https://github.com/ryanmaxwell/UncrustifyX/releases">这里</a>下载最新版本安装。</p>

<h2>git commit hooks(这里使用Git版本控制)</h2>

<p><a href="https://github.com/githubbrowser/Pre-commit-hooks">这里</a>有已经写好的<code>pre-commit-uncrustify(rename为pre-commit)</code>、<code>canonicalize_filename.sh(一个定位路径输出的文件)</code>可以下载，把这个两个文件<code>copy</code>到你的本地项目仓库的<code>.git/hooks</code>文件夹下面,值此就可以生效了，不过别忘了做一下配置，像如下的：</p>

<ol>
<li>设置uncrustify的路径像我这里的的路径为<code>/Applications/UncrustifyX.app/Contents/Resources/uncrustify</code>.</li>
<li>设置uncrustify配置位置，我这里路径为<code>$HOME/.uncrustify/uncrustify.cfg</code>.</li>
</ol>


<h2>git receive hooks</h2>

<p><code>commit</code>可能还不能满足要求，我们为了统一代码规范，需要在<code>git</code>服务端检查，规范不符合我们团队的我们就拒绝<code>push</code>,所以需要在<code>receive</code>的时候也触发调用。<a href="">这里</a>这里有我自己参考资料改的一个<code>pre-receive</code>文件可以达到上述要求，你下载完成后把<code>pre-receive</code>、<code>canonicalize_filename.sh</code>一并<code>copy</code>到服务端你的项目仓库的hooks目录下面,至此就会生效了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理APP状态转换的策略]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/22/chu-li-appzhuang-tai-zhuan-huan-de-ce-lue/"/>
    <updated>2016-07-22T16:01:54+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/22/chu-li-appzhuang-tai-zhuan-huan-de-ce-lue</id>
    <content type="html"><![CDATA[<h1>处理APP状态转换的策略(Strategies for Handling App State Transitions)</h1>

<p>  对于每一个APP可能的运行时状态，你的APP在进入每一个状态的时候系统都有不同的预期。但状态迁移发生时，系统通知这个APP对象，这个APP对象通知它自己的代理对象。你能使用<code>UIApplicationDelegate</code>协议的状态迁移方法去发现这些状态的改变和作出适当的响应。</p>

<h2>在APP启动时间做些什么(What to Do at Launch Time)</h2>

<p>  当你的APP已经启动(无论是进入前台和是后台)，使用你的APP代理方法<code>application:willFinishLaunchingWithOptions:</code>和 <code>application:didFinishLaunchingWithOptions:</code>去做一下这些。</p>

<ul>
<li>检查启动选项字典的内容得到关于为什么这个APP已经启动信息并作出适当的响应。</li>
<li>初始化你的APP关键的数据结构。</li>
<li><p>准备你的APP作为显示的窗体(window)和视图(views)</p>

<p>在启动时间，系统自动加载你的APP的主故事板(storyboard)文件和加载初始的视图控制器(view controller)。关于APP支持的状态恢复，在调用<code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法中间，APP状态恢复机械的恢复你的界面到以前的状态。使用<code>application:willFinishLaunchingWithOptions:</code>方法去显示你的APP窗体(window)和去确定状态恢复是否全部发生。使用<code>application:didFinishLaunchingWithOptions:</code>方法去对你的APP界面做最后的调整。</p>

<p>你的<code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法中应该做尽可能少的事情去减少你的APP的启动时间。APP是预期去启动初始化它们自己并在五秒之内开始处理事件。如果一个APP没有及时的结束它的启动周期，系统会终止它。所以，任何可能减慢你的启动的任务(例如访问网络)应该安排它执行在一个次要的线程上。</p></li>
</ul>


<h3>启动周期(The Launch Cycle)</h3>

<p>  当你的APP已经启动，它从没运行状态(not running)进入到活动状态(active)或者后台状态(background)，迁移短暂的进入到不活动状态作为过渡(inactive)。作为启动周期的一部份，系统为你的APP创建一个过程和主线程并在主线程上调用你APP的主函数(main function)。进来这个默认的主函数随着你的Xcode项目迅速的传递控制到UIKit框架上面，这个主函数大部分的工作是初始化你的APP和为APP运行做准备。
  当你的APP启动进入后台(background)时-通常去处理一些后台事件类型，和启动进入前台主要不同的是你的APP不是活动的(active),它进入后台状态去操作事件，在操作完时间之后可能会在任何时间挂起。当启动进入后台时，系统任然加载你的APP用户界面文件但是它不显示APP窗体(window)。
   去确定你的APP是进入前台还是后台，在你的<code>application:willFinishLaunchingWithOptions:</code>或者<code>application:didFinishLaunchingWithOptions:</code>代理方法中检查共享的<code>UIApplication</code>对象的<code>applicationState</code>属性值。当你的APP是进入的前台，这个属性值是<code>UIApplicationStateInactive</code>。当你的APP启动进入了后台，这个属性值是<code>UIApplicationStateBackground</code>，你能使用这个值去调整你的代理方法做相应的启动时间行为。</p>

<h3>横屏模式启动(Launching in Landscape Mode)</h3>

<p>  APP只有使用横屏模式启动它们的界面必须明确的告诉系统这个APP的启动方向。通常的，APP启动在竖屏模式然后界面旋转匹配设备需要的方向。关于APP支持的竖屏和横屏方向，你应该总是配置你的视图到横屏模式然后让你的视图控制器去操作任何的旋转。如果APP支持横屏单不支持竖屏方向，执行以下的几个任务去制作它初始横屏启动。</p>

<ul>
<li> 添加<code>UIInterfaceOrientation</code>键到你的APP的<code>Info.plist</code>文件，设置这个键的值为 <code>UIInterfaceOrientationLandscapeLeft</code>或者<code>UIInterfaceOrientationLandscapeRight</code>其中一个。</li>
<li> 布局你的视图在横屏模式，确保它们的布局或者自动尺寸选项是设置正确的。</li>
<li><p> 覆盖你的视图控制器的<code>shouldAutorotateToInterfaceOrientation:</code>方法，当旋转到横屏方向的left或者right时返回YES，当旋转到竖屏方向是返回NO。</p>

<pre><code>    Important:APP应该总是使用视图控制器去管理它们基于窗口的内容
</code></pre></li>
</ul>


<p>  这个<code>UIInterfaceOrientation</code>键在<code>Info.plist</code>文件告诉iOS它应该配置APP的状态栏的方向(如果有一个显示的)此外通过视图控制器在启动时间管理视图的方向。视图控制器考虑这个键然后设置他们的视图的初始方向去匹配。使用这个键等同于在早期的 <code>applicationDidFinishLaunching:</code>方法中调用UIApplication对象的<code>setStatusBarOrientation:animated:</code>方法。</p>

<h3>在第一次启动安装APP特定的数据文件(Installing App-Specific Data Files at First Launch)</h3>

<p>  你能利用你的APP第一次启动周期去建立任何数据和需要去运行的配置文件。APP特定的数据文件应该创建在你的APP沙盒的Library/Application Support/<bundleID>/目录，<bundleID>是你的APP包(bundle)标识。你能进一步细分这个目录去组织你需要的数据文件。你能同样创建文件在另外的目录，例如你的APP iClound容器目录或者本地Documents目录，这个主要根据你的需要。
   如果你的APP包(bundle)包含了你计划去改变的文件，复制这些文件到一个可以修改文件的目录，如果你直接在包(bundle)里面修改它们，那么你的APP的签名会无效，因为APP包(bundle)是代码签名了的，签名无效以为着你的APP在将来启动的时候回被系统阻止，你唯一方法是把这些要修改的文件复制到应用程序沙盒支持的可写的目录然后才能安全的使用这些文件。</p>

<h2>当你的APP暂时的中断时干些什么(What to Do When Your App Is Interrupted Temporarily)</h2>

<p>一个基于提醒的中断导致你的APP暂时失去控制，你的APP继续运行在前台，但是不接收任何来自系统的触摸事件(它不继续去接收通知和另外的事件类型，例如加速计事件)。去响应这个改变，你的APP应该在<code>applicationWillResignActive:</code>方法中做一下的事。</p>

<ul>
<li>保存数据和任何相关的状态信息.</li>
<li>停止计时器和另外的定期任务.</li>
<li>停止运行任何元数据查询.</li>
<li>不开始任何新任务。</li>
<li>暂停电影播放(通过AirPlay播放除外).</li>
<li>如果是游戏就使游戏进入一个暂停状态。</li>
<li>调节减慢OpenGL ES帧速率.</li>
<li><p>暂停任何调度队列(dispatch queues)或者操作队列(operation queues)去执行非关键的代码。(你能继续处理网络请求和另外时间灵敏的后台任务在不活动状态(inactive)).</p>

<p>当你的APP迁移回活动(active)状态，它的<code>applicationDidBecomeActive:</code>方法应该反转在<code>applicationWillResignActive:</code>方法中做得任何步骤，你的APP应该重新启动计时器，恢复调度队列，加速OpenGL ES帧速率。无论如何，游戏不应该自动恢复，它们应该保持在暂停状态知道用户选择去恢复它们。</p></li>
</ul>


<p> 当用户按压休眠/唤醒按钮，APP设置了<code>NSFileProtectionComplete</code>保护选项保护文件，这时必须关闭所有对这些文件的引用。设备配置一个适当的密码，按压休眠/唤醒按钮锁定屏幕会强制系统扔掉文件的解密秘钥使其能起到完整的保护。在这个屏幕锁定期间，任何企图去访问相应的文件将失败。如此如果你有这样的文件，你应该在你的<code>applicationWillResignActive:</code>方法中关闭任何对这些文件的引用和在你的<code>applicationDidBecomeActive:</code>方法中打开新的引用。</p>

<pre><code>    Important:总是在你的APP的适当的检查点保存数据，尽管你能使用APP状态迁移去强制对象去写未保
    存的数据到磁盘，但是绝不等到一个APP的状态迁移去保存数据。例如，一个视图控制器管理用户数据应
    该在它离开(dismissed)时保存数据
</code></pre>

<h3>暂时中断的响应(Responding to Temporary Interruptions)</h3>

<p>当一个基于提醒的中断发生，例如你一个进来的电话，APP暂时移动到不活动状态如此系统能提示这个用户如何继续下去。APP停留在这个状态直到用户关闭了这个提醒(alert)。在这一点上，APP返回到活动状态或者后台状态。</p>

<p>设置通知作为横幅显示的不会是你的APP不活动(不影响你APP)，基于提醒的APP才会影响(如上)，这个横幅显示在APP窗体顶部的边缘，你的APP可以继续接收触摸事件就像以前一样。无论如何，如果用户拉下这个横幅去显示这个通知中心，你的APP会移动到不活动状态就像发生了一个基于提醒的通知一样。你的APP保持在这个不活动状态直到用户消散(或者关闭反正就是不显示在屏幕上了)了这个通知中心或者启动了另外的APP。在这些情况上，你的APP移动到相应的活动或者后台状态。用户能够使用设置APP(Settings app,就是手机上设置你可以单独设置每个应用的设置地方)去配置那个显示横幅方式的通知和那个显示基于提醒的通知。</p>

<p>按休眠/唤醒按钮是另外一种中断类型，这个引起你的APP临时不活动。当用户按了这个按钮，系统使触摸事件失效(就是系统整个不再接收触摸事件)，移动APP到后台，设置APP的<code>applicationState</code>属性值为<code>UIApplicationStateBackground</code>和锁定屏幕。锁定屏幕对于APP来说是额外的后果，用户数据会保护到加密文件。</p>

<h2>当你的APP进入前台状态时做什么(What to Do When Your App Enters the Foreground)</h2>

<p>返回到前台状态你的APP有机会去重新启动在它移动到后台时停止的任务。</p>

<pre><code>Note:当你的APP重新进入前台这个UIApplicationWillEnterForegroundNotification
通知是可以获得的。在你的APP里的对象可以去使用默认的通知中心注册这个通知。
</code></pre>

<h3>准备处理排队通知(Be Prepared to Process Queued Notifications)</h3>

<p>  一个APP在挂起状态当它返回到前台或者后台执行状态时必须准备好去处理任何排队通知。一个挂起的APP不处理任何代码，因此也不能处理通知相关方向的改变，时间的变化，偏好的变化，和许多会影响APP外观和状态的变化。确保这些改变没有丢失，系统排队了许多相关的通知，直到APP再一次开始执行代码才交付这些通知给APP（前台或者后台任意一个状态）。为了防止当APP恢复时通知过多时APP发生过载，系统合并事件（每一个相关的事件），这些事件反映的是是你的APP自暂停以来的净变化(net change).</p>

<p>下表中的通知可以合并和交付到你的APP的。大部分这些通知是直接交付到你注册的观察者。像这些与设备方向改变相关的，是典型的通过系统框架拦截然后用另外的方法交付给你的APP。</p>

<table>
<thead>
<tr>
<th>                    事件       </th>
<th style="text-align:center;">                  通知                           </th>
</tr>
</thead>
<tbody>
<tr>
<td> 一个配件连接或者断开连接          </td>
<td style="text-align:center;"> EAAccessoryDidConnectNotification与EAAccessoryDidDisconnectNotification </td>
</tr>
</tbody>
</table>


<p>|设备方向改变                     | UIDeviceOrientationDidChangeNotification除了这个通知，视图控制器自动的更新他们的界面方向 |</p>

<p>|一个有重大意义(significant)的时间变化|UIApplicationSignificantTimeChangeNotification|</p>

<p>|电池电量等级改变(The battery level)或者电池状态改变|UIDeviceBatteryLevelDidChangeNotification与UIDeviceBatteryStateDidChangeNotification|</p>

<p>|接近状态改变(例如接近传感器)|UIDeviceProximityStateDidChangeNotification|</p>

<p>|文件保护状态改变|UIApplicationProtectedDataWillBecomeUnavailable与UIApplicationProtectedDataDidBecomeAvailable|</p>

<p>|一个外部的显示连接或者断开连接|UIScreenDidConnectNotification与UIScreenDidDisconnectNotification|</p>

<p>|屏幕显示模式改变|UIScreenModeDidChangeNotification|</p>

<p>|你的APP偏好通过Settings app暴露出来被更改|NSUserDefaultsDidChangeNotification|</p>

<p>|当前语言或者区域设置改变|NSCurrentLocaleDidChangeNotification|</p>

<p>|用户的云账户状态改变|NSUbiquityIdentityDidChangeNotification|</p>

<p>  排队通知是交付到你的APP的主运行循环(run loop)并且通常是交付在任何触摸事件或者另外的用户输入以前。大部分APP应该尽可能足够快的去处理这些事件那样在恢复时才将不会引起任何明显的滞后。无论如何，当你的APP从后台状态返回如果它出现了迟钝，使用Instruments去确定是是否你的通知处理代码引起了延迟。
  一个APP返回到前台同样接收任何视图的视图更新通知，这些是自从最后一次更新以来需要重新更新的视图。一个APP运行在后台任然可以调用<code>setNeedsDisplay或setNeedsDisplayInRect:</code>方法去请求视图的更新。因外这个视图没有显示，系统合并这些请求当APP返回到前台后更新。</p>

<h3>处理云(iClound)变化(Handle iCloud Changes)</h3>

<p>  处于任何理由的iClound状态改变，系统交付 <code>NSUbiquityIdentityDidChangeNotification</code>通知给你的APP。当用户登录或者登出一个iClound账户或者启用或者禁用文档和数据同步这个iClound状态会改变。这个通知是提示你的APP去更新缓存和任何iClound相关的用户界面元素去适应这个改变。例子，当用户登出iClound，你应该移除所有基于iClound文件或者数据的引用。
  如果你的APP已经提示用户是否去存储文件到iClound，当iClound状态改变是不会再次提示用户。在第一次提示用户之后，存储用户的选择到你的APP的本地偏好里面。你可能接下来想使用一个设置包(Settings bundle)或者作为在你APP里面的一个选项去暴露这个偏好。但是再次重复提示除非偏好目前没有在你的用户默认数据库里面。</p>

<h3>处理区域变化(Handle Locale Changes)</h3>

<p> 在你的APP挂起期间如果用户改变了当前的区域，当你的APP返回到前台时你能使用<code>NSCurrentLocaleDidChangeNotification</code>通知去强制更新任何视图包含了区域敏感(locale-sensitive)信息，例如时间，计时器，和数字。当然，最好的避免区域相关问题方法是去用你的方式写代码去制作它简单的更新视图。</p>

<h3>处理改变你的APP设置(Handle Changes to Your App’s Settings)</h3>

<p>如果你的APP的设置是通过Settings app管理的，他观察 <code>NSUserDefaultsDidChangeNotification</code>通知。应为用户能改变设置在你的APP挂起或者进入后台期间，你能够使用这个通知去响应那些设置中重大的改变。有时候，响应这个通知能够帮助你关闭一个潜在的安全漏洞。例子，一个邮件程序应该响应用户账户信息的改变。未能监测这些变化可能会引起隐私或者安全问题。典型的，当前的用户可能能够使用旧的账户信息去发送邮件，甚至这个账户不在属于这个用户了。
根据接收这个<code>NSUserDefaultsDidChangeNotification</code>通知，你的APP应该重新载入任何相关的设置，必要时，适当重置它的用户界面。如果密码或者另外的安全相关的信息改变了，你应该同样隐藏任何先前的显示信息，强制用户去键入新的密码。</p>

<h2>当你的APP进入后台时做什么(What to Do When Your App Enters the Background)</h2>

<p>当从前台移动到后台执行，使用你的app代理的<code>applicationDidEnterBackground:</code>方法去做以下的事:</p>

<ul>
<li>准备去拿你APP的照片。当你的<code>applicationDidEnterBackground</code>方法返回时，系统拿你的APP用户界面的图片去使用这个结果图片做动画迁移。如果你的用户界面的视图包含了任何的敏感信息，在调用<code>applicationDidEnterBackground</code>方法返回之前你应该隐藏或者修改这些视图。如果你添加了新的视图到你的视图层级并作为这个过处理的一部分，你必须强制这些视图去绘制。</li>
<li>保存任何APP相关的状态信息。在进入后台之前，你的APP应该已经保存了所有的用户关键数据。使用迁移到后台去保存任何最后一分钟的变化到你的APP状态。</li>
<li>根据需要释放内存。释放任何你不需要的缓存数据和做任何简单的清理，这个能够减少你APP的内存占用。APP占用太大的内存系统会第一个终止它，如此释放你不需要的图片资源，数据缓存，和任何另外的对象。</li>
</ul>


<p>你的APP代理<code>applicationDidEnterBackground</code>方法有大约五秒钟去结束任何未完成的任务然后返回，事实上，这个方法应该尽可能快的返回。如果这个方法在时间耗尽以前还没有返回，你的APP会被终止占用的内存会被释放。如果你任然需要更多的时间去执行任务，调用<code>beginBackgroundTaskWithExpirationHandler</code>方法去请求更多的后台执行时间，还有就是开启一个长运行任务在次要的线程。不管你是否启动任何后台任务，<code>applicationDidEnterBackground</code>方法在五秒钟之内任然必须退出。</p>

<pre><code>    Note:系统除了调用applicationDidEnterBackground方法之外还发送
    UIApplicationDidEnterBackgroundNotification通知，你可以使用这个通知去分布清理任
    务到你的APP的另外的对象
</code></pre>

<h3>后台迁移周期(The Background Transition Cycle)</h3>

<p>当用户按了Home键，按了休眠/唤醒键，或者系统启动了另外一个APP，当前的前台APP迁移到不活动状态接着迁移到后台状态。这些迁移结果导致调用APP的代理<code>applicationWillResignActive:</code> 和<code>applicationDidEnterBackground:</code>方法<code>applicationDidEnterBackground:</code>方法返回后，不久后大部分的APP移动到挂起状态。APP可以请求指定的后台任务(例如音乐播放)或者请求一点额外执行时间让这个APP就能够继续运行一段时间。</p>

<h3>准备APP快照(Prepare for the App Snapshot)</h3>

<p>APP的<code>applicationDidEnterBackground:</code>方法返回后不久，系统拿一个APP窗体的快照。同样的，当一个APP唤醒去执行后台任务时，系统可能拿一个快照去反映任何相关的改变。
如果你制造改变在APP马上进入后台时，你能调用主视图的<code>snapshotViewAfterScreenUpdates:</code>方法去强制这些改变去渲染。关于快照调用一个视图的<code>setNeedsDisplay</code>方法是无效的因为快照是拿下一个绘制周期以前的，因此阻止任何改变被渲染。调用<code>snapshotViewAfterScreenUpdates</code>并传入参数YES强制立即更新到基础缓冲区给快照机器使用(the snapshot machinery uses.)。</p>

<h3>降低你的内存占用(Reduce Your Memory Footprint)</h3>

<p>每个APP在马上进入后台时应该释放许多的内存这种做法是实用的。系统在同一时间视图保持许多的APP在内存里当它可以能够如此的话，但是当内存运行比较低的时候系统会终止挂起的APP来回收内存。当在后台期间APP消耗大量的内存那么它会第一个被终止。
实际上来说，当你的APP不在对这个对象需要时你的APP应该移除对这个对象的强引用，移除强引用给编译器有能力去立即释放这个对象，如此相应的内存能够回收。无论如何，如果你想去缓存一些对象去改善性能，你能等到直到APP迁移到后台以前移除对这些对象的引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac上安装Visual Studio Code开发Asp.Net应用程序]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/21/zai-macshang-an-zhuang-visual-studio-codekai-fa-asp-dot-netying-yong-cheng-xu/"/>
    <updated>2016-07-21T11:02:25+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/21/zai-macshang-an-zhuang-visual-studio-codekai-fa-asp-dot-netying-yong-cheng-xu</id>
    <content type="html"><![CDATA[<p>  现在微软出了新的跨平台编译器Visual Studio Code，能够横跨Linux、Mac、Windows并在其上面进行web开发，现在ASP.NET已经出到了5.0了而且MVC框架也已近出到6.0.下面我就来写我在Mac上安装Visual Studio Code和与其依赖的环境。</p>

<h2>安装Visual Studio Code</h2>

<p>  可以在<a href="https://code.visualstudio.com/c?utm_expid=101350005-24.YOq70TI1QcW9kAbMwmhePg.2">这里</a>下载Visual Studio Code的安装包，下载到硬盘后把下载的包拖到你机器的Application目录中就安装完成了，现在的最新版本是Visual Studio Code 1.3。
  下载完成后你可以安装相应的扩展（除了第一个强烈要求安装外其余的可以看各自需要）：
  * C# for Visual Studio Code (powered by OmniSharp)(启动VS Code按(⌘+P)快捷键然后复制ext install csharp命令到扩展查询框中接着按enter键。这个扩展提供了高亮语法，Debugging等的支持)
  * Auto Close Tag(安装方法类似上面的)</p>

<h2>安装.NET Core SDK</h2>

<p>  Net Core是什么，其实可以看做是一个所有微软框架的基础，他是.Net Framework和跨平台框架mono(mono其实是更具.Net Framework重新实现的跨平台版本)的基石，以前的.Net Framework框架和mono是两个独立的框架，那么可能有些与跨平台无关的代码重复实现了，现在有Net Core框架，他是所有的微软框架的技术栈，都是依托它搭建起来，当然现在还才开始，Net Core实现的内容还不多，不过微软以后的趋势就是这样的。</p>

<h3>安装.NET Core前必须确保安装了openssl的最新版本，用brew安装可以用以下命令</h3>

<pre><code>    brew install openssl
    brew link --force openssl
</code></pre>

<p>然后在<a href="https://download.microsoft.com/download/0/A/3/0A372822-205D-4A86-BFA7-084D2CBE9EDF/dotnet-dev-osx-x64.1.0.0-preview2-003121.pkg">这里</a>下载安装.NET Core就可以了。</p>

<p><code>注意：如果你安装了oh-my-zsh，你可能会遇到一个错误，安装完.NET Core后它的dotnet命令没有在你的PATH里面，你可以用命令(sudo ln -s /usr/local/share/dotnet/dotnet /usr/local/bin)修复它</code></p>

<h3>现在你可以初始化一些代码了</h3>

<p>用以下命令初始化一个简单的Hello World应用</p>

<pre><code>    mkdir hwapp
    cd hwapp
    dotnet new
</code></pre>

<h3>运行应用程序</h3>

<p>下面的第一个命令将恢复指定在project.json文件中的包，第二个命令将运行实际的项目。</p>

<pre><code>    dotnet restore
    dotnet run
</code></pre>

<h3>你可以创建一个web站点</h3>

<ol>
<li>就利用上面的项目，你可以更新上面的项目的project.json文件，在中间添加一行依赖于Kestrel HTTP服务包，加入后记得运行dotnet restore命令去恢复包，加入后大概类似以下部分。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0-*&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;buildOptions&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;debugType&quot;</span><span class="p">:</span> <span class="s2">&quot;portable&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;emitEntryPoint&quot;</span><span class="p">:</span> <span class="kc">true</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{},</span>
</span><span class='line'>  <span class="nt">&quot;frameworks&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;netcoreapp1.0&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;Microsoft.NETCore.App&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>          <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;platform&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="nt">&quot;Microsoft.AspNetCore.Server.Kestrel&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>      <span class="nt">&quot;imports&quot;</span><span class="p">:</span> <span class="s2">&quot;dnxcore50&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>添加一个Startup.cs(这个文件是所有的web的入口，是必须的)文件去定义请求逻辑，类似以下：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Builder</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Hosting</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Http</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">aspnetcoreapp</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">app</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="n">context</span> <span class="p">=&gt;</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="s">&quot;Hello from ASP.NET Core!&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>更新修改Program.cs去建立和启动这个Web主机(host):</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Hosting</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">aspnetcoreapp</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebHostBuilder</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseKestrel</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span><span class='line'>            <span class="n">host</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>运行这个APP(这个dotnet run命令在这个APP有改动的时候自动编译它再运行)</p>

<pre><code> dotnet run
</code></pre></li>
<li><p>在浏览器键入<a href="http://localhost:5000">http://localhost:5000</a>打开这个web网站(你可以用Ctrl+C停止这个服务)</p></li>
</ol>


<h2>利用Yeoman来生成一个项目模板</h2>

<p>Yeoman是一个完整项目生成器，他是一个开源的工具，他可以生成出来像一个Visual Studio项目模板等等。</p>

<h3>安装Yeoman</h3>

<p>首先要安装Yeoman所依赖的Node.js,你可以<a href="https://nodejs.org/en/">这里</a>下载安装Node.js.然后要安装npm,可以在<a href="https://www.npmjs.com">这里</a>下载安装。接下来用npm安装Yeoman,bower,grunt和gulp</p>

<pre><code>    sudo npm install -g yo bower grunt-cli gulp
</code></pre>

<p>安装ASP.NET模板生成器（-g标识是全局生成器，可以再任何路径使用）</p>

<pre><code>    sudo npm install -g generator-aspnet
</code></pre>

<h3>创建一个ASP.NET应用</h3>

<p>键入如下命令</p>

<pre><code>    mkdir src
    cd src
    yo aspnet
</code></pre>

<p>选中Web Application选项按enter，键入项目名字mywebapp,然后键入一下命令</p>

<pre><code>    dotnet restore
</code></pre>

<p>编译和运行可以键入一下命令,其中dotnet build是可选命令，每次运行时都会重新编译一下。</p>

<pre><code>    dotnet build
    dotnet run
</code></pre>

<p>打开浏览器，导航到<a href="http://localhost:5000">http://localhost:5000</a>可以看界面。至此一个简单web站点搭建成功。</p>

<h3>利用yo可以添加类到现存项目中</h3>

<p>进入如下命令</p>

<pre><code>    yo aspnet:Class Person
</code></pre>

<p>结果是一个命名为Person.cs的文件被建立，如下Person:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">MyNamespace</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="nf">Person</span><span class="p">()</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>扩展</h2>

<p>  ASP.NET 5.0已经正式更名为 ASP.NET CORE,现在都存在于.NET Core SDK中。
  关于Kestrel,它是一个跨平台的web服务是基于<a href="https://github.com/libuv/libuv">libuv</a>的，你添加Kestrel的支持必须添加Microsoft.AspNetCore.Server.Kestrel到你的项目的project.json依赖列表中。Kestrel他是跑到一个代理服务后面的(例如IIS或者Nginx),它自己是不面向网络的，你可以在一个服务中配置代理请求转发到Kestrel处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展App的行为]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/kuo-zhan-appde-xing-wei/"/>
    <updated>2016-07-12T18:30:04+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/kuo-zhan-appde-xing-wei</id>
    <content type="html"><![CDATA[<h1>引言</h1>

<p>此篇文章几乎是对照着Apple文档翻译，某些地方是按照自己理解翻译的，难免有理解和翻译不当的地方，在此告知。</p>

<h1>扩展APP行为</h1>

<p>每一个新的Xcode项目从配置好到马上运行在iOS模拟器或者设备上。但是简单的能够运行在一个设备上并不意味着你的APP准备好传送到APP Store上。每一个APP都需要一定量的定制去确保给用户一个好的用户体验。定制的范围从给APP一个图标到制作一个建筑级别决定你的APP如何去呈现和使用信息。这些定制的行为可以再APP的计划过程中尽早的考虑。</p>

<h1>具体的可以分为以下几项</h1>

<h2>提供所需的资源</h2>

<h3>你创建每一个APP都必须有接下来的资源集合和元数据如此它才能正确的显示在设备上。</h3>

<ol>
<li>一个信息属性列表文件。这个Info.plist文件包含了你的APP的元数据，系统使用这些信息去和你的APP交互。Xcode会自动的基于你的项目的配置和设置创建这个文件。如果你想直接的查看或者修改这个内容，你能操作你的项目的Info选项卡。</li>
<li>一个APP所需能力的声明。每一个APP必须声明它运行时所需要的硬件能力或者特性.APP Store使用这个信息确定是否能够在一个特定的设备上运行你的APP。你能够在Info选项卡的"Required device capabilities"条目上编辑你的APP需要量列表。</li>
<li>一个或者多个图标。系统在用户设备主屏幕上显示的你的APP的图标。系统可能显示在设置应用上或者一个查询结果上使用的是你图标其他的版本。</li>
<li>一个或者多个启动图片。当一个APP启动时，系统显示一个临时的图片直到这个APP能够呈现它的用户界面为止。这个临时的图片是你的APP的 启动图片他提供给用户及时的反馈你的APP是正在启动和将要马上准备好了。你必须提供至少一个启动图片，你可能提供了额外的启动图片去解决不同的场景。</li>
</ol>


<p>以上的这些资源是所有的APP必须的但是你包含的应该不仅仅是这些资源。有更多的键Xcode默认没有包含在你的APP的Info.plist文件中。更多额外的键仅仅是当你的APP包含了特定的特性时加入。</p>

<h1>APP包(Bundle)</h1>

<p>当你建立你的APP的时候，Xcode包装它作为一个包(Bundle).一个包(Bundle)在文件系统中是一组相关的资源放在一个地方的目录。一个iOS App包(Bundle)包含一个APP执行文件和所支持的资源文件例如应用程序图标，图片文件，和本地化内容。</p>

<h1>支持用户隐私</h1>

<p>当你设计你的APP的时候保护用户隐私应该作为一个重要考虑。大部分iOS设备包含了用户和设备数据用户可能不想暴露这些数据到应用和外部实体。请记住如果你用一个不恰当的方法去使用数据用户可能会删除你的APP。
访问用户或者设备数据仅仅是当用户了解同意并和适当的法律一致时。另外，采取适当的步骤去保护用户和设备数据清晰的告诉用户你要如何使用这些数据。你可以采用下面的一些好的实践。</p>

<ol>
<li>可以和公司的法律顾问一起看一些来自政府或者行业关于保护移动用户隐私的文档。</li>
<li>请求访问用户或者设备数据有时候是需要的，这个数据是受iOS系统授权设置保护的。考虑在你的Info.plist文件里供应一个用法描述字符串用来解释为什么APP需要用到这个数据。受iOS系统授权设置保护的数据包含位置数据，联系人，日历事件，备忘录，照片和媒体。</li>
<li>明确的告诉用户你将要如何去使用这些数据。</li>
<li>给用户控制这些用户和设备数据。提供设置如此用户能够禁止访问某些需要的敏感数据。</li>
<li>请求使用需要的最少量的用户或者设备数据去完成一个给定的任务。如果不明显的原因或者不必要的原因或者因为你觉得这些数据以后会有用等等这些情况都不要去访问查寻或者收集数据。</li>
<li>采用合理的步骤去保护收集在你的APP中的用户和设备数据。当存储这些信息在本地时，尝试使用iOS数据保护特性 (described in Protecting Data Using On-Disk Encryption)去存储它为一个加密的格式。当你要经过网络发送用户或者设备数据时尝试采用HTTPS连接。</li>
<li>如果你的APP使用了ASIdentifierManager类，你必须考虑它的advertisingTrackingEnabled属性值。如果用户设置这个属性值为NO，使用这个类仅仅是有限的广告目的。</li>
<li>如果你还没有这么做得话，停止使用UDID。这个属性在iOS 5.0已经废弃了。App Store不接受新的APP或者APP更新使用这个标识。作为替代，ASIdentifierManager类的advertisingIdentifier属性是适合的。</li>
<li>如果你的APP支持音频输入，那么仅仅在你实际上计划要开始录音的地方配置你的录音回话（audio session）。如果你没有计划立即录音不要在启动的时候配置你的录音回话（audio session）。在iOS7中，当APP配置他们的录音的录音回话（audio session）时系统会提醒用户，并给用户一个禁用录音的选项。</li>
</ol>


<h1>APP国际化</h1>

<p>因为APP分布在许多的国家，本地化你的APP能帮助你联络到更多的用户。当APP被本地化为他们的母语时，更多的用户可能会使用这个APP。当你把面向用户的内容作为因素插入到资源文件时，本地化这个内容是一个相对简单的过程。
在你可能本地化你的内容以前，你必须使你的APP国际化这样是为了便利本地化的过程。国际化APP牵涉的因素有任何面向用户的内容插入到本地化的资源文件和提供存储内容特定语言项目目录。当使用特定语言和特定地区内容工作时它同样意味着使用恰当的技术（例如时间和数字格式化）
一个完全国际化的APP，本地化过程创建一个新的特定语言资源文件添加到你的项目。一个典型的iOS应用需要接下来这些资源文件类型的本地化版本。</p>

<ol>
<li>Storyboard文件(或者nib文件)-Storyboard能包含文本标签和另外的需要本地化的内容。你可能同样想调整界面项的位置去适应文本长度的改变。（同样的，nib文件能包含你需要本地化的文本或者你需要去更新的布局）</li>
<li>Strings文件-Strings文件（如此命名是因为他们的.strings文件名扩展）包含你的APP显示的静态文本的本地化版本。</li>
<li>Image文件-你应该避免本地化图片除非图片包含了特定的文化内容。在任何时候，你应该避免直接的存储文本在你的图片文件里面。从你的APP里面加载和使用图片，存储文本到一个strings文件，在运行时，把文字内容和图片内容整合在一起。</li>
<li>录像和录音文件-你应该避免本地化多媒体文件，除非他们包含了特定语言或者特定文化的内容。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APP生命周期与后台执行]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/appsheng-ming-zhou-qi-yu-hou-tai-zhi-xing/"/>
    <updated>2016-07-12T18:20:42+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/appsheng-ming-zhou-qi-yu-hou-tai-zhi-xing</id>
    <content type="html"><![CDATA[<h1>引言</h1>

<p>此篇文章几乎是对照着Apple文档翻译，某些地方是按照自己理解翻译的，难免有理解和翻译不当的地方，在此告知。</p>

<h1>APP生命周期（The App Life Cycle）</h1>

<p>APP是在你的自定义代码和系统框架中间复杂的相互作用。这个系统框架提供了所有的APP运行需要的基础结构，你提供的代码需要去定制这个结构和给APP一个样子和你想要的感觉。有效的做这个，它帮助你了解一点点关于iOS的结构和它如何工作的
iOS框架依赖于设计模式，例如MVC和代理在他里面的实现。了解这些设置模式是成功创建一个APP的关键。他同样帮助你熟悉objective-c语言和它的特性。</p>

<h1>APP的结构（The Structure of an App）</h1>

<p>在启动的时候，这个UIApplicationMain函数建立几个关键的对象和开始这个APP运行。每一个APP的核心是UIApplication对象，它的工作是在APP中去便利系统和另外对象的交互。iOS应用都采用了mvc结构，这个模式用来数据视觉呈现时的数据和业务逻辑的分离。这个是去创建APP运行在不同的设备的不同屏幕尺寸上的关键结构。</p>

<h2>iOS应用中各个对象的角色</h2>

<h3>UIApplication对象</h3>

<p>UIApplication对象管理事件的循环和另外的高等级的行为。它同样传达关键的APP迁移和一些特定的事件（例如正到来的推送通知）给它的代理。</p>

<h3>App delegate对象</h3>

<p>这个App delegate是你自定义代码的核心。这个对象和UIAplication对象协力去操作APP的初始化，状态迁移，和许多高等级APP事件。这个对象同样保证在每一个APP中仅仅一个，如此它通常用来建立APP的初始数据结构。</p>

<h3>Documents和data model对象</h3>

<p>Data model对象存储了你的APP内容并且是特定于你的APP的。APP能同样使用document对象（自定义UIDocument子类）去管理一些或者所有的他们的data model对象。Document对象不是必须的，但是它提供一种方便的方法去组织你的数据到一个单个的文件或者文件包中。</p>

<h3>View controller</h3>

<p>UIViewController是所有View controller对象的基类。它提供了默认的功能关于加载视图，呈现他们，旋转他们去响应设备的旋转，和几个另外的标准的系统行为。UIKit和另外的框架定义了额外的View controller类去实现标准的系统界面，例如图片选择器（image picker），tab bar界面和导航界面。</p>

<h3>UIWindow对象</h3>

<p>UIWindow对象协调一个或多个视图的显示。大部分的APP只有一个window，它在主屏幕上呈现内容，但是APP可能有一个额外的视图关于显示内容到一个外部的显示。
去改变你的APP的内容，你使用view controller去改变视图在相应的window里的显示。你永远不可能替换window本身。
除了承载视图，Windows和UIApplication一起工作去交付事件给你的视图和view controllers。</p>

<h3>View对象，control对象和layer对象</h3>

<p>Views和controls提供你的APP的内容的视觉表现。一个view是一个对象，它绘制内容在一个指定的矩形区域，响应这个指定的矩形区域中的事件。Controls是一个专门的view类型，负责实现熟悉的界面对象，例如buttons、text field和toggle switches。</p>

<h1>APP执行状态（Execution States for Apps）</h1>

<p>在任何一个给定的时刻，你的APP都是在下面的任意一个状态。系统在整个系统运行期为了响应动作的发生去迁移你的APP从一个状态到另外一个状态。例如用户按了home键，一个电话打进来或者任何几个其他的中断发生，当前运行的APP响应后去改变自己的状态。一下是一些APP各状态描述。</p>

<h2>没有运行（Not running）</h2>

<p>这个APP没有启动或者在运行但是通过启动终结了。</p>

<h2>未活动（Inactive）</h2>

<p>这个APP运行在前台但是现在不接受事件。（它可能执行另外的代码）一个APP通常只停留在这个状态一瞬间然后他迁移到不同的状态。</p>

<h2>活动(Actice)</h2>

<p>APP运行在前台并且接受事件。这个是一个前台APP标准的模式。</p>

<h2>后台（Background）</h2>

<p>APP后台和执行代码，大部分APP进入这个转态一瞬间就被系统挂起。无论如何，一个APP请求一个额外的执行时间能够保持在这个状态一段时间。另外，一个APP启动时直接进入后台状态而不是未活动（Inactive）状态.</p>

<h2>挂起（Suspended）</h2>

<p>APP进入后台但是没有执行代码，系统自动移动APP到挂起状态并且做这个的时候没有通知。在挂起的期间，APP保持在内存里但是不执行任何代码。
当一个低内存状况发生，系统可能净化挂起的APP去制造更多的空间给前台APP并且做这个的时候没有通知。
大部分的状态迁移都伴随着APP代理方法的调用。这些方法是给你机会用一些适当的方式去响应状态的改变。以下是这些方法的列表。</p>

<h3>application:willFinishLaunchingWithOptions:</h3>

<p>这个方法是在APP启动时第一次机会去执行代码。</p>

<h3>application:didFinishLaunchingWithOptions:</h3>

<p>这个方法是你的APP显示给用户之前运行你执行任何最终的初始化处理。</p>

<h3>applicationDidBecomeActive:</h3>

<p>让你知道你的APP已经变为了前台APP。这个方法给你最后一分钟的准备。</p>

<h3>applicationWillResignActive:</h3>

<p>让你知道你的APP将迁移离开前台APP，使用这个方法把你的APP变为一个静态状态。</p>

<h3>applicationDidEnterBackground:</h3>

<p>让你知道你的APP现在运行在后台状态并且随时可能挂起。</p>

<h3>applicationWillEnterForeground:</h3>

<p>让你知道你的APP已经移动退出了后台状态和返回进入了前台，但是这个还不是活动的状态。</p>

<h3>applicationWillTerminate:</h3>

<p>让你知道你的APP开始终结。如果你的APP挂起了，那么不会调用这个方法。</p>

<h1>后台执行（Background Execution）</h1>

<p>当用户没有积极的使用你的app时，系统会移动这个app到后台状态，许多的APP，在后台状态事实是驻留一瞬间就被系统迁移到挂起状态了。挂起APP这个做法是为改善电池寿命和把系统的重大资源用于新的前台APP以用于吸引用户的手段。
大部分的APP能够相当容易的迁移到挂起状态但是也同样有正当的持续在后台运行的理由。例如一个徒步旅行APP可能想要追踪用户在任何时间的位置这样能够显示航线在徒步旅行地图上面。一个音频APP可能需要在锁屏的时候继续播放音乐。另外一些APP可能需要在后台下载内容如此它能以最小的延迟展现这个内容给用户。当你认为需要你的APP能够在后台运行，iOS帮助你有效的做这些并不耗尽系统资源和用户电池。这个技术通过iOS分成三类提供。</p>

<ol>
<li>APP在前台启动一个短的任务，当APP迁移到后台时能够请求时间去结束这个任务。</li>
<li>APP在前台开始下载能够挪动那些下载的管理给系统管理，从而在下载期间允许APP挂起或者终结。</li>
<li>APP需要在后台运行指定的任务类型，可以声明他们要支持的一个或者多个后台任务模式。</li>
</ol>


<p>总是试图去避免做任何后台工作，除非这么做能够改善整体的用户体验。一个APP迁移到后台的可能的原因有用户启动了一个不同的APP或者因为用户锁定了设备和此时没有使用这个APP.在这两种情况，用户此时不需要你的APP做任何有意义的工作。在这样的条件下继续运行你的APP仅仅是耗尽电池和可能导致用户去强制完全退出你的APP。如此记住在后台你做的工作当你能避免的时候避免。</p>

<h1>执行有限长度的任务（Executing Finite-Length Tasks）</h1>

<p>APP迁移到后台是预期把自己尽可能快的进入到一个静止的转态，如此系统能够暂停他们。如果APP是在一个任务运行的中间和需要一点时间去完成这个任务，它能够调用UIApplication对象的 beginBackgroundTaskWithName:expirationHandler: 或者beginBackgroundTaskWithExpirationHandler:方法去请求一些额外的执行时间。调用这两个方法中的任何一个都可以暂时去延迟你的APP的挂起，给它一点额外的时间去结束这个工作。到这个工作完成的时候，你的APP必须调用endBackgroundTask:方法去让系统知道任务结束了系统能够挂起这个APP了。
每次调用beginBackgroundTaskWithName:expirationHandler: 或者beginBackgroundTaskWithExpirationHandler:方法生成一个唯一的令牌（token）去关联相应的任务。但你的APP完成了一个任务的时候，它必须用相应任务的令牌（token）作为参数去调用endBackgroundTask:方法去让系统知道这个任务完成了。失败去调用endBackgroundTask:方法关于一个后台任务将导致你的应用程序终结。当开始这个任务如果你提供了一个到期终止处理（expiration handler）,这个系统调用这个到期终止处理（expiration handler）给你一个最后的机会去结束任务和避免APP终结。
你不需要去等到你的APP迁移到后台的时候再去指派后台任务。开始一个任务之前，一个更有用的设计是调用beginBackgroundTaskWithName:expirationHandler: 或者 beginBackgroundTaskWithExpirationHandler:方法。等到你的任务结束就调用endBackgroundTask:方法。</p>

<p>在你自己的到期终止处理（expiration handler）中，你能够包含额外的需要去关闭你的任务的代码。你包含的任何代码不能拿太长时间去执行，因为到你调用到期终止处理（expiration handler）时候，你的APP已经很靠近它的时间限制了。因为这个原因，仅仅执行极少的你的状态信息的清理和结束这个任务。</p>

<h1>在后台下载内容（Downloading Content in the Background）</h1>

<p>但下载文件时，APP应该使用一个NSURLSession对象去开始一个下载，如果这个APP挂起或者终结此时系统能拿到这个下载处理的控制。当你配置一个NSURLSession对象作为后台传输用，系统在一个独立的处理里面管理那些传输和以通常的方式报告状态给你的APP。当以传输在进行期间如果你的APP终结了，系统在后台继续这个传输，当这个传输结束或者当一个或多个任务需要你的APP的注意，启动这个APP（当适当的时候）。
去支持后台传输，你必须适当的配置你的NSURLSession对象，去配置这个回话（session），你必须首先创建一个NSURLSessionConfiguration对象和设置这个对象的几个属性到适当的值。当创建这个回话（session）的时候，你接着传递那个配置对象到NSURLSession的适当的初始化方法。</p>

<p>创建支持后台下载配置对象的过程如下：</p>

<ol>
<li>使用NSURLSessionConfiguration的 backgroundSessionConfigurationWithIdentifier: 方法创建配置对象。</li>
<li>设置配置对象的sessionSendsLaunchEvents属性值为YES.</li>
<li>如果你的APP在前台期间启动的下载，推荐你同样设置配置对象的discretionary属性值为YES。</li>
<li>配置这个配置对象任何其他的属性值到适当的值。</li>
<li>使用这个配置对象去创建你的NSURLSession对象。</li>
</ol>


<p>一单配置，你的NSURLSession对象在适当的时候无缝移交这个上传和下载任务给系统。在APP仍然在运行的时候如果你的任务结束（前台和后台任其一的状态），这个回话（session）对象以通常的方式通知它的代理（delegate）。如果这个任务尚未完成此时系统终结了你的APP，这个系统自动的在后台继续管理这个任务。如果用户终结了你的APP，系统取消所有的待执行的任务。</p>

<h1>实现长运行任务（Implementing Long-Running Tasks）</h1>

<p>对于需要更多执行时间去实施的任务，你必须请求指定的许可（specific permissions ）在后台去运行他们，没有他们APP在后台会被暂停。iOS中，只有特定的APP类型能被允许在后台运行：</p>

<ol>
<li>在后台播放有声音的内容给用户的APP，例如音乐播放APP。</li>
<li>在后台录制音频内容的APP。</li>
<li>让用户随时了解他们的位置的APP，例如导航APP。</li>
<li>支持VoIP（Voice over Internet Protocol）的APP。</li>
<li>接收来自外部附件定期更新的APP。</li>
</ol>


<p>实现这些服务（services）的APP必须声明相应的服务，他们支持和使用系统框架去实现那些服务相关的方面。声明服务让系统知道你使用了哪一种服务，但在某些情况下，系统框架实际阻止了你的APP被暂停。</p>

<h2>声明你APP支持的后台任务（Declaring Your App’s Supported Background Tasks）</h2>

<p>支持一些后台执行类型必须通过你的APP提前声明使用它们。在Xcode5以后，你在你项目设置的“Capabilities”标签中声明你的APP所支持的后台模式。启用这个后台模式选项添加UIBackgroundModes键到你的APP的Info.plist文件中。选择一个或者多个检验盒（checkboxes ）添加相应的后台模式值到该键。你能指定以下的后台模式，Xcode会分配这个值到你的APP的Info.plist文件的UIBackgroundModes键中。</p>

<ol>
<li>Audio和AirPlay。</li>
<li>位置更新</li>
<li>VoIP(Voice over IP)</li>
<li>Newsstand下载。</li>
<li>外部附近通信。</li>
<li>使用蓝牙LE附件。</li>
<li>Acts as a Bluetooth LE accessory。</li>
<li>后台拉取。</li>
<li>远程通知。</li>
</ol>


<p>每一个前面的模式让你的系统知道你的APP应该在适当的时间唤醒或者启动去相应相关的事件。</p>

<h1>在后台获得用户的注意（Getting the User’s Attention While in the Background）</h1>

<p>通知是一个当你的APP挂起、在后台或者没有运行需要获得用户注意的方式。APP能够使用本地通知去显示通告，播放声音，以APP的图标为徽章显示，或者这三个的组合。
排定一个本地通知的交付，创建一个UILocalNotification类的实例，配置这个通知的参数，使用UIApplication类的方法计划他。</p>

<h1>选择退出后台执行</h1>

<p>如果你不想要你的APP在任何时候运行在后台，你能够通过添加UIApplicationExitsOnSuspend键（设置值为YES）到你的APP的Info.plist文件来明确的选择退出后台。当一个APP是这样设置的，它将循环在没有运行（not-running），未活跃的（inactive），和活跃（active）状态之间，并且从不进入后台或者挂起状态。当用户按了Home键去退出这个APP，这个APP的代理方法 applicationWillTerminate:会被调用，他终结以前APP大约有五秒时间去清理和退出，迁移到没运行（not-running）的状态。
选择退出后台执行时强烈反对的，但是可能在一定条件下是首选的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins+fastlane持续集成]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/jenkins-plus-fastlanechi-xu-ji-cheng/"/>
    <updated>2016-07-12T16:04:39+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/jenkins-plus-fastlanechi-xu-ji-cheng</id>
    <content type="html"><![CDATA[<h1>iOS持续集成</h1>

<p>用Jenkins配置job,在合适的时机自动触发从git上拉取最新代码、自动构建、自动运行Test最后通过slack通过发送通知形式把结果反馈给team成员。</p>

<h2>安装工具</h2>

<ol>
<li>更新brew包管理工具
$ sudo brew update</li>
<li>安装jenkins
$ sudo brew install jenkins</li>
<li>安装fastlane
$ sudo gem install fastlane</li>
<li>安装fir-cli
$ sudo gem install fir-cli</li>
</ol>


<p>brew error
You can use brew with sudo, but only if the brew executable is owned by root.
However, this is both not recommended and completely unsupported so do so at
your own risk.
解决
$ sudo chown -R root /usr/local
参考：<a href="http://raiko.in/tech/homebrew-cant-sudo/"></a>
<a href="http://lyo.is-programmer.com/posts/39956.html"></a></p>

<p>根证书过期，下载重新安装:
<a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer">根证书下载</a></p>

<h2>fastlane自动构建、自动测试等等</h2>

<ul>
<li>cd [your_project_folder]</li>
<li>fastlane init</li>
<li>Follow the setup assistant, which will set up fastlane for you</li>
<li>Edit Fastfile
<code>``
fastlane_version "1.81.0"
default_platform :ios
platform :ios do
before_all do
   ENV["SLACK_URL"] = "https://hooks.slack.com/services/..."
  #cocoapods
  #increment_build_number
  cocoaPods
  xcodebuild(workspace: "LHAlertCustomViewDevApp.xcworkspace",scheme: "LHAlertCustomViewDevApp",sdk: "iphonesimulator",destination: "platform=iOS Simulator,name=iPhone 6s")
  #gym(workspace: "LHAlertCustomViewDevApp.xcworkspace")
end
desc "Runs all the tests"
lane :test do
  xctest(scheme: "LHAlertCustomViewDevApp",destination: "platform=iOS Simulator,name=iPhone 6s",
    reports: [
      {
        report: "html",
        output: "build/reports/unit-tests.html"
      },
      {
        report: "junit",
        output: "build/reports/unit-tests.xml"
      }
    ],
    clean: nil)
  #scan
end
desc "Submit a new Beta Build to Apple TestFlight"
desc "This will also make sure the profile is up to date"
lane :beta do
  # match(type: "appstore") # more information: https://codesigning.guide
  #gym # Build your app - more options available
  #pilot
  # sh "your_script.sh"
  # You can also use other beta testing services here (run</code>fastlane actions`)
end
desc &ldquo;Deploy a new version to the App Store&rdquo;
lane :appstore do

<h1>match(type: &ldquo;appstore&rdquo;)</h1>

  # snapshot
  #gym # Build your app - more options available
  #deliver(force: true)
  # frameit
end

<h1>You can define as many lanes as you want</h1>

after_all do |lane|
  # This block is called, only if the executed lane was successful
   slack(
     message: &ldquo;Successfully test new App Update.&rdquo;
   )
end
error do |lane, exception|
   slack(
     message: exception.message,
     success: false
   )
end
end
```
在终端输入fastlane test测试自动构建，自动测试是否成功,也可以用xtool来构建和测试工程。

<h2>fir-cli</h2></li>
<li>进入slack.com注册自己的账号，可以自己创建team，也可以加入别的team。</li>
<li>进入<a href="https://ajiosteam.slack.com/services/B0ZRJH8UU?added=1%E7%94%9F%E6%88%90SLACK_URL%E3%80%82">https://ajiosteam.slack.com/services/B0ZRJH8UU?added=1%E7%94%9F%E6%88%90SLACK_URL%E3%80%82</a></li>
<li>设置Fastfile中的slack地址。</li>
</ul>


<h2>jenkins配置</h2>

<ol>
<li>创建job</li>
<li>打开<a href="http://localhost:8080">本地</a></li>
<li>Manage Jenkins > Manage Plugins > Available 安装插件

<ul>
<li>HTML Publisher Plugin</li>
<li>AnsiColor Plugin</li>
<li>Rebuild Plugin</li>
<li>GIT Plugin</li>
</ul>
</li>
<li>上一步结束点击 Back to Dashboard > New Item > 键入Item name > 选择Freestyle project > ok</li>
<li>配置job
<code>
 Source Code Management：/Users/liuhao/Documents/gittest/LHAlertCustomView
 Branches to build：*/master
 Add build step &gt; Execute shell
 Command:
 #!/bin/bash
    source ~/.bash_profile
    cd LHAlertCustomViewDevApp/
    fastlane test
    or
    #!/bin/bash
  export LC_ALL="en_US.UTF-8"
  fastlane test
</code>

<ul>
<li>Save job</li>
</ul>
</li>
<li>自动job

<ul>
<li>Build Triggers > Build periodically
<code>
在每周的工作日的每小时的前半个小时，每过十分钟触发一次
H(0-29)/10 * * * 1-5
</code></li>
</ul>
</li>
</ol>


<h2>参考</h2>

<p><a href="https://github.com/fastlane/fastlane">fastlane</a><br/>
<a href="https://github.com/fastlane/fastlane/blob/master/docs/Jenkins.md">Jenkins Integration</a></p>

<h2>Note</h2>

<h1>error:</h1>

<p>修改文件为可读可写：
<string>&ndash;httpListenAddress=0.0.0.0</string>替换<string>&ndash;httpListenAddress=127.0.0.1</string>
sudo chmod 666  ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</p>

<p>Mac-mini:~ dongmeiliang$ sudo chmod o-w /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Password:
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: Path had bad ownership/permissions
Mac-mini:~ dongmeiliang$ sudo chmod g-w /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded
Mac-mini:~ dongmeiliang$ sudo chmod o-w ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded
Mac-mini:~ dongmeiliang$ vim ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ vim /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ clear
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded</p>

<h2>注意</h2>

<p>如果fastlane编译测试成功
但Jenkins运行编译成功测试失败并报
或者：invalid byte sequence in US-ASCII (ArgumentError)[0m</p>

<p>timeout connect(2)只是以上错误引起的。</p>

<p>可以fix错误
    export LC_ALL=&ldquo;en_US.UTF-8"写到你的shell里面</p>

<pre><code>There are two ways to fix this. You can export language settings to your shell:
</code></pre>

<p>1：不推荐，这样会修改整个系统的设置。
export LANGUAGE=en_US.UTF-8
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
or you can put this into your Gemfile:
2：推荐这个 you can put this into your Gemfile:（可以把一下代码加到你的Gemfile的头部）
if RUBY_VERSION =~ /1.9/
  Encoding.default_external = Encoding::UTF_8
  Encoding.default_internal = Encoding::UTF_8
end
提醒：可以免密码登录
The authorized_keys file corresponds to the conventional ~/.rhosts file, and has one key per line, though the lines can be very
     long.  After this, the user can log in without giving the password</p>
]]></content>
  </entry>
  
</feed>
