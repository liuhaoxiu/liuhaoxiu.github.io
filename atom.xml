<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刘浩的技术博客]]></title>
  <link href="http://liuhaoxiu.github.io/atom.xml" rel="self"/>
  <link href="http://liuhaoxiu.github.io/"/>
  <updated>2017-03-22T08:58:18+08:00</updated>
  <id>http://liuhaoxiu.github.io/</id>
  <author>
    <name><![CDATA[刘浩]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apple推送通知服务]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2017/03/21/appletui-song-tong-zhi-fu-wu/"/>
    <updated>2017-03-21T17:17:31+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2017/03/21/appletui-song-tong-zhi-fu-wu</id>
    <content type="html"><![CDATA[<h2>Apple推送通知服务(Apple Push Notification Service)</h2>

<p>Apple推送通知服务(APNs)是远程通知功能的核心。他是一个关于传播信息到iOS(和，间接的，watchOS),tvOS,和OS X设备的强健和高效的服务。每一个设备建立一个可接受和与APNs加密的IP连接并通过这个持久连接接收通知。如果一个APP的通知到达而这个APP没有运行，设备提醒用户该应用程序有数据等待它。</p>

<p>你提供你自己的服务去生成远程通知给用户。这个服务，被称为提供者，收集用户的数据决定何时需要发送通知。对于每一个通知，提供者生成通知的有效载荷并附加这个有效载荷到一个HTTP/2请求，它接着使用一个持久的和使用HTTP/2多路复用协议的安全通道发送到APNs。根据收到的请求，APNs处理你通知的有效载荷交付给用户设备上的APP。</p>

<p>关于你发送到APNs请求格式的信息，和你可以接收到的响应和错误，看<code>APNs Provider API</code>。关于如何去实现你APP支持的通知，看<code>Registering, Scheduling, and Handling User Notifications</code>。</p>

<h3>远程通知路径(The Path of a Remote Notification)</h3>

<p>Apple推送通知服务传输和路由来自你的提供者关于你APP的远程通知到每一个用户设备。图3-1显示每条通知的路径。当你的提供者确定需要一个通知时，你发送通知和一个设备令牌到APNs服务。APNs服务处理通知路由到正确的用户设备。操作系统处理通知交付到客户端APP。</p>

<p>图3-1 推送一个来自提供者的远程通知到一个客户端APP
<img src="http://liuhaoxiu.github.io/images/remote_notif_simple_2x.png" width="612" height="807"></p>

<p>你提供到服务的设备令牌类似于一个电话号码；它包含启用APNs去定位那个安装了你的客户端APP的设备的信息。APNs也使用它去验证通知的路由。设备令牌通过你的客户端APP提供给你，它自己与远程通知服务注册后接收令牌。</p>

<p>通知有效载荷是一个包含你想去发送到设备的数据的JSON字典。有效载荷包含了你想如何去通知用户的信息，例如使用一个提醒，徽章或者声音。它也可以包含你定义的自定义数据。</p>

<p>图3-2显示一个抽象网络APNs在提供者和设备间可能的更现实的描述。设备面和提供者面与APNs面两者都有多个连接点；在提供者面，这些被称为网关。通常有多个提供者，每一个都通过这些网关制造一个或者多个与APNs持久和安全的连接。这些提供者通过APNs发送通知到更多安装了客户端APP的设备。</p>

<p>图3-2 推送来自多个提供者的远程通知到多个设备
<img src="http://liuhaoxiu.github.io/images/remote_notif_multiple_2x.png" width="612" height="807"></p>

<p>关于获得设备令牌的更多信息，看<code>Token Generation and Dispersal</code>。关于通知有效载荷的信息，看<code>The Remote Notification Payload</code>。</p>

<h3>服务质量(Quality of Service)</h3>

<p>Apple推送通知服务包含一个默认的服务质量部分，它执行一个存储和转发功能。如果APNs试图去交付一个通知但是设备不在线，这个通知在有限的时间里被存储，当设备变得可以获得时交付到设备。只有一个最近的通知为特定的应用程序存储。在设备不在线期间如果多个通知发送，新的通知会引起先前的通知被丢弃。这种行为只保留最新的通知。</p>

<p>如果设备不在线很长一段时间，任何被存储的通知都会被丢弃。</p>

<h3>安全结构(Security Architecture)</h3>

<p>去确保安全通讯，APNs使用两个不同的信任级别：连接信任和令牌信任调节提供者和设备之间的入口点。</p>

<p>连接信任建立了确定性，APNs连接到Apple已经同意交付通知的授权提供者。APNs也使用与设备的连接信任去确保设备的合法性。与设备的连接信任是由APNs自动处理的，但是你必须采取措施去确保在你的提供者和APNs之间连接信任的存在。</p>

<p>令牌信任确保通知只在合法的开始和结束点间路由。令牌信任涉及设备令牌使用，他是在一个特定设备上分配给指定APP的一个不透明标识符。当它与APNs注册时每一个APP接收它唯一的令牌并且必须分享令牌给它的提供者。此后，令牌必须伴随由你的提供者发送的每一个通知。提供令牌确保通知是只交付到它的APP/设备的组合。</p>

<p><code>NOTE:一个设备令牌不是一个唯一ID，你可以使用它去识别一个设备。在一个设备上更新操作系统后设备令牌可能改变。因此，应用程序应该发送他们的设备令牌</code></p>

<p>APNs服务也有必要的证书，CA证书，为了验证连接的加密秘钥(私有和公有)和提供者身份标识和设备。</p>

<h4>提供者对APNs的连接信任(Provider-to-APNs Connection Trust)</h4>

<p>每一个提供者必须有一个唯一的提供者证书和私有加密秘钥，这个是用来验证提供者与APNs连接的。提供者证书(这个是Apple提供的)标识通过提供者主题支持。(一个主题是bundle ID与你的APP其中之一的关联。)</p>

<p>你的提供者与APNs通过TLS对等认证建立连接信任。TLS连接启动之后，你获得来自APNs的服务证书和在你结束时验证这个证书。接着你发送你的提供者证书到APNs，它在结束时验证证书。这个步骤完成之后，一个安全的TLS连接已经建立；APNs现在是满足其连接由一个合法的提供者制造。</p>

<p>图3-3 在提供者和APNs间建立连接信任
<img src="http://liuhaoxiu.github.io/images/service_provider_ct_2x.png" width="612" height="807"></p>

<p>HTTP/2提供者连接对于交付到一个特定的APP是有效的，由证书中指定的主题(bundle ID)标识。根据你如何配置和提供你的APNs SSL证书，这个连接也可以对远程通知交付到任何Apple Watch complications或者与主要APP关联的后台VoIP服务有效。看详细<code>APNs Provider API</code>。APNs也维护证书吊销列表；如果一个提供者证书在这个列表上，APNs可以撤销提供者信任(拒绝连接)。</p>

<h4>APNs对设备的连接信任(APNs-to-Device Connection Trust)</h4>

<p>每个设备有一个设备证书和私有加密秘钥，他是用于验证设备与APNs的连接。设备在设备激活时间时获得证书和密钥并存储它们到钥匙扣(keychain)。</p>

<p>你不需要做任何事来建立APNs与设备之间的连接信任。APNs通过TLS对等认证建立一个连接设备标识。在这个过程中，设备开启一个与APNs的TLS连接，它返回一个他的服务端证书，设备验证这个证书接着发送它的设备证书到APNs，然后APNs验证证书。</p>

<p>图3-4 建立设备和APNs间的连接信任
<img src="http://liuhaoxiu.github.io/images/service_device_ct_2x.png" width="612" height="807"></p>

<h4>令牌生成与扩散(Token Generation and Dispersal)</h4>

<p>应用程序必须与系统注册以接收远程通知,如描述在<code>Registering for Remote Notifications</code>里。收到注册请求后，系统转发请求到APNs，它产生一个唯一的设备令牌，对于应用程序，使用设备证书中包含的信息。它接着使用令牌秘钥加密令牌然后返回它到设备，如图3-5所示。系统交付设备令牌到你的APP使用NSDATA对象交付。接收到此令牌，你APP必须传发它到你的提供者，使用二进制或十六进制格式。没有这个令牌你的提供者不能发送通知到设备。</p>

<p>图3-5 管理设备令牌
<img src="http://liuhaoxiu.github.io/images/token_generation_2x.png" width="612" height="807"></p>

<p><code>Important:APNs设备令牌长度是可变的。不要硬编码他们的大小。</code></p>

<p>图3-6表明令牌生成和扩散序列，但是除了显示的由APNs返回的令牌路径外，随后会转发给你的自定义提供者。</p>

<p>图3-6 共享设备令牌
<img src="http://liuhaoxiu.github.io/images/registration_sequence_2x.png" width="612" height="807"></p>

<h4>令牌信任(通知)(Token Trust (Notification))</h4>

<p>每一个你提供者发送到APNs的通知必须伴随一个与设备关联的设备令牌。APNs使用它的令牌秘钥去解密令牌去确保通知源的有效性&ndash;这里通知源是你的提供者。APNs使用在设备令牌里包含的设备ID去确定目标设备标识。它接着发送通知到这个设备，如图3-7所示。</p>

<p>图3-7 使用设备令牌识别设备
<img src="http://liuhaoxiu.github.io/images/token_trust_2x.png" width="612" height="807"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用AFNetworking 3.x做https安全连接]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2017/01/19/shi-yong-afnetworking-3-dot-xzuo-httpsan-quan-lian-jie/"/>
    <updated>2017-01-19T10:00:20+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2017/01/19/shi-yong-afnetworking-3-dot-xzuo-httpsan-quan-lian-jie</id>
    <content type="html"><![CDATA[<h1>使用AFNetworking 3.x做https安全连接,单向验证</h1>

<h2>制作自签名证书</h2>

<p>对于一般的需求自签名证书足够了，这里可以自己制作一个CA证书，然后用CA给所有你要用到的证书签名，这样你就可以在所有安装了CA证书的iOS设备里面用此CA签名的证书。自己制作CA证书稍后再说(12306就是用的自己的CA颁发的自签名证书)，先讲制作自签名证书。</p>

<h3>如何使用OpenSSL去创建一个自签名的SSL证书</h3>

<p>运行以下下命令去创建，你会跳过问题提示，CN就是你的服务器地址。
<code>openssl req -x509 -sha256 -newkey rsa:2048 -keyout certificate.key -out certificate.crt -days 1024 -nodes -subj '/CN=localhost'req</code>
这个命令会生成两个文件在当前目录，一个私钥文件和一个crt证书文件，你能看到一个.key后缀名的私钥文件，它是没有密码与之关联的，如果你想使用密码，去掉-nodes选项就可以了。</p>

<h3>转换成AFNetworking可识别的cer格式文件</h3>

<p>运行以下命令可以转换格式，然后改成后缀名cer,AFNetworking可识别的。
<code>openssl x509 -in server.crt -outform der -out "server.der"</code></p>

<h3>生成pfx文件</h3>

<p>转成c#能使用的证书，用c#写web api做后台其实格式和java使用的.p12是一样的只是后缀名不同。(此文件包含了私钥和证书)，我这里设置了密码"123"
<code>openssl pkcs12 -export -out certificate.pfx -inkey certificate.key -in certificate.crt</code></p>

<h3>制作CA证书</h3>

<p>其实就是制作一个证书作为CA证书，步骤和制作自签名证书一样，名字不同而已。
<code>openssl req -x509 -sha256 -newkey rsa:2048 -keyout CA.key -out CA.crt -days 1024 -nodes -subj '/CN=localhost'req</code></p>

<h3>使用CA签发证书</h3>

<p>生成csr文件，和一个私有key
<code>openssl req -newkey rsa:2048 -keyout server.key -out server.csr -nodes -subj '/CN=localhost'</code></p>

<p>用自有的CA证书给csr文件签名
<code>openssl x509 -req -sha256 -days 365 -in server.csr -CA CA.crt -CAkey CA.key -CAcreateserial -out server.crt</code></p>

<p>转成c#能使用的证书，用c#写web api做后台其实格式和java使用的.p12是一样的只是后缀名不同。(此文件包含了私钥和证书),我这里设置了密码"123"
<code>openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt</code></p>

<p>可改成后缀名cer,AFNetworking可识别的。
<code>openssl x509 -in server.crt -outform der -out "server.der"</code></p>

<p><code>NOTE:CA验证大概原理是，他会给你的证书公钥、机构、等信息用CA私钥加密然后生成签名放在返回给你的已经签名过的证书里。</code></p>

<h2>AFNetworking与服务端的代码配置</h2>

<p>AFHTTPSessionManager配置代码如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">_sessionManager</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_sessionManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPSessionManager</span> <span class="n">manager</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_sessionManager</span><span class="p">.</span><span class="n">requestSerializer</span><span class="p">.</span><span class="n">cachePolicy</span> <span class="o">=</span> <span class="n">NSURLRequestReloadIgnoringLocalCacheData</span><span class="p">;</span>
</span><span class='line'>        <span class="n">_sessionManager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPResponseSerializer</span> <span class="n">serializer</span><span class="p">];</span>
</span><span class='line'>        <span class="n">AFSecurityPolicy</span> <span class="o">*</span><span class="n">securityPolicy</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFSecurityPolicy</span> <span class="nl">policyWithPinningMode</span><span class="p">:</span><span class="n">AFSSLPinningModeCertificate</span> <span class="nl">withPinnedCertificates</span><span class="p">:[</span><span class="n">AFSecurityPolicy</span> <span class="nl">certificatesInBundle</span><span class="p">:[</span><span class="bp">NSBundle</span> <span class="n">mainBundle</span><span class="p">]]];</span>
</span><span class='line'><span class="n">_sessionManager</span><span class="p">.</span><span class="n">securityPolicy</span> <span class="o">=</span> <span class="n">securityPolicy</span><span class="p">;</span>
</span><span class='line'><span class="n">_sessionManager</span><span class="p">.</span><span class="n">securityPolicy</span><span class="p">.</span><span class="n">allowInvalidCertificates</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span><span class="c1">//不验证证书有效性</span>
</span><span class='line'><span class="n">_sessionManager</span><span class="p">.</span><span class="n">securityPolicy</span><span class="p">.</span><span class="n">validatesDomainName</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span><span class="c1">//不验证域名</span>
</span></code></pre></td></tr></table></div></figure>


<p>把上面准备好的证书，放到APP的bundle里面，和web api项目根目录里面，服务端代码示例</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConfigurationBuilder</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">AddCommandLine</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">AddEnvironmentVariables</span><span class="p">(</span><span class="n">prefix</span><span class="p">:</span> <span class="s">&quot;ASPNETCORE_&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebHostBuilder</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseConfiguration</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseKestrel</span><span class="p">(</span><span class="n">options</span> <span class="p">=&gt;</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">HttpsConnectionFilterOptions</span> <span class="n">httpsoptions</span> <span class="p">=</span> <span class="k">new</span>    <span class="n">HttpsConnectionFilterOptions</span><span class="p">();</span>
</span><span class='line'>                    <span class="n">httpsoptions</span><span class="p">.</span><span class="n">ServerCertificate</span> <span class="p">=</span> <span class="k">new</span> <span class="n">X509Certificate2</span><span class="p">(</span><span class="s">&quot;certificate.pfx&quot;</span><span class="p">,</span> <span class="s">&quot;123&quot;</span><span class="p">);;</span>
</span><span class='line'>                    <span class="n">httpsoptions</span><span class="p">.</span><span class="n">ClientCertificateMode</span> <span class="p">=</span> <span class="n">ClientCertificateMode</span><span class="p">.</span><span class="n">AllowCertificate</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">httpsoptions</span><span class="p">.</span><span class="n">CheckCertificateRevocation</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">options</span><span class="p">.</span><span class="n">UseHttps</span><span class="p">(</span><span class="n">httpsoptions</span><span class="p">);</span>
</span><span class='line'>                <span class="p">})</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseUrls</span><span class="p">(</span><span class="s">&quot;http://192.168.1.89:5000&quot;</span><span class="p">,</span> <span class="s">&quot;https://192.168.1.89:5001&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseContentRoot</span><span class="p">(</span><span class="n">Directory</span><span class="p">.</span><span class="n">GetCurrentDirectory</span><span class="p">())</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseIISIntegration</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">host</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>启动服务，然后客户端访问，发现可以正常访问。</p>

<p>如果需要验证证书的有效性，可以使用CA证书。通过iOS模拟器，直接拖CA证书文件到模拟器界面上然后安装就可以了。客户端代码修改</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//_sessionManager.securityPolicy.allowInvalidCertificates = YES;//注释掉，模式是不允许无效证书的</span>
</span></code></pre></td></tr></table></div></figure>


<p>服务端代码修改</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="n">httpsoptions</span><span class="p">.</span><span class="n">ServerCertificate</span> <span class="p">=</span> <span class="k">new</span> <span class="n">X509Certificate2</span><span class="p">(</span><span class="s">&quot;server.pfx&quot;</span><span class="p">,</span> <span class="s">&quot;123&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后把server.cer证书分别放到客户端和服务端项目里面，启动服务，客户端访问，发现访问成功。</p>

<h2>相关概念</h2>

<p>双向认证的大概步骤：
1. 客户端请求一个受保护的资源
2. 服务端发送它的证书到客户端
3. 如果验证成功，客户端发送它的证书到服务端
4. 服务端验证客户端证书。
5. 如果成功，服务端允许该客户端访问它的受保护的资源</p>

<p><code>NOTE:CA验证证书有效性的过程大概是，因为CA会用私钥签名证书，那么该证书的签名是用私钥加密的，当这个证书从服务端发送过来时，CA证书会用公钥去机密签名而得到证书的公钥，解不开就证明不是此CA颁发的证书，此证书验证无效。</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event Handling Guide之Remote Control Events]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/12/14/event-handling-guidezhi-remote-control-events/"/>
    <updated>2016-12-14T16:31:37+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/12/14/event-handling-guidezhi-remote-control-events</id>
    <content type="html"><![CDATA[<p>远程控制事件是用户去控制你的APP多媒体的一种方法。远程控制事件源于外部附件或者来自通过系统显示的传输控制并通过<code>Media Player framework</code>的类交付到你的APP。APP播放音视频内容使用这些事件去开始和停止播放，改变轨迹，甚至快进一个项(rate an item)。所有的媒体APP都应该支持这些事件。</p>

<p>除了支持远程控制事件，APP可以使用<code>Media Player framework</code>去提供播放的轨迹信息。系统在适当的位置显示播放信息，例如锁屏界面和控制中心。</p>

<p>更多关于<code>Media Player framework</code>的类的信息，看<code>Media Player Framework Reference</code>。</p>

<h2>准备你的APP的远程控制事件</h2>

<p>去接收远程控制事件，做以下几点：</p>

<ul>
<li>注册你支持的每一个action的处理者。使用共享的<code>MPRemoteCommandCenter</code>对象去注册不同事件类型的处理者，详细描述在<code>Handling Remote Control Events</code>里面。</li>
<li>开始播放音频(audio)。你的APP必须是"现在播放"(&ldquo;Now playing&rdquo;)的APP。APP直到它开始播放音频才接收远程控制事件。</li>
</ul>


<p>如果你的APP还提供了包含当前轨迹信息的正在播放的信息，使用<code>MPNowPlayingInfoCenter</code>对象在适当的时间去更新这个信息。更多关于如何去提供现在播放信息，看<code>Providing Now Playing Information</code>。</p>

<h2>处理远程控制事件(Handling Remote Control Events)</h2>

<p>处理一个特定的远程控制事件，与适当的<code>MPRemoteCommand</code>对象注册一个action操作者。<code>Media Player framework</code>定义一个标准<code>MPRemoteCommand</code>对象集合对于处理媒体相关的事件。当一个附件或者iOS接口生成一个远程控制事件时，系统通知相应的<code>MPRemoteCommand</code>对象。这个对象通过执行任何附加的处理程序响应。</p>

<p>你从共享的<code>MPRemoteCommandCenter</code>对象检索远程命令对象。远程命令中心属性包含管理播放对象，切换轨道，和为轨道评级(rating the track)。获取你想去支持的对象，使用一个block或者一个action方法附加一个处理程序。通常，你为每一个命令类型注册一个单个处理程序，如果你需要你也可以注册多个处理程序。以下代码显示当用户想播放一个轨道时如何去注册一个block被执行。在这个例子里，block使用一个自定义的播放对象播放当前选中的音轨。在你的代码里面，执行你需要去播放这个音轨的任何动作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">MPRemoteCommandCenter</span> <span class="o">*</span><span class="n">commandCenter</span> <span class="o">=</span> <span class="p">[</span><span class="n">MPRemoteCommandCenter</span> <span class="n">sharedCommandCenter</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">commandCenter</span><span class="p">.</span><span class="n">playCommand</span> <span class="nl">addTargetUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">MPRemoteCommandEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Begin playing the current track.</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">MyPlayer</span> <span class="n">sharedPlayer</span><span class="p">]</span> <span class="n">play</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你明确不想去支持一个给定的命令，获取这个命令对象并设置它的<code>enabled</code>属性到<code>NO</code>。当你的APP是现在演示的APP时禁用一个远程命令让系统知道它不应该显示任何相关的UI。</p>

<p>一些命令对象让你指定与该命令有关的其它的信息。例如，反馈命令让你指定一个描绘反馈意义的本地字符串。一定要查看参考文档，了解您所支持的特定命令的信息。</p>

<p>对于远程控制命令处理程序的添加和移除的更多信息，看<code>MPRemoteCommand Class Reference</code>。</p>

<h2>提供正在播放的信息(Providing Now Playing Information)</h2>

<p>当播放audio或者video内容时，使用<code>MPNowPlayingInfoCenter</code>对象去提供关于这个内容正在播放的描述信息。<code>MPNowPlayingInfoCenter</code>对象包含一个<code>nowPlayingInfo</code>字典，它的内容描述了正在播放的项目。系统在适当的地方显示字典的信息，例如设备的锁定屏幕。</p>

<p>以下代码显示一个关于如何使用在<code>MPMediaItem</code>里面的信息去配置正在播放的信息的例子。这个例子枚举一组固定的属性，使用结果值去构建一个新的字典这个是接下来分配给<code>MPNowPlayingInfoCenter</code>对象的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">configureNowPlayingInfo:</span><span class="p">(</span><span class="bp">MPMediaItem</span><span class="o">*</span><span class="p">)</span><span class="nv">item</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">MPNowPlayingInfoCenter</span><span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="bp">MPNowPlayingInfoCenter</span> <span class="n">defaultCenter</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSMutableDictionary</span><span class="o">*</span> <span class="n">newInfo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSSet</span><span class="o">*</span> <span class="n">itemProperties</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSSet</span> <span class="nl">setWithObjects</span><span class="p">:</span><span class="n">MPMediaItemPropertyTitle</span><span class="p">,</span>
</span><span class='line'>          <span class="n">MPMediaItemPropertyArtist</span><span class="p">,</span>
</span><span class='line'>          <span class="n">MPMediaItemPropertyPlaybackDuration</span><span class="p">,</span>
</span><span class='line'>          <span class="n">MPNowPlayingInfoPropertyElapsedPlaybackTime</span><span class="p">,</span>
</span><span class='line'>          <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">item</span> <span class="nl">enumerateValuesForProperties</span><span class="p">:</span><span class="n">itemProperties</span>
</span><span class='line'>          <span class="nl">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">newInfo</span> <span class="nl">setObject</span><span class="p">:</span><span class="n">value</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">property</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">info</span><span class="p">.</span><span class="n">nowPlayingInfo</span> <span class="o">=</span> <span class="n">newInfo</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>NOTE:在iOS模拟器里面，在你的nowPlayingInfo字典里总是包含了MPNowPlayingInfoPropertyPlaybackRate键。模拟器使用这个键值去更新显示在控制中心和另外的基于模拟器界面里面的播放进度。对于暂停或者停止的音轨设置这个键值为0。对于一个正在播放的音轨设置这个值为一个正数。</code></p>

<p>更多关于你可以提供的信息类型，看<code>MPNowPlayingInfoCenter Class Reference</code>。</p>

<h2>在设备测试远程控制事件</h2>

<p>测试你的APP接收和处理与控制中心的远程控制事件是正确的，你通过上滑你屏幕的边缘请求。这些控制发送远程控制事件到当前或者是最近播放音频的APP。你也可以在设备的锁定屏幕请求播放控制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APP间通信与APP性能技巧]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/08/12/appjian-tong-xin-yu-appxing-neng-ji-qiao/"/>
    <updated>2016-08-12T11:05:56+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/08/12/appjian-tong-xin-yu-appxing-neng-ji-qiao</id>
    <content type="html"><![CDATA[<h1>APP间通信(Inter-App Communication)</h1>

<p>在一个设备APP间只能间接的通信。你能使用<code>AirDrop</code>去分享文件和数据给另外一个APP。你能同样定义一个自定义<code>URL</code>方案，如此另外的APP能够使用<code>URLs</code>发送信息到你的APP。</p>

<p><code>Note:你能同样使用UIDocumentInteractionController对象或者一个文档选择器(document picker)在APP中间发送文件。</code></p>

<h2>支持AirDrop(Supporting AirDrop)</h2>

<p><code>AirDrop</code>让你分享照片，文档，URLs,和另外的数据类型给你附近的设备。<code>AirDrop</code>采用点对点(<code>peer-to-peer</code>)的网络去寻找附近的设备和连接到它们。</p>

<h3>发送图片和数据到另外的APP(Sending Files and Data to Another App)</h3>

<p>去使用<code>AirDrop</code>发送文件和数据，使用<code>UIActivityViewController</code>去在你的用户界面显示一个活动的层。当创建这个视图控制器时，你指定你想去分享的数据对象。这个视图控制器只显示支持指定数据的那些活动。关于<code>AirDrop</code>你能指定图片，字符串，<code>URLs</code>和几个另外的数据类型。你同样能传递遵循了<code>UIActivityItemSource</code>协议的自定义对象。</p>

<p>去显示一个活动的视图控制器，你能使用如下所示代码那样。这个活动的视图控制器自动使用指定的数据去确定显示在一个活动层中的活动是什么。你不用去明确的去指定这个<code>AirDrop</code>活动。你能使用这个视图控制器的<code>excludedActivityTypes</code>属性阻止显示指定的类型在这个层上。当你显示一个活动视图控制器在<code>iPad</code>的上，你必须使用<code>popover</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">displayActivityControllerWithDataObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">obj</span> <span class="p">{</span>
</span><span class='line'>   <span class="bp">UIActivityViewController</span><span class="o">*</span> <span class="n">vc</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIActivityViewController</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class='line'>                                <span class="nl">initWithActivityItems</span><span class="p">:</span><span class="l">@[</span><span class="n">obj</span><span class="l">]</span> <span class="nl">applicationActivities</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">presentViewController</span><span class="p">:</span><span class="n">vc</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span> <span class="nl">completion</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>接收发送到你APP的文件和数据(Receiving Files and Data Sent to Your App)</h3>

<p>接收使用<code>AirDrop</code>发送到你APP的文件，做以下：</p>

<ul>
<li>在<code>Xcode</code>里面，声明你APP能够打开的文档类型。</li>
<li>在你的APP代理里，实现<code>application:openURL:sourceApplication:annotation:</code>方法.使用这个方法去接收通过另外的APP发送过来的数据。</li>
<li>准备好在你的APP的<code>Documents/Inbox</code>目录查询文件，根据需要移动它们出这个目录。</li>
</ul>


<p>你的Xcode项目<code>Info tab</code>包含了一个文档类型块给你指定你APP支持的文档类型。最低限度，你必须对于文档类型指定一个名称和一个或多个表示数据类型的<code>UTIs</code>。例子，去声明支持<code>PNG</code>文件，你将包含<code>public.png</code>作为<code>UTI</code>字符串。iOS使用指定的<code>UTIs</code>去确定你的APP是否有资格打开给定的文档。
将一个合格的文档传送到你的APP容器之后，iOS启动你的APP(如果需要)和调用你APP代理的<code>application:openURL:sourceApplication:annotation:</code>方法。如果你的APP在前台，你将使用这个方法去打开这个文件和显示它给你的用户。如果你的APP在后台，你可能只决定去标记这个文件在哪里然后你可以之后去打开它。因为通过<code>AirDrop</code>传输的文件是通过数据保护加密的，所以除非设备当前是未锁定的要么你不能够打开这个文件。</p>

<p>使用<code>AirDrop</code>传输到你的APP的文件是放置在你的APP的<code>Documents/Inbox</code>目录。你APP有权限去读和删除在这个目录里面的文件但是它没有权限去写在目录里的文件。如果你打算去修改这个文件，你必须把要修改的文件移出<code>Inbox</code>目录后才能修改。当你不需要这些文件的时候删除它们是被鼓励的。</p>

<p>更多关于在你APP能支持的文档类型看一看<code>Document-Based App Programming Guide for iOS</code>文档。</p>

<h2>使用URL方案去与另外的APP通信(Using URL Schemes to Communicate with Apps)</h2>

<p>一个<code>URL</code>方案让你通过一个你定义的协议去与另外的APP通信。去与一个实现了这样的方案的APP通信，你必须创建一个适当的<code>URL</code>格式告诉系统去打开它。去实现一个自定义方案的支持，你必须声明支持这个方案和处理进来的使用了这个方案的URL。</p>

<p><code>Note:Apple提供内建支持http,mailto.tel和sms URL方案等等。它同样支持基于http URLs针对Maps,YouTube,和iPod APP.对于这些方案的处理是固定的不能被改变的。如果你的URL类型包含一个和Apple定义的方案相同，那么会启动Apple提供的APP而不是你的APP。关于更多信息方案支持看Apple URL Scheme Reference.</code></p>

<h3>发送URL到另外一个APP</h3>

<p>当你想去发送数据到一个实现了自定义<code>URL</code>方案的APP时，创建一个适当的<code>URL</code>格式然后调用APP对象的<code>openURL:</code>方法。<code>openURL:</code>用注册方案启动APP和传递你的<code>URL</code>给它。在这个点上，控制权会传递到新的APP上。</p>

<p>以下的代码片段演示一个APP如何请求另外一个APP的服务(<code>todolist</code>在这个例子里假设是通过APP注册的一个自定义方案)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="bp">NSURL</span> <span class="o">*</span><span class="n">myURL</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;todolist://www.acme.com?Quarterly%20Report#200806231300&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="bp">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">openURL</span><span class="p">:</span><span class="n">myURL</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果APP定义一个自定义的<code>URL</code>方案，他应该为该方案实现一个处理程序。关于系统支持的<code>URL</code>方案和怎么样去格式化<code>URLs</code>看文档<code>Apple URL Scheme Reference</code>.</p>

<h3>实现自定义的URL方案(Implementing Custom URL Schemes)</h3>

<p>如果你的APP能接收指定格式化的<code>URLs</code>,你应该用系统注册相应的<code>URL</code>方案。APP通常使用自定义的<code>URL</code>方案去暴露服务给另外的APP。例如，<code>Maps APP</code>支持显示指定<code>map</code>位置的<code>URLs</code>.</p>

<h4>注册自定义URL方案(Registering Custom URL Schemes)</h4>

<p>去注册你的<code>APP URL</code>类型，包含<code>CFBundleURLTypes</code>键到你的<code>Info.plist</code>文件。<code>CFBundleURLTypes</code>键包含一个字典数组，这个字典数据的每一项(每一项都是一个字典，里面可以包含如下的一个<code>CFBundleURLName</code>键，这个键的值就是定义一个反转<code>DNS</code>样式的方案摘要名，然后还有一个<code>CFBundleURLSchemes</code>键，这个键是一个字符串数组，可以包含多个方案名，比如可以支持<code>http，tel,sms</code>等等你想去支持的方案名)可以定义一个你的APP支持的<code>URL</code>方案。</p>

<p>如下是每一个字典包含的键值对描述:
Key | Value
&mdash; | &mdash;
CFBundleURLName | 一个字符从包含URL方案的摘要名(abstract name).保证这个是唯一的，推荐你
指定一个标识符使用反转DNS样式，例如，com.acme.myscheme.
CFBundleURLSchemes | 一个字符串数组，用于包含URL方案名，例如，http，mailto，tel,和sms.</p>

<p><code>Note:如果有超过一个第三方APP注册去处理这个相同的方案，目前还没有方法去决定把这个方案给那个APP处理.</code></p>

<h4>处理URL请求(Handling URL Requests)</h4>

<p>一个有自定义<code>URL</code>方案的APP必须有能力去处理传递给它的<code>URL</code>。在APP启动时间或者在你的APP运行或者在后台期间，所有的<code>URLs</code>是传递到你的APP的代理。去处理到达的<code>URLs</code>，你的代理应该实现以下的方法：</p>

<ul>
<li>使用<code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法去找寻关于URL的信息和决定你是否想去打开它。如果两个方法中有一个放回<code>NO</code>，你的APP URL处理代码是不会被调用的。</li>
<li>使用<code>application:openURL:sourceApplication:annotation:</code>去打开这个文件。</li>
</ul>


<p>当一个URL请求到达时你的APP没有运行，APP会启动和移动到前台，这样它能够打开这个URL。你的<code>application:willFinishLaunchingWithOptions:</code>或者<code>application:didFinishLaunchingWithOptions:</code>的实现应该从他的<code>options</code>字典寻找URL和确定是否APP能够打开它。如果它能，返回<code>YES</code>和让你的<code>application:openURL:sourceApplication:annotation:</code>(或者<code>application:handleOpenURL:</code>)方法操作这个实际的URL打开。(如果你实现了这两个方法，这两个方法必须都返回<code>YES</code>之前的网址才能打开.)</p>

<p>图6-1 一个APP被请求去打开一个URL的启动顺序。
<img src="http://liuhaoxiu.github.io/images/app_open_url_2x.png" width="612" height="807"></p>

<p>当一个URL请求到达时，如果你的APP是运行在后台或者是暂停(挂起)的，它将迁移回前台去打开这个URL。在这之后不久，系统调用代理<code>application:openURL:sourceApplication:annotation:</code>方法去检查URL和打开它。</p>

<p>图6-2 移动APP到到前台去打开一个URL的过程
<img src="http://liuhaoxiu.github.io/images/app_bg_open_url_2x.png" width="612" height="807"></p>

<p><code>Note:支持自定义URL方案的APP当启动这个APP去处理一个不同方案的URL时能够指定不同的启动图片去显示</code>
所有的URLs都通过一个<code>NSURL</code>对象传递到你的APP。它是由你去定义的URL格式，但是<code>NSURL</code>类遵循<code>RFC 1808</code>规范因此支持大部分的URL格式协议。这个类包含的方法返回有<code>RFC 1808</code>定义的URL的不同部分，包括用户，密码，查询，片段，和参数字符串。你的自定义方案的协议(<code>protocol</code>)能使用这些URL部分传送不同种类的信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">openURL:</span><span class="p">(</span><span class="bp">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span>
</span><span class='line'>        <span class="nf">sourceApplication:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">sourceApplication</span> <span class="nf">annotation:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">annotation</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([[</span><span class="n">url</span> <span class="n">scheme</span><span class="p">]</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;todolist&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ToDoItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ToDoItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">taskName</span> <span class="o">=</span> <span class="p">[</span><span class="n">url</span> <span class="n">query</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">taskName</span> <span class="o">||</span> <span class="o">!</span><span class="p">[</span><span class="nb">self</span> <span class="nl">isValidTaskString</span><span class="p">:</span><span class="n">taskName</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// must have a task name</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">taskName</span> <span class="o">=</span> <span class="p">[</span><span class="n">taskName</span> <span class="nl">stringByReplacingPercentEscapesUsingEncoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">item</span><span class="p">.</span><span class="n">toDoTask</span> <span class="o">=</span> <span class="n">taskName</span><span class="p">;</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">dateString</span> <span class="o">=</span> <span class="p">[</span><span class="n">url</span> <span class="n">fragment</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dateString</span> <span class="o">||</span> <span class="p">[</span><span class="n">dateString</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;today&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">item</span><span class="p">.</span><span class="n">dateDue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="nb">self</span> <span class="nl">isValidDateString</span><span class="p">:</span><span class="n">dateString</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="c1">// format: yyyymmddhhmm (24-hour clock)</span>
</span><span class='line'>            <span class="bp">NSString</span> <span class="o">*</span><span class="n">curStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateString</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span><span class='line'>            <span class="bp">NSInteger</span> <span class="n">yeardigit</span> <span class="o">=</span> <span class="p">[</span><span class="n">curStr</span> <span class="n">integerValue</span><span class="p">];</span>
</span><span class='line'>            <span class="n">curStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateString</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)];</span>
</span><span class='line'>            <span class="bp">NSInteger</span> <span class="n">monthdigit</span> <span class="o">=</span> <span class="p">[</span><span class="n">curStr</span> <span class="n">integerValue</span><span class="p">];</span>
</span><span class='line'>            <span class="n">curStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateString</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)];</span>
</span><span class='line'>            <span class="bp">NSInteger</span> <span class="n">daydigit</span> <span class="o">=</span> <span class="p">[</span><span class="n">curStr</span> <span class="n">integerValue</span><span class="p">];</span>
</span><span class='line'>            <span class="n">curStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateString</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">)];</span>
</span><span class='line'>            <span class="bp">NSInteger</span> <span class="n">hourdigit</span> <span class="o">=</span> <span class="p">[</span><span class="n">curStr</span> <span class="n">integerValue</span><span class="p">];</span>
</span><span class='line'>            <span class="n">curStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateString</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)];</span>
</span><span class='line'>            <span class="bp">NSInteger</span> <span class="n">minutedigit</span> <span class="o">=</span> <span class="p">[</span><span class="n">curStr</span> <span class="n">integerValue</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">NSDateComponents</span> <span class="o">*</span><span class="n">dateComps</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateComponents</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">dateComps</span> <span class="nl">setYear</span><span class="p">:</span><span class="n">yeardigit</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">dateComps</span> <span class="nl">setMonth</span><span class="p">:</span><span class="n">monthdigit</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">dateComps</span> <span class="nl">setDay</span><span class="p">:</span><span class="n">daydigit</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">dateComps</span> <span class="nl">setHour</span><span class="p">:</span><span class="n">hourdigit</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">dateComps</span> <span class="nl">setMinute</span><span class="p">:</span><span class="n">minutedigit</span><span class="p">];</span>
</span><span class='line'>            <span class="bp">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="bp">NSCalendar</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCalendarIdentifier</span><span class="p">:</span><span class="n">NSGregorianCalendar</span><span class="p">];</span>
</span><span class='line'>            <span class="bp">NSDate</span> <span class="o">*</span><span class="n">itemDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">dateFromComponents</span><span class="p">:</span><span class="n">dateComps</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">itemDate</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">item</span><span class="p">.</span><span class="n">dateDue</span> <span class="o">=</span> <span class="n">itemDate</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[(</span><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">list</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">item</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>打开一个URL时显示一个自定义的启动图片(Displaying a Custom Launch Image When a URL is Opened)</h3>

<p>支持自定义URL方案的APP能够为每一个支持的方案提供一个自定义的启动图片。当系统启动你的APP去处理一个URL时没有相关的快照可以用，它显示你指定的启动图片。去指定一个启动图片，提供一个PNG图片，名字使用以下的命名约定：
<code>&lt;basename&gt;-&lt;url_scheme&gt;&lt;other_modifiers&gt;.png</code>
在命名约定中，<code>basename</code>表示通过在你的<code>Info.plist</code>文件里的<code>UILaunchImageFile</code>键指定的基础图片名。如果你没有指定一个自定义的基础名，使用<code>Default</code>字符串。这个名字的<code>&lt;url_scheme&gt;</code>部分是你的URL方案名。为<code>myapp</code>URL方案指定一个通用的启动图片，你将在你的APP的<code>bundle</code>里包含一个名字为<code>Default-myapp@2x.png</code>的图片文件。(@2x修饰的意思是这个图片打算视网膜显示，如果你的APP同样支持分辨率显示，你将同样提供一个<code>Default-myapp.png</code>图片。)</p>

<h1>性能技巧(Performance Tips)</h1>

<p>在你APP开发的每一个步骤，考虑你的设计的选择对你的APP整体性能的影响。电源使用和内存消耗对于iOS APP是极其重大考虑，也还有其他许多另外的考虑。以下的部分描述了在你的开发过程中你应该考虑的方方面面的因素。</p>

<h2>减少你APP的电池消耗(Reduce Your App’s Power Consumption)</h2>

<p>耗电量在移动设备是一个一直存在的问题。电池管理系统通过关闭任何现在没在使用的硬件特性去保存电量。你能够通过优化使用以下的特性去帮助改善电池寿命:</p>

<ul>
<li>The CPU</li>
<li>Wi-Fi, Bluetooth, and baseband (EDGE, 3G) radios</li>
<li>The Core Location framework</li>
<li>The accelerometers</li>
<li>The disk</li>
</ul>


<p>你的优化的目标应该是以最有效的方式去做大部分的工作。你应该总是使用工具(<code>Instruments</code>)优化你的运算法则。但是即使是最优的运算法则可能仍然对设备上的电池寿命有一个负面影响。因此在你写你的代码的时候你应该考虑以下的指导：</p>

<ul>
<li>避免做需要轮询的工作。轮询会阻止CPU去休眠。不用轮询可以使用<code>NSRunLoop</code>或者<code>NSTimer</code>去做你需要定期的工作。</li>
<li>在任何可能的时候保持<code>UIApplication</code>对象的<code>idleTimerDisabled</code>属性值为<code>NO</code>。在一个指定的不活动时间后这个空闲定时关闭设备屏幕。如果你不需要屏幕常亮，让系统关闭它。如果关闭屏幕对你的APP体验有影响，你应该修改你的代码去消除这个负面影响而不是禁用这个空闲定时时间。</li>
<li>尽可能合并工作去最大化提高空闲时间。它通常去同时执行一套计算比它在一个较长的时间去一小块一小块的执行会使用更少的电量。定期做小块的工作需要更经常的唤醒CPU使之在一个能够执行你任务的状态。</li>
<li>避免太频繁地访问磁盘。例如，如果你的APP保存状态信息到磁盘，只有当状态信息改变时才去访问磁盘，并尽可能合并改变避免频繁的去写小的改变。</li>
<li>不要在屏幕上画的比需要的速度快。画(<code>Drawing</code>)是一个昂贵的操作。不要依靠硬件来调节你的帧数率。只画你的APP实际需要的帧数。</li>
<li>如果使用<code>UIAccelerometer</code>类去接收定期的加速计事件，当你不需要这些事件的时候禁用这些事件的交付。同样的，将事件交付的频率设置为你需要的适当的最小值。</li>
</ul>


<p>你传送到网络更多的数据，然而更多的电量必须用来运行电话。事实上，访问网络是你能执行的最耗电的操作。你能够使用以下的指导去最小化访问网络的时间:</p>

<ul>
<li>只有有需要时才连接外部的网络，不要去轮询这些服务。</li>
<li>当你必须连接到网络，传输你需要做这个工作的最小的数据块(不传输不必要的数据)。使用压缩数据格式，不要包含可以被忽略的额外的内容。</li>
<li>当使用<code>NSURLSession</code>类去排队多个上传或者下载任务时，同时排队这些项而不是等待一个结束再去开启下一个。当系统有最有效的方法做这个时系统自动管理队列执行任务。</li>
<li>尽可能使用Wi-Fi连接到网络.Wi-Fi使用比蜂窝无线电(<code>cellular radios</code>)更少的电量。</li>
<li>如果你使用<code>Core Location framework</code>去收集位置数据，一旦可能立马禁用位置更新，设置距离过滤和精确等级到恰当的值。<code>Core Location</code>使用可用的<code>GPS</code>，<code>cell</code>(蜂窝无线电)，和<code>Wi-Fi</code>网络去确定用户的位置。虽然<code>Core Location</code>工作很难减少这些无线电的使用，但是设置精确和过滤给<code>Core Location</code>的选项去完全关闭硬件，在这种情况下，它是不需要的。</li>
</ul>


<h2>有效使用内存(Use Memory Efficiently)</h2>

<p>鼓励APP使用尽可能少的内存，这样系统能够保持更多的APP在内存中或者奉献更多的内存给真正需要内存的前台APP。系统有多少可用的空闲内存和你的APP的相对性能是直接相关的。较少的空闲内存意味着系统更有可能不能满足将来的内存请求。</p>

<p>去确保总有足够的可能内存，你应该最小化你的APP的内存使用和当系统请求释放内存时灵敏的响应。</p>

<h3>观察低内存警告(Observe Low-Memory Warnings)</h3>

<p>当系统派遣一个低内存警告到你的APP时，马上响应。低内存警告是你去移除对你不需要的对象的引用的时机。响应这些警告是重要的，因为APP不去做这个的话你的APP更有可能被系统终止。系统交付内存警告给你的APP使用以下的APIs:</p>

<ul>
<li>APP代理的<code>applicationDidReceiveMemoryWarning:</code>方法.</li>
<li>你的<code>UIViewController</code>类的<code>didReceiveMemoryWarning</code>方法.</li>
<li><code>UIApplicationDidReceiveMemoryWarningNotificationnotification</code>.</li>
<li>调度源类型<code>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</code>.这个方式只能用来区分系统内存压力的严重程度.</li>
</ul>


<p>根据接收的任何这些警告，你的处理方法应该直接释放任何不需要的内存作为响应。使用警告去清理缓存和释放图片。如果你有一个大的数据结构没有被使用，写这些结构到磁盘然后释放掉在内存中已被写入磁盘的数据。</p>

<p>如果你的数据模型包含了已知的可清除的资源，你可以有一个相应的管理对象注册关于<code>UIApplicationDidReceiveMemoryWarningNotification</code>的通知然后直接移除对它的可清理资源的强引用。处理这个通知直接避免需要去通过APP代理路由的所有的内存警告调用。</p>

<p><code>Note:你可以测试你的APP的行为在低内存条件下，你可以在iOS模拟器里使用模拟内存警告命令.</code></p>

<h3>减少你的APP内存占用(Reduce Your App’s Memory Footprint)</h3>

<p>APP开始时占用低的内存便于有更多空间在之后展开你的APP。以下有一些关于如何整体减少你的APP内存占用的技巧.</p>

<table>
<thead>
<tr>
<th>Tip                       </th>
<th>     Actions to take</th>
</tr>
</thead>
<tbody>
<tr>
<td>消除内存泄漏                </td>
<td> 因为在iOS中内存是关键的资源,APP绝没有内存溢出.</td>
</tr>
<tr>
<td>制做尽可能小的资源文件        </td>
<td> 文件在磁盘上只有加载进入内存它们才能被使用.压缩所有的图片文件去使它们尽可能的小.(去压缩PNG图片-这个是iOSAPP首选的压缩格式-使用<code>pngcrush</code>工具.)你可以制作一个较小的<code>property list</code>文件(其实就是写一个对象到内存,这个对象的属性列表必须是框架支持的某些原生的数据类型，比如array，dictionary等等类型)通过使用<code>NSPropertyListSerialization</code>类写它们到一个二进制的格式.</td>
</tr>
<tr>
<td>使用<code>Core Data</code>或者<code>SQLite</code>存储大块数据 </td>
<td> 如果你的APP操作大块的结构数据，存储它到一个<code>Core Data</code>持久存储或者一个<code>SQLite</code>数据库而不是在一个平面的文件.<code>Core Data</code>和<code>SQLite</code>都提供了高效的方法去管理大数据集，它们不需要全部的数据集一次都加载入内存里去操作。</td>
</tr>
<tr>
<td>延迟加载资源                 </td>
<td> 你加载资源文件应该直到它实际需要时才加载。预加载资源可能看上去像很节省时间的方法，但是这种做法实际上是你的APP马上慢了下来。另外，如果最后都没有使用这些资源，加载它浪费内存不是一个好的意图。</td>
</tr>
</tbody>
</table>


<h3>明智的分配内存(Allocate Memory Wisely)</h3>

<p>以下列出了在你的APP里改善内存使用的技巧.</p>

<table>
<thead>
<tr>
<th>Tip                       </th>
<th>     Actions to take</th>
</tr>
</thead>
<tbody>
<tr>
<td>在资源文件上施加大小限制      </td>
<td> 当有一个较小的资源文件行得通时避免加载一个大的资源文件。不去使用高分辨率的图片，对于基于iOS的设备使用合适的大小。如果你必须使用一个大的资源文件，查找在任何给定时间内只加载您需要的文件的部分的方法。例如，不加载全部的文件进入内存，使用<code>mmap</code>和<code>munmap</code>功能去映射文件的一部分进入和离开内存。关于更多的映射文件进入内存，看<code>File-System Performance Guidelines</code>.</td>
</tr>
<tr>
<td>避免无界限问题集合            </td>
<td> 无界限的问题集合可能必须有一个任意大的数据量的计算。如果集合必须的内存比它能使用的更多，你的APP可能不能去完成计算。你的APP应该尽可能避免如此集合和运行在已知的内存限制问题上(work on problems with known memory limits)。</td>
</tr>
</tbody>
</table>


<h2>调整你的网络代码(Tune Your Networking Code)</h2>

<p>在iOS的网络栈里包含了几个在iOS设备的无线电硬件上通信的接口.这个主要的设计接口是CFNetwork框架，它建立在<code>BSD sockets</code>上面和在<code>Core Foundation</code>框架里去和实体网络通信的不透明类型。你同样能使用在<code>Foundation</code>框架中<code>NSStream</code>类和在系统<code>Core OS</code>层里找到低层级的<code>BSD sockets</code>.</p>

<h3>高效网络技巧(Tips for Efficient Networking)</h3>

<p>实现代码通过网络去接收或者传输数据在一个设备上是一个最耗电的操作。最小化传输或者接收数据花费的时间有助于改善电池寿命.因此，当写你的网络相关的代码时你应该考虑以下的技巧:</p>

<ul>
<li>关于你控制的协议，定义你的数据格式尽可能被紧凑.</li>
<li>避免使用非正式(<code>chatty</code>)协议.</li>
<li>传输数据包在有可能时使用突发网络(<code>bursts</code>(意义是为了博取用户体验，上传下载时突发流量，用所能得到的最大带宽去做传输数据的事)).</li>
</ul>


<h3>使用Wi-Fi(Using Wi-Fi)</h3>

<p>如果你的APP使用Wi-Fi请求网络，你必须通过包含<code>UIRequiresPersistentWiFi</code>键在你的APP的<code>Info.plist</code>文件去通知系统这个事实。包含这个键让系统知道如果它发现有活动的Wi-Fi热点可用它应该显示网络对话框块.它同样让系统知道在你的APP运行期间它不应该试图去关闭Wi-Fi硬件.</p>

<p>防止Wi-Fi硬件使用太多电量，iOS有一个内建的计时计，如果运行的APP没有使用<code>UIRequiresPersistentWiFi</code>键那么30分钟后会完全关闭Wi-Fi硬件.如果用户启动一个APP包含了这个键，iOS有效的禁用这个计时计在这个APP的生命运行周期期间。一旦APP退出或者被挂起，系统重新启用这个计时计。</p>

<p><code>Note:注意，当设备空闲时(也就是说，屏幕锁定)即使UIRequiresPersistentWiFi的值是true，它也不会生效。这个APP被认为是不活动的，尽管可能它在某些层面上发挥作用，但是它是没有Wi-Fi连接的.</code></p>

<h3>飞行模式警告(The Airplane Mode Alert)</h3>

<p>设备在飞行模式期间如果你的APP启动，系统可能显示一个警告去通知用户一些实际情况。系统显示警告只有当以下所有条件满足时：</p>

<ul>
<li>你的APP<code>Info.plist</code>文件包含了<code>UIRequiresPersistentWiFi</code>键并且值是<code>true</code>.</li>
<li>设备在飞行模式期间你的APP启动.</li>
<li>切换到飞行模式后Wi-Fi在设备上没有重新手动启用.</li>
</ul>


<h2>使应用程序的备份更有效(Make App Backups More Efficient)</h2>

<p>无线备份发生通过iCound或者当用户设备与iTunes同步时。在备份期间，文件从设备传输到用户计算机或者iCloud账户。文件在你APP沙盒中的位置确定这是文件是否备份和恢复.如果你的APP创建许多经常改变的大文件并把它们放在一个备份的位置，备份结果可能很慢。作为你写你的文件管理代码，你需要去注意这个事.</p>

<h3>APP备份最佳实践(App Backup Best Practices)</h3>

<p>对于备份和恢复你不需要以任何方式去准备你的APP。设备与一个活动的iCloud账户在适当的时候备份它们的APP数据到iCloud.设备插入计算机，iTunes执行APP数据文件的增量备份。无论如何，iCloud和iTunes不备份以下目录的内容:</p>

<ul>
<li><code>&lt;Application_Home&gt;/AppName.app</code></li>
<li><code>&lt;Application_Data&gt;/Library/Caches</code></li>
<li><code>&lt;Application_Data&gt;/tmp</code></li>
</ul>


<p>为了防止同步处理消耗太长时间，去选择放置文件在你的APP的<code>home</code>目录的位置。APP存储大文件到iTunes或者iCloud这个过程可能很慢.这些APP同样可能消耗了一大块用户可用的存储空间，这个可能促使用户去删除这个APP或者禁用这个APP到iCloud的数据备份.因此，你应该根据以下相应的指导存储数据：</p>

<ul>
<li>关键数据应该存储在<code>&lt;Application_Data&gt;/Documents</code>目录。关键数据是任何不能够被你的APP重建的数据，例如用户文档和另外用户生成的类容。</li>
<li>支持文件(Support files)包含你的APP下载或者生成和你的APP能够根据需要重建的文件。存储你APP支持文件的位置依赖于iOS的当前版本.

<ol>
<li>在iOS 5.1或之后版本，存储支持文件在<code>&lt;Application_Data&gt;/Library/Application</code>的<code>Support</code>目录里和使用<code>setResourceValue:forKey:error:</code>方法添加<code>NSURLIsExcludedFromBackupKey</code>属性到相应的<code>NSURL</code>对象。(如果你是使用Core Foundation，使用<code>CFURLSetResourcePropertyForKey</code>函数添加<code>kCFURLIsExcludedFromBackupKey</code>键到你的<code>CFURLRef</code>对象)应用这个属性阻止文件被备份到iTunes或者iCloud。如果你有大量的支持文件，你可能存储它们在一个自定义的子目录和应用这个扩展属性到这个恰当的目录。</li>
<li>在iOS 5.0或之前，存储支持文件在<code>&lt;Application_Data&gt;/Library/Caches</code>目录里去阻止它们备份。</li>
</ol>
</li>
<li>缓存数据应该存储在<code>&lt;Application_Data&gt;/Library/Caches</code>目录里。示例文件你应该放在<code>Caches</code>目录包括(但不限于)数据库缓存文件和可下载的内容，例如由杂志，报纸，和地图这些APP使用的文件。你APP应该能够优雅的处理通过系统删除缓存数据去释放磁盘空间这种情况.</li>
<li>临时数据应该被存储在<code>&lt;Application_Data&gt;/tmp</code>目录里。临时数据由任何你不需要在以后用到的数据组成。当你使用完它们时推荐删除这些文件，如此它们不需要继续占用用户设备的空间。</li>
</ul>


<p>尽管iTunes备份APP <code>bundle</code>本身，但在每一个同步操作期间它不这样做。当下一个设备与iTunes同步时已购的APP直接来自一个已备份的设备(你的手机第一个插入电脑与iTunes连接时会备份你设备上的已购项目和及其需要备份的数据)。在之后的同步操作期间APP是不备份的，除非APP <code>bundle</code>本身已被改变(例如，因为APP是已被更新)。</p>

<h3>在APP更新期间保存的文件(Files Saved During App Updates)</h3>

<p>当用户下载一个APP更新，iTunes安装这个更新在一个新的APP目录。在删除旧的安装之前它移动数据文件从旧的安装到新的APP目录。在更新过程期间文件在以下的目录是保证会被保留的：</p>

<ul>
<li><code>&lt;Application_Data&gt;/Documents</code></li>
<li><code>&lt;Application_Data&gt;/Library</code></li>
</ul>


<p>尽管文件在另外目录同样有可能被移动，不过更新之后你不应该依靠他们(就是不应该依赖这些或许会存在的文件)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIView动画块占用主线程不]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/08/10/uiviewdong-hua-kuai-zhan-yong-zhu-xian-cheng-bu/"/>
    <updated>2016-08-10T10:37:26+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/08/10/uiviewdong-hua-kuai-zhan-yong-zhu-xian-cheng-bu</id>
    <content type="html"><![CDATA[<h1>UIView动画块占用主线程吗</h1>

<p>一般人都会有一个这样的疑问，我动画UIView的属性的时候需要重启线程以便不占用主线程吗，比如我封装一个进度条的动画，是不是要考虑下主线程。那么UIView运行动画block时实际的运行状况是怎么样的，以下我来讲讲。</p>

<h2>对于block</h2>

<p>比如以下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[</span><span class="bp">UIView</span> <span class="nl">animateWithDuration</span><span class="p">:</span> <span class="n">some</span> <span class="n">duration</span>
</span><span class='line'>                     <span class="nl">animations</span><span class="p">:</span><span class="o">^</span><span class="p">{</span> <span class="n">some</span> <span class="n">animation</span> <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上以上代码中block是在主线程(<code>main thread</code>)执行的，这一部分是会阻塞主线程的。</p>

<h2>对于block中属性的动画</h2>

<p>对于动画部分，系统是会启动一个动画线程，这个线程不阻塞你的主线程。系统使用动画线程作为一个帧定时器，每到一个触发时间这个线程发送一个更新到你的主线程其中携带了你的可动画属性的进度值，你可以在你的表示层检查这些值得当前状态。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现独特APP特性的策略]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/08/03/shi-xian-du-te-appte-xing-de-ce-lue/"/>
    <updated>2016-08-03T16:44:37+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/08/03/shi-xian-du-te-appte-xing-de-ce-lue</id>
    <content type="html"><![CDATA[<h1>实现特定APP特性的策略(Strategies for Implementing Specific App Features)</h1>

<p>不同的APP有不同的需要，但是有一些行为对于许多的APP是共同的。接下来的块提供了指导关于在你的APP中实现特定的特性。</p>

<h2>隐私策略(Privacy Strategies)</h2>

<p>在设计一个APP的时候保护用户的隐私是一个重大的考虑。隐私保护包含了保护用户数据，用户身份和个人信息。系统框架已经提供了关于管理数据的隐私框架，例如联系人，但是你的APP应该采取措施去保护你的本地使用的数据。</p>

<h3>保护数据使用在磁盘加密(Protecting Data Using On-Disk Encryption)</h3>

<p>数据保护使用内置硬件使用一个加密的格式去存储文件到磁盘，需要它们的时候再解密。在用户锁定屏幕期间，保护文件是访问不到的，即使是创建它们的APP也不行。你个APP能够访问一个它保护的文件必须是这个设备不是屏幕锁定的(通过键入适当的密码解锁)。</p>

<p>数据保护在大部分iOS设备是可用的，但需要服从以下的要求：</p>

<ul>
<li>在用户设备上的文件系统必须支持数据保护.大部分设备支持这个行为.</li>
<li>这个用户必须有有效的密码用于锁定这个设备.</li>
</ul>


<p>去保护一个文件，你添加一个特性到这个文件只是所需要的保护等级。添加这个特性使用<code>NSData</code>类或者<code>NSFileManager</code>其中的一个。当写一个新文件，你能使用<code>NSData</code>的<code>writeToFile:options:error:</code>方法并用一个合适的值作为写选项参数。关于现存的文件，你能使用<code>NSFileManager</code>的<code>setAttributes:ofItemAtPath:error:</code>方法去设置或者改变 <code>NSFileProtectionKey</code>的值。当使用这些方法，给你文件指定一个以下的保护等级。</p>

<ul>
<li>没有保护——这个文件是加密的但是没有通过密码保护，在这个设备锁定期间是可用的。指定<code>NSDataWritingFileProtectionNone</code>选项(<code>NSData</code>)或者<code>NSFileProtectionNone</code>属性(<code>NSFileManager</code>).</li>
<li>完全的保护——这个文件是加密的，在设备锁定期间是不可访问的。指定 <code>NSDataWritingFileProtectionNone</code>选项(<code>NSData</code>)或者<code>NSFileProtectionNone</code>属性(<code>NSFileManager</code>).</li>
<li>完全保护但是除了已经打开的文件——这个文件是加密的。在设备锁定期间一个关闭的文件是不可访问的。用户解锁这个设备之后，你的APP能够打开这个文件并使用它。在文件打开期间用户锁定了设备你的APP能继续去访问它。指定<code>NSDataWritingFileProtectionCompleteUnlessOpen</code>选项(<code>NSData</code>)或者<code>NSFileProtectionCompleteUnlessOpen</code>属性(<code>NSFileManager</code>).</li>
<li>完全保护直到第一次登录——这个文件是加密的，这个设备启动后文件是不可访问的，用户一旦解锁这个设备文件就可以访问了。指定 <code>NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication</code>选项(<code>NSData</code>)或者<code>NSFileProtectionCompleteUntilFirstUserAuthentication</code>属性(<code>NSFileManager</code>).</li>
</ul>


<p>如果你保护一个文件，你的APP必须准备去失去对这个文件的访问。当完全的文件保护启用时，当用户锁定屏幕你的APP失去了读写这个文件内容的能力。你能使用接下来的技术跟踪保护文件状态的改变。</p>

<ul>
<li>实现APP代理的<code>applicationProtectedDataWillBecomeUnavailable:</code>和 <code>applicationProtectedDataDidBecomeAvailable:</code>方法。</li>
<li>任何对象能够注册<code>UIApplicationProtectedDataWillBecomeUnavailable</code>和 <code>UIApplicationProtectedDataDidBecomeAvailable</code>通知。</li>
<li>任何对象能够验证<code>UIApplication</code>共享对象的<code>protectedDataAvailable</code>属性值去确定当前文件是否是可访问的。</li>
</ul>


<p>关于新文件，在写任何数据到这个文件之前你去启用数据保护是被推荐的。如果你使用<code>writeToFile:options:error:</code>方法去写一个<code>NSData</code>对象内容到磁盘，这个是保护自动发生的。关于现存的文件，用一个新的数据版本添加数据保护去替换一个未保护的文件。</p>

<h3>识别你的APP的独特用户(Identifying Unique Users of Your App)</h3>

<p>仅仅在你去识别你的APP的一个用户能够提供一个明显的好处给你的用户的时候你才应该去做这个。你如果仅仅需要去区分你的APP的一个用户是不是来自另外一个，iOS提供了标识符能够帮助你去做这个。无论如何，如果你需要一个高的安全级别，你可能需要自己做更多的工作。</p>

<p><code>Important：当识别一个用户时，总是明确的关于你想要用你获得的信息做什么。识别用户是不可接受的，这样你能秘密的跟踪它们.</code></p>

<p>这里是一些你需要去识别用户的常用的场景，以下是一些关于如何实现它们和一些解决方案.</p>

<ul>
<li>你想去链接一个用户到一个特定的账户。包含一个登录屏幕需要用户去键入它们的安全账户信息。总是保护你收集来自用户的账户信息通过加密的形式去存储。</li>
<li>你想去区分你的APP实例运行去不同的设备上。使用<code>UIDevice</code>类的<code>identifierForVendor</code>属性去获取一个<code>ID</code>，这个用于区别在不同设备的的同一个用户。这个技术现在允许你去识别特定的用户。当个用户可能有多个设备，在每个设备上有不同的<code>ID</code>值。</li>
<li>你想去识别关于广告目的的用户。使用<code>ASIdentifierManager</code>类的<code>advertisingIdentifier</code>属性去获取关于这个用户的<code>ID</code>。</li>
</ul>


<p>因为用户是允许去运行APP到他们所有的iOS设备上的，Apple不提供一个方法去识别同样的用户在多个设备上，如果你需要去识别一个特定的用户，你必须提供你自己的解决方案使用通用的唯一<code>IDs</code>(<code>UUIDS</code>),一个登录账户，或者一些另外的身份识别类型系统。</p>

<h2>关于限制(Respecting Restrictions)</h2>

<p>用户能够设置限制，指定想去在你的APP中使用的媒体的等级。如果你的APP播放媒体或者修改基于限制的行为，你需要去确定当前的设置和去响应设置的改变。(访问限制就是用户可以在通用里面设置不同国家和地区的对你的APP所包含内容的访问限制，你可以选择那些内容是可以看到，那些APP是可以运行的，这个是分级制度保护不同阶段的人看到不同的内容，比如儿童可以设置一下限制级的内容限制访问)。</p>

<p>去获得当前的设置，获得共享对象<code>standardUserDefaults</code>和使用它的<code>objectForKey:</code>方法去查看以下键的值：</p>

<ul>
<li><code>com.apple.content-rating.ExplicitBooksAllowed</code> <code>Boolean</code>。如果这个键的值是NO，明确书是不允许的。</li>
<li><code>com.apple.content-rating.ExplicitMusicPodcastsAllowed</code> <code>Boolean</code>。如果这个键的值是NO，明确音乐内容，电影，和播客是不允许的。</li>
<li><code>com.apple.content-rating.AppRating</code> <code>NSNumber</code>。这个键的值在0到1000的范围内。一个APP的等级比这个当前的键值高是不被允许的。</li>
<li><code>com.apple.content-rating.MovieRating</code> <code>NSNumber</code>。这个键的值在0到1000的范围内。一个电影的等级比这个当前的键值高是不被允许的。</li>
<li><code>com.apple.content-rating.TVShowRating</code> <code>NSNumber</code>。这个键的值在0到1000的范围内。一个电视节目的等级比这个当前的键值高是不被允许的。</li>
</ul>


<p><code>Note:关于一个指定的键如果objectForKey:返回nil，它意味着关于这个特定限制的信息是无法拿到的。在这种情况下，你的APP能够使用它自己的策略去确定适当的分级。</code></p>

<p>去发现用户对限制的改变，注册<code>NSUserDefaultsDidChangeNotification</code>通知。当发现一个持久域中本地偏好设置改变这个共享对象<code>standardUserDefaults</code>发送这个通知到你的APP。</p>

<h2>支持多个iOS版本(Supporting Multiple Versions of iOS)</h2>

<p>一个APP支持最新的iOS版本加一个或者多个以前的版本必须使用运行时检查去阻止在旧的iOS版本上使用新的APIs.当你的APP尝试使用一个在当前操作系统上不能获得的特性时运行时检查防止你的APP崩溃。</p>

<p>这些是几种你能做的检查类型：</p>

<ul>
<li>去确定是否一个类存在，看是否<code>Class</code>对象返回<code>nil</code>。链接器对于所有未知的类对象都返回<code>nil</code>,使用一个条件检查就像以下这样：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="bp">UIPrintInteractionController</span> <span class="k">class</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Create an instance of the class and use it.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// The print interaction controller is not available so use an     alternative technique.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>去确定一个方法在一个现有的类是否可以获取，使用<code>instancesRespondToSelector:</code>类方法或者<code>respondsToSelector:</code>实例方法。</li>
<li>去确定一个基于C的函数是否可以使用，执行这个函数去和<code>NULL</code>比较返回一个布尔值。如果不为<code>NULL</code>，你能调用这个函数。如下：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">UIGraphicsBeginPDFPage</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">UIGraphicsBeginPDFPage</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>保存你的APP的视觉外观(Preserving Your App’s Visual Appearance Across Launches)</h2>

<p>即使你的APP支持后台执行，它也不可能永远运行。在一些点，系统可能需要终结你的APP释放内存给当前的前台APP使用。无论如何，用户应该绝不关心一个APP已经运行还是已经终结。从用户的角度看，退出一个APP应该恰恰看起来像是一个临时中断。当用户返回到一个APP时，APP应该总是返回到用户使用这个APP的最后位置，如此用户能继续运行中的任何任务。这个行为提供了一个好体验给用户，状态恢复支持内建到UIKit里面这个获得是相对容易的。
状态保存系统在UIKit里面提供一个简单但是灵活的结构用于保存和恢复你的APP的视图控制器和视图状态。这个结构的工作是在适当的时间去驱动保存和恢复处理。做这个，UIKit需要你的APP的帮助。只有你了解你的APP的内容，如此只有你能写去保存和恢复这个内容的代码。当你更新你的APP用户界面时，只有你知道如何在你的界面去映射旧的保存内容到一个新的对象。</p>

<p>这里是三个地方，在这里你去考虑状态保存在你的APP里。</p>

<ul>
<li>你的APP代理对象，管理APP的最高级别的状态</li>
<li>你的APP视图控制器对象，管理你APP全部的用户界面状态。</li>
<li>你的APP的自定义视图，可能有一些你需要保存的自定义数据。</li>
</ul>


<p>UIKit允许你去选择你想保存的用户界面部分。如果你已经有自定义的代码关于操作状态保存，你能继续使用这个代码和作为需要你能迁移部分代码到UIKit保存系统。</p>

<h3>在你的APP中启用状态保存和恢复（Enabling State Preservation and Restoration in Your App）</h3>

<p>状态保存和恢复不是一个自动特性，APP必须选择去使用它。APP表明自己支持这个特性通过在它们的APP代理中实现以下的几个方法：</p>

<ol>
<li><code>application:shouldSaveApplicationState:</code></li>
<li><code>application:shouldRestoreApplicationState:</code></li>
</ol>


<p>通常的，你实现这些方法只有返回<code>YES</code>才能表明状态保存和恢复能够发生。当然也能返回<code>NO</code>，不过状态保存和恢复不会发生。例如你的APP无法有效的去恢复状态来自一个以前的版本你就可以在<code>application:shouldRestoreApplicationState:</code>方法里返回<code>NO</code>。</p>

<h3>保存和恢复过程(The Preservation and Restoration Process)</h3>

<p>状态保存和恢复是一个可选的特性，工作需要你的APP的帮助。你的APP标识应该保存的对象，UIKit在合适的时间去做保存和恢复这些对象的工作，因为UIKit处理这么多的过程，它帮你你去明白他在幕后做了什么，如此你知道如何实现你的自定义代码去契合这个总体的方案。</p>

<p>当思考关于状态保存和恢复时，它首先帮助你去分离这两个过程。UIkit在适当的时间保存你的APP状态，例如当你APP从前台移动到后台的时候。当UIkit确定新的状态信息是必要的时候，它审视你的APP视图和视图控制去看哪一个应该被保存。关于这些对象的每一个，UIkit写保存相关的数据到一个磁盘上的加密文件。在下次你的APP重新开始启动，UIkit找到这个文件，如果它是存在的，使用它去尝试恢复你的APP状态。因为这个文件是加密的，只有在这个设备解锁的状态下状态保存和恢复才会发生。</p>

<p>在恢复过程期间，UIkit使用保存数据去重新构造你的界面但是实际对象的创造是通过你的代码操作的。因为你的APP可能自动加载一个对象来自<code>storyboard</code>文件，只有你的代码知道哪一个对象需要去创建和哪一个可能已经存在能够简单的返回。创建每一个对象之后，UIkit用保存的状态信息初始化它们。</p>

<p>在保存和恢复处理期间，你的APP有少数的责任。</p>

<ul>
<li><p>在保存期间，你的APP的职责：</p>

<ol>
<li>告诉UIkit它支持状态保存。</li>
<li>告诉UIkit那个视图控制和视图应该保存。</li>
<li>为任何保存的对象编码相关的数据。</li>
</ol>
</li>
<li><p>在恢复处理期间，你的APP的职责：</p>

<ol>
<li>告诉UIkit它支持状态恢复。</li>
<li>提供(或创建)UIkit要求的对象。</li>
<li>解码你保存的对象状态和使用它去返回这个对象到它以前的状态。</li>
</ol>
</li>
</ul>


<p>你的APP的责任，最重要的是告诉UIkit那些对象要保存和之后的启动提供这些对象。这两个行为是在你设计你的APP的保存和恢复代码的时候应该花费你最多时间的地方。他们同样是你在这个实际过程中有最多控制的地方。去明白为什么是这个样子的。
UIkit只保存已经分配了恢复标识的对象。一个恢复标识是一个字符串，这个标识视图或者视图控制器，这个字符串的值仅仅对于你的代码有意义，但是这个字符串的存在告诉UIkit它需要去保存这个标记的对象。在保存处理期间，UIkit走你的APP视图控制器层级，保存所有的有恢复标识的对象。如果一个视图控制器没有一个恢复标识，这个视图控制器和所有它的视图和子视图控制器是不保存的。</p>

<p>根据你的APP，它可能有或者没有去保存每一个视图控制器的场景。如果一个视图控制器去呈现一个短暂的信息，你可能在恢复的时候不想返回到这个相同的点，而且选择返回到你的界面的一个稳定的点。</p>

<p>关于你选择去保存的每一个视图控制器，你同样需要去决定之后你想如何去恢复它。UIkit提供两个方法去重建对象。你能让你的APP代理重建它或者你能分配一个恢复类给这个视图控制器和让这个类重建它。一个恢复类(<code>restoration class</code>)实现<code>UIViewControllerRestoration</code>协议和它的职责是关于在恢复时间寻找或者创建一个指定的对象。这里有一些小技巧：</p>

<ul>
<li>如果视图控制器在启动时间总是从你的APP的主<code>storyboard</code>加载，不要分配一个恢复类。作为替代，让你的APP找到这个对象或者利用UIkit支持隐式查找恢复对象。</li>
<li>如果视图控制器在启动时间不从你的APP的主<code>storyboard</code>加载，分配一个恢复类。这个简单的选择是去为每一个视图控制器制作它自己的恢复类。</li>
</ul>


<p>在保存过程期间，UIkit标识这个对象去保存和写每一个受影响的对象状态到磁盘。每一个视图控制器对象给一个机会去写出任何他想要去保存的数据。</p>

<p>在下次APP启动后，UIkit照例加载APP的主<code>storyboard</code>或者<code>nib</code>文件，调用APP代理<code>application:willFinishLaunchingWithOptions:</code>方法，尝试去恢复APP以前的状态。这个第一件事是询问你的APP提供的视图控制器对象集合用于去匹配那个是保存了的。如果给的视图控制器有一个指定的恢复类，询问这个类去提供这个对象；否则，询问APP的代理提供这个对象。</p>

<h4>保存的处理流程(Flow of the Preservation Process)</h4>

<p>保存甚至发生之前，UIkit询问你的APP代理如果它应该发生就通过调用<code>application:shouldSaveApplicationState:</code>方法。如果这个方法返回值为<code>YES</code>，UIkit开始收集和编码你的APP视图和视图控制器。当这个过程结束，它写编码后的数据到磁盘。
在下次你的APP启动，系统自动找寻一个保存状态文件，如果存在，使用它去恢复你的界面。因为这个状态信息是只与你的APP在以前状态和当前启动周期相关的，这个文件在你的APP结束启动之后通常会被丢弃。这个文件同样在任何时间恢复你的APP有一个错误发生时被丢弃。例子，如果你的APP在恢复处理期间崩溃，系统自动扔掉这个状态信息避免在下一次启动周期再次发生崩溃。</p>

<h4>恢复的处理流程(Flow of the Restoration Process)</h4>

<p>在标准初始化和UI加载完成之后，UIkit询问你的APP代理，如果状态恢复应该发生通过调用<code>application:shouldRestoreApplicationState:</code>方法。这个是你的APP代理去检查保存数据和确定状态恢复是否可能的机会。如果它是，UIkit使用APP代理和恢复类去获取到你的APP视图控制器的引用。每一个对象去提供它需要的数据去恢复它自己到它以前的状态。
尽管UIkit帮助恢复单独的视图控制器，它不自动恢复这些视图控制器之间的联系。作为替代，每一个视图控制器有责任去编码足够多的状态信息用于返回它自己到以前的状态。例子，一个导航控制器编码信息关于在它的导航栈上视图控制器的顺序。它使用这个信息在之后去返回这些视图控制器到它们以前在导航栈的位置。其他的视图控制器有嵌入子视图控制器有同样的责任关于编码任何它们需要的信息用于之后去恢复它们的子类。</p>

<p><code>Note:不是所有的视图控制器需要去编码它们的子视图控制器，例如tab bar控制器就不.作为替代，它假设你的APP遵循通常的模式，在创建tab bar控制器之前创建恰当的子视图控制器.</code></p>

<p>因为你的的职责是关于重建你的APP视图控制器，在恢复处理期间你有一定的灵活性趣改变你的界面。例如，你能够重排序一个<code>tab bar</code>控制器中的<code>tab</code>和仍然使用保存数据去返回每一个<code>tab</code>到它以前的状态。当然，如果你对你的视图控制器层级做了巨大的更改，例如在一个应用程序更新期间，你可能不能使用保存数据。</p>

<h3>当你被逐出了视图控制器组时发生了什么(What Happens When You Exclude Groups of View Controllers?)</h3>

<p>当一个视图控制器的标识符为<code>nil</code>,这个视图控制器和它管理的任何子视图控制器是不自动保存的。</p>

<p>即使你决定不保存视图控制器,这么做不意味着这些所有的视图控制器完全从视图层级消失。在启动时间，你的APP可能仍然创建这个视图控制器作为默认设置的一部分。例如，如果任何视图控制器是自动加载来自于你的APP的<code>storyboard</code>文件，他们将仍然出现，虽然是在他们默认的配置(或者说状态).</p>

<p>有些事需要了解的是，即使一个视图控制器没有自动保存，你还可以编码对这个视图控制器的引用然后手动保存它。</p>

<h3>实现状态保存和恢复清单(Checklist for Implementing State Preservation and Restoration)</h3>

<p>支持状态保存和恢复需要修改你的APP的代理和视图控制器对象去编码和解码这个状态信息。如果你的APP有任何自定义的视图并且同样有可保存的状态信息，你也需要去修改这些对象。</p>

<p>当添加状态保存和恢复到你的代码的时，使用以下列表来提醒你需要些的代码.</p>

<ul>
<li>(必须)在你的APP代理实现<code>application:shouldSaveApplicationState:</code>和<code>application:shouldRestoreApplicationState:</code>方法.</li>
<li>(必须)分配恢复标识符到每一个你想去保存的视图控制器，做法是分配一个非空字符串到它们的<code>restorationIdentifier</code>属性.如果你也想去保存指定视图的状态，分配非空字符串到它们的<code>restorationIdentifier</code>属性.</li>
<li>(必须)在你的APP代理<code>application:willFinishLaunchingWithOptions:</code>方法中显示你的<code>window</code>.这个状态恢复系统需要这个<code>window</code>，如此它能恢复滚动位置和另外的与你的界面相关的一些东西。</li>
<li>指定对恰当视图控制器的恢复类.(如果没有这个，你的APP代理在恢复时间被询问去提供相应的视图控制器).</li>
<li>(推荐)编码和解码你的视图和视图控制器的状态，使用这些对象的<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法.</li>
<li>对于你的APP的任何版本信息或者额外的状态信息进行编码和解码，使用你的APP的代理<code>application:willEncodeRestorableStateWithCoder:</code>和<code>application:didDecodeRestorableStateWithCoder:</code>方法.</li>
<li>作为<code>table view</code>和<code>collection view</code>数据源的对象应该实现<code>UIDataSourceModelAssociation</code>协议.尽管这不是必须的，这个协议帮助保存在这些视图类型中的选中项和显示项.</li>
</ul>


<h3>保存你的视图控制器状态(Preserving the State of Your View Controllers)</h3>

<p>保存你的APP视图控制器状态应该是你主要的目标.视图控制器定义你的用户界面的结构.它们管理需要在界面上呈现的视图和协调支持的视图的数据的获取和设置.去保存一个单独的视图控制器状态，你必须做以下这些：</p>

<ul>
<li>(必须)分配一个恢复标识符到这个视图控制器.</li>
<li>(必须)在启动时间提供代码去创建或者定位新的视图控制器.</li>
<li>(可选)实现<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法去编码和恢复在下一次启动期间不能再现的状态信息.</li>
</ul>


<h4>标记你要保存的视图控制器(Marking Your View Controllers for Preservation)</h4>

<p>UIkit仅仅保存在视图控制器<code>restorationIdentifier</code>属性包含一个有效字符串对象的视图控制器.你知道你想去保存的视图控制器，当你初始化这个视图控制器对象时设置这个属性值.如果你的视图控制器是加载来自一个<code>storyboard</code>或者<code>nib</code>文件，你能在哪里设置这个恢复标识.</p>

<p>选择一个恰当的值作为恢复标识(<code>restoration identifiers</code>)是重要的.当这个恢复处理期间，你的代码使用这个恢复标识去确定那个视图控制器去寻回(<code>retrieve</code>)或者创建.如果每一个视图控制器对象是基于一个不同的类，你能使用类名作为恢复标识。无论如何，如果你的视图控制器层级包含了一个相同类的多个实例，你可能需要对每个视图控制器使用去选择不同的名字。</p>

<p>当它请你去提供一个视图控制器时，UIkit提供给你视图控制器对象的恢复路径.一个恢复路径是在根视图控制器开始的恢复标识序列，它沿着视图控制器层级向下直到你的当前的对象。例如，假如你有一个<code>tab bar controller</code>其标识符是<code>TabBarControllerID</code>，这个第一个<code>tab</code>包含了一个导航控制器其标识符是<code>NavControllerID</code>并且其根视图控制器标识是<code>MyViewController</code>.这个根视图控制器完整的恢复路径将是<code>TabBarControllerID/NavControllerID/MyViewController</code>.</p>

<p>每一个对象的恢复路径是唯一的。如果一个视图控制器有两个子视图控制器，每一个子视图控制器必须有一个不同的恢复标识。然而，两个视图控制器有两个不同的父对象可以使用相同的恢复标识符，因为这个恢复路径的剩余部分提供了需要的唯一性。一些UIkit视图控制器，例如导航控制器，自动消除它们子视图控制器的歧义，允许你对每一个子视图控制器使用相同的恢复标识。更多关于一个给定视图控制器的行为，去看相应的类参考。</p>

<p>在恢复时间，你使用提供的恢复路径去确定那些视图控制器返回给UIkit。</p>

<h4>在启动时间恢复你的视图控制器(Restoring Your View Controllers at Launch Time)</h4>

<p>在恢复处理期间，UIkit要求你的APP去创建(或者定位)视图控制器对象这些由你保存的用户界面组成。当尝试去定位视图控制器时UIkit坚持以下的过程:</p>

<ol>
<li>如果视图控制器有一个恢复类，UIkit要求这个类去提供这个视图控制器.UIkit调用这个关联的恢复类的<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法去找回这个视图控制器。如果这个方法返回<code>nil</code>，他是假定APP不想去重建这个视图控制器然后UIkit停止寻找它。</li>
<li>如果视图控制器没有一个恢复类，UIkit请求APP代理去提供这个视图控制器.UIkit调用你的APP代理的<code>application:viewControllerWithRestorationIdentifierPath:coder:</code>方法寻找一个没有恢复类的视图控制器.如果这个方法返回<code>nil</code>，UIkit视图去找到隐式视图控制器.</li>
<li>如果一个视图控制器的正确的恢复路径已经存在，UIkit使用这个对象.如果你的APP在启动时间创建视图控制器(以编程的方式或者通过加载它们来自一个资源文件)和分配了恢复标识符给它们，UIkit会通过它们的恢复路径隐式的找到它们。</li>
<li>如果视图控制器最初从一个<code>storyboard</code>文件加载，UIkit使用保存的<code>storyboard</code>信息去定位和创建它.UIkit保存关于在恢复档案内部存在的视图控制器相关的<code>storyboard</code>信息.在恢复时间，它使用这个信息去定位相同的<code>storyboard</code>文件和如果有视图控制器通过任何另外的方法没有被找到那么实例化相应的视图控制器.</li>
</ol>


<p>值得注意的是，如果你为一个视图控制器指定一个恢复类，UIkit不会试图隐式的去寻找你的视图控制器.如果你的恢复类的<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法返回<code>nil</code>，UIkit停止尝试去定位你的视图控制器。这给你控制是否真的想去创建这个视图控制器。如果你不指定一个恢复类，UIkit会做它能够找到这个视图控制器给你的任何事，当必要时从你的APP的<code>storyboard</code>文件创建它。</p>

<p>如果你选择去使用恢复类，你实现<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法应该创建恢复类的一个新实例，执行一些最小的初始化，返回所得的对象。以下代码是一个例子显示了你可能如何使用这个方法去从一个<code>storyboard</code>加载一个视图控制器。因为视图控制器是最初从<code>storyboard</code>加载的，这个方法使用<code>UIStateRestorationViewControllerStoryboardKey</code>键去获得来自档案文件(归档)的<code>storyboard</code>。注意此方法不试图去配置这个视图控制器的数据字段。当视图控制状态解码后这一步会发生。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">UIViewController</span><span class="o">*</span><span class="p">)</span> <span class="nf">viewControllerWithRestorationIdentifierPath:</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifierComponents</span>
</span><span class='line'>                      <span class="nf">coder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">MyViewController</span><span class="o">*</span> <span class="n">vc</span><span class="p">;</span>
</span><span class='line'>   <span class="bp">UIStoryboard</span><span class="o">*</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeObjectForKey</span><span class="p">:</span><span class="n">UIStateRestorationViewControllerStoryboardKey</span><span class="p">];</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PushViewController</span><span class="o">*</span><span class="p">)[</span><span class="n">sb</span> <span class="nl">instantiateViewControllerWithIdentifier</span><span class="p">:</span><span class="s">@&quot;MyViewController&quot;</span><span class="p">];</span>
</span><span class='line'>      <span class="n">vc</span><span class="p">.</span><span class="n">restorationIdentifier</span> <span class="o">=</span> <span class="p">[</span><span class="n">identifierComponents</span> <span class="n">lastObject</span><span class="p">];</span>
</span><span class='line'>      <span class="n">vc</span><span class="p">.</span><span class="n">restorationClass</span> <span class="o">=</span> <span class="p">[</span><span class="n">MyViewController</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">vc</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上当创建一个新的视图控制器时去重新分配一个恢复标识和恢复类是一个好的习惯。最简单的恢复这个恢复标识的方法是去抓住<code>identifierComponents</code>数据的最后一项把这项分配给你的新的视图控制器(如上代码所示).</p>

<p>关于在启动时间对象已经从你的APP主<code>storyboard</code>加载了，就不要为每一个对象创建一个新实例了。作为替代，实现你APP的<code>application:viewControllerWithRestorationIdentifierPath:coder:</code>方法和使用这个方法返回恰当的对象或者让UIkit隐式的找到这些对象。</p>

<h4>编码和解码你的视图控制器状态(Encoding and Decoding Your View Controller’s State)</h4>

<p>对于每一个计划保存的对象，UIkit调用对象的<code>encodeRestorableStateWithCoder:</code>去给它一个机会保存它的状态。在这个解码处理期间，UIKit调用<code>decodeRestorableStateWithCoder:</code>方法去解码这个状态和应用状态到这个对象。这些方法的实现是可选的，但是是被推荐的，对于你的视图控制器。你可以使用它们去保存和恢复以下的信息类型：</p>

<ul>
<li>对任何被展示的数据的引用(不是数据本身)</li>
<li>用于一个容器视图控制器，对它子视图控制器的引用</li>
<li>关于当前选择的信息</li>
<li>用于具有用户可配置视图的视图控制器，关于这个可配置视图的当前配置信息。</li>
</ul>


<p>在你的编码和解码方法里面，你能编码由编码器支持的任何值，包括其他的对象。对于除视图和视图控制器之外的所有对象，这个对象必须采用<code>NSCoding</code>协议和使用这个协议的方法去写它的状态。对于视图和视图控制器，编码器不使用<code>NSCoding</code>协议的方法去保存这个对象状态对象。作为代替，编码器保存这个对象的恢复标识和添加它到可保存的对象列表，这结果在该对象的<code>encodeRestorableStateWithCoder:</code>方法里面被调用。</p>

<p>你的视图控制器的<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法应该总是在它们实现的一些点调用<code>super</code>。调用<code>super</code>给父类一个机会去保存和恢复任何额外的信息。以下的代码简单的实现了这些方法，其保存一个用于去识别指定视图控制器的数字值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">encodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">super</span> <span class="nl">encodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">[</span><span class="n">coder</span> <span class="nl">encodeInt</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">MyViewControllerNumber</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">decodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">super</span> <span class="nl">decodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeIntForKey</span><span class="p">:</span><span class="n">MyViewControllerNumber</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编码和解码处理期间编码器对象不是共享的。每个对象的可保存状态接收它自己的编码器，如此它能使用去读或者写数据。这个独特的编码器使用方式使你不用去担心在你自己的对象之间关键的命名空间冲突。然而，你必须仍然避免使用一些UIkit提供的特定键名。具体的，每一个编码器包含<code>UIApplicationStateRestorationBundleVersionKey</code>和 <code>UIApplicationStateRestorationUserInterfaceIdiomKey</code>键，它们提供了关于包版本(<code>bundle version</code>)和当前用户界面风格(<code>idiom</code>).编码器关联的视图控制器可能同样包含了<code>UIStateRestorationViewControllerStoryboardKey</code>键，这个识别视图控制器来源于哪一个<code>storyboard</code>.</p>

<h3>保存你的视图的状态(Preserving the State of Your Views)</h3>

<p>如果视图有状态值得保存，你能够保存你的APP视图控制器的剩余部分状态。因为它通常是由拥有它的视图控制器配置,大部分视图不需要保存状态信息。你唯一需要保存一个视图状态的时间是当视图能够被用户通过一种方式改变，并且这个改变是独立于它的数据和拥有它的视图控制器的。例如,<code>scroll</code>视图保存了当前的滚动位置，这个信息对于视图控制器是没有趣的但是这个会影响这个视图如何去呈现它自己。</p>

<p>指定一个视图状态应该保存，你要做以下的：</p>

<ul>
<li>分配一个有效的字符串到视图的<code>restorationIdentifier</code>属性</li>
<li>使用来自视图控制器的视图同样有一个有效的恢复标识符</li>
<li>对于<code>table views</code>和<code>collection views</code>,分配一个采用了<code>UIDataSourceModelAssociation</code>协议的数据源</li>
</ul>


<p>与视图控制器一样，分配一个恢复标识符到一个视图告诉系统这个视图有你的APP想去保存的状态。之后这个恢复标识符能同样被使用去定位这个视图。</p>

<p>像视图控制器，视图定义方法关于编码和解码它们自定义状态。如果你创建一个它的状态值得保存的视图，你能使用这些方法去读和写任何相关的数据。</p>

<h4>有可保存状态的UIKit视图(UIKit Views with Preservable State)</h4>

<p>为了保存任何视图的状态，包括自定义和标准系统视图两种，你必须分配一个恢复标识符给这个视图。视图没有一个恢复标识符UIKit是不会把它加入一个可保存对象列表的。</p>

<p>以下的UIKit视图有能被保存的状态信息：</p>

<ul>
<li><code>UICollectionView</code></li>
<li><code>UIImageView</code></li>
<li><code>UIScrollView</code></li>
<li><code>UITableView</code></li>
<li><code>UITextField</code></li>
<li><code>UITextView</code></li>
<li><code>UIWebView</code></li>
</ul>


<p>其他的框架可能同样有可保存状态的视图。关于视图是否保存状态信息和保存什么状态信息，可以看相应类的参考。</p>

<h4>保存自定义视图的状态(Preserving the State of a Custom View)</h4>

<p>如果你实现一个有可恢复状态的自定义视图，实现<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法和使用它们去编码和解码这个状态。使用这些方法去保存只有在通过其他的方式不能很容易的被重新配置的数据。例如，使用这些方法去保存用户与视图交互被修改的数据。不要使用这些方法去保存由视图去呈现的数据或者所属视图控制器能够很容易配置的任何数据。</p>

<p>如下代码显示如何去保存和恢复一个包含可编辑文本的自定义视图的选择。在这个例子里，这个选择范围是使用<code>selectionRange</code>和<code>setSelectionRange</code>去访问，这些是自定义方法，视图使用这些方法去管理选择范围。编码这些数据只需要写它们到一个提供的编码器(<code>coder</code>)对象。恢复数据需要读取这个编码器(<code>coder</code>)对象然后应用数据到这个视图。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// Preserve the text selection</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">encodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">encodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSRange</span> <span class="n">range</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">selectionRange</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">coder</span> <span class="nl">encodeInt</span><span class="p">:</span><span class="n">range</span><span class="p">.</span><span class="n">length</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLength</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">coder</span> <span class="nl">encodeInt</span><span class="p">:</span><span class="n">range</span><span class="p">.</span><span class="n">location</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLocation</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Restore the text selection.</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">decodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">super</span> <span class="nl">decodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">([</span><span class="n">coder</span> <span class="nl">containsValueForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLength</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>           <span class="p">[</span><span class="n">coder</span> <span class="nl">containsValueForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLocation</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSRange</span> <span class="n">range</span><span class="p">;</span>
</span><span class='line'>      <span class="n">range</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeIntForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLength</span><span class="p">];</span>
</span><span class='line'>      <span class="n">range</span><span class="p">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeIntForKey</span><span class="p">:</span><span class="n">kMyTextViewSelectionRangeLocation</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>         <span class="p">[</span><span class="nb">self</span> <span class="nl">setSelectionRange</span><span class="p">:</span><span class="n">range</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>实现友好保存数据源(Implementing Preservation-Friendly Data Sources)</h4>

<p>因为通过<code>table</code>或者<code>collection</code>视图显示的数据可以更改，只有这两个类实现了<code>UIDataSourceModelAssociation</code>协议才会保存当前选中项和当前显示的<code>cell</code>信息。这个协议提供了一个关于<code>table</code>或者<code>collection</code>视图去识别它所包含的不依赖该内容的索引路径(<code>index path</code>)的内容。如此，在下一个启动周期期间不管这个数据源(<code>data source</code>)放置一个项(<code>item</code>)在哪里，这个视图仍然有所有的它需要去定位相应项(<code>item</code>)的信息。</p>

<p>为了成功的实现<code>UIDataSourceModelAssociation</code>协议，你的数据源对象必须能确定在APP随后启动之间的项(<code>items</code>).这个意味着你设计的任何识别方案对于一个给定的数据块必须是不变的。这个是必不可少的，因为数据源(<code>data source</code>)每次请求同样的标识符必须能寻回同样的数据块。实现这个协议本身是一个数据项到它唯一<code>ID</code>的关系映射，之后通过这种映射再次返回相应项。</p>

<p>APP使用<code>Core Data</code>利用对象标识符能实现这个协议。每一个对象在<code>Core Data</code>里储存有一个唯一对象标识符，这个能够被转换成一个<code>URL</code>，之后可以使用这个<code>URL</code>去定位这个对象。如果你的APP不使用<code>Core Data</code>，如果你想去支持你视图的状态保存那么你需要去设计你自己唯一标识的形式。</p>

<p><code>Note:记住实现UIDataSourceModelAssociation协议是只必须(only necessary)去保存属性(attributes)例如在一个table或者collection视图的当前选择项。这个协议不用于保存由你的数据源(data source)管理的实际数据。这个是你APP的责任，去确保它的数据在恰当的时间保存。</code></p>

<h3>保存你的APP高等级状态(Preserving Your App’s High-Level State)</h3>

<p>除了由你的APP的视图控制器和视图保存数据之外，UIkit提供钩子给你去保存任何你的APP所需要的各种各样的数据。具体的,<code>UIApplicationDelegate</code>协议包含了以下的方法给你覆盖：</p>

<ul>
<li><code>application:willEncodeRestorableStateWithCoder:</code></li>
<li><code>application:didDecodeRestorableStateWithCoder:</code></li>
</ul>


<p>如果你的APP包含的状态不被视图控制器所拥有，但是需要去保存，你能使用前面的方法去保存和恢复它。<code>application:willEncodeRestorableStateWithCoder:</code>方法在保存过程一开始被调用，如此你能写出任何高级别的APP状态，例如你的用户界面的当前版本。<code>application:didDecodeRestorableStateWithCoder:</code>方法在恢复状态结束时被调用，如此你能解码任何数据和执行任何你的APP需要的最后的清理。</p>

<h3>保存和恢复状态信息技巧(Tips for Saving and Restoring State Information)</h3>

<p>当你添加状态保存和恢复到你的APP，考虑以下的指导：</p>

<ul>
<li>编码版本信息以及你的APP状态的其余部分。当保存过程期间，建议你编码一个版本字符串或者数字作为标识你的APP用户界面的当前版本。你能在你的APP代理<code>application:willEncodeRestorableStateWithCoder:</code>方法中编码这个状态。当你的APP代理 <code>application:shouldRestoreApplicationState:</code>方法被调用，你能从提供的编码器(<code>coder</code>)找回这个信息和使用它去确定是否状态保存是可能的。</li>
<li>在你的APP状态里不要包含来自你数据模型(<code>data model</code>)的对象.APP应该继续去保存它们的数据分别在云(<code>iCloud</code>)或者在磁盘上的本地文件。绝不使用状态恢复系统去保存这个数据。在一个恢复操作期间如果有问题发生保存的界面数据可能被删除。因此，任何你写到磁盘的保存相关的数据应该考虑清除。</li>
<li>状态保存系统期望你按照这种方式去使用视图控制器，它们是设计去被使用的。视图控制器层级是通过一个视图控制器包含的组合创建的，并由另一个视图控制器去呈现一个视图控制器。如果你的APP通过另外一种方式显示一个视图控制器的视图，例如添加它到一个另外的视图且没有在相应的视图控制器中间创建包含关系——这个保存系统将不能去找到你的视图控制器去保存它。</li>
<li>记住，你可能不想去保存所有的视图控制器。有时候，它可能没有去保存一个视图控制器的意义。例如，当显示一个视图控制器去改变用户密码的时候，如果用户离开了你的APP，你可能想去取消这个操作和恢复APP到以前的屏幕。在这种情况，你将不保存那个要求新密码信息的视图控制器。</li>
<li>在恢复过程期间避免交换视图控制器类。状态保存系统编码它保存的视图控制器类。在恢复期间，如果你的APP返回一个对象，这个对象的类和(或者不是一个子类)这个原来的对象不匹配，这个系统不要求视图控制器去解码任何状态信息。如此，将旧的视图控制器换成一个完全不同的视图控制器并且不恢复这个对象的全部状态。</li>
<li>当用户强制退出这个APP时系统自动删除APP保存的状态。当APP被终结(<code>killed</code>)时删除保存的状态信息是一个安全的预防措施。(作为一种安全的预防措施，如果APP在启动期间崩溃两次系统同样删除保存的状态)，如果你想去测试你的APP恢复状态的能力，在调试时(<code>debugging</code>)你不应该使用多任务栏(<code>multitasking bar</code>)去终结这个APP。作为替代，使用<code>Xcode</code>去<code>Kill</code>这个APP或者通过安装一个临时命令以编程的方式<code>kill</code>这个APP或者手势去调用<code>exit</code>根据需要.</li>
</ul>


<h2>一个VoIP App开发技巧(Tips for Developing a VoIP App)</h2>

<p>一个因特网上的音频协议(VoIP)APP允许用户使用一个互联网连接打电话而不是设备移动服务。在iOS8或者之后的系统，你能使用苹果推送通知(APNs)和PushKit框架的APIs去创建一个VoIP APP。依赖这个推送通知去启用VoIP功能意味着你的APP不要去保持(或维护)一个到所关联服务的持久的网络连接或者配置一个套接字(socket)给VoIP使用。当一个VoIP推送通知抵达，你的APP是给定时间去处理这个通知，即使你的APP现在是被终结的。</p>

<p><code>Note:VoIP推送通知是只发送给设备上运行的是iOS8或者这之后的系统。如果你需要    去支持运行以前iOS版本的设备，你有责任去维护一个兼容的实现.</code></p>

<p>和任何后台音频(audio)APP一样，关于VoIP APP的音频会话(audio session)必须配置正确去确保这个APP和另外的基于音频的APP工作顺利。因为一个VoIP APP的音频播放(playback)和录音不在所有时间都使用，只有在它需要的时候去创建和配置你APP的音频会话这个尤其重要。例如，你要创建音频会话去通知用户有电话进来或者用户实际上正在打电话。一到电话结束，你将接下来移除对这个音频会话的引用去给另外的音频APP机会去播放它们的音频。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用工具规范OC代码样式]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/29/yong-gong-ju-gui-fan-ocdai-ma-yang-shi/"/>
    <updated>2016-07-29T15:13:14+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/29/yong-gong-ju-gui-fan-ocdai-ma-yang-shi</id>
    <content type="html"><![CDATA[<h1>规范OC代码样式</h1>

<p>在团队开发过程中，可能你team里面的每个成员都有自己不同的代码风格，其实代码风格到不是一定要很规范，但是一定要很统一，这样整体的代码在是视觉上就不会显得很混乱，而且互相阅读代码的时候也会很自然。这篇文章是来安装适当的工具强制team成员形成统一的代码样式。</p>

<h2>安装Xcode插件用于格式化你的代码到相应的范式</h2>

<p><a href="https://github.com/benoitsan/BBUncrustifyPlugin-Xcode">这里</a>这里有一个插件，安装完后你就可以在Xcode的菜单中找到响应的格式化命令了。安装可以选择在终端运行</p>

<pre><code>    curl -SL https://raw.githubusercontent.com/benoitsan/
    BBUncrustifyPlugin-Xcode/master/install.sh | sh
</code></pre>

<p>自动下载安装。(也可以使用插件目录中提到的另外两种安装方法)</p>

<p>安装完成后，如果重启Xcode可以看到菜单<code>Edit &gt; Format Code</code>中的以下命令：</p>

<ol>
<li>使用<code>Format Selected Files</code>去格式化在项目导航中选定的文件。</li>
<li>使用<code>Format Active File</code>去格式化在编辑器中实际打开的文件。</li>
<li>使用<code>Format Selected Lines</code>去格式化选中的代码行(多行选中时支持的)。如果选中的行没有满选会自动扩展的整行，如果没有选中任何行，就会使用光标下的行作为格式化。</li>
<li>使用<code>Edit Configuration</code>在一个额外的编辑器去配置这个格式化程序。</li>
<li>使用<code>BBUncrustifyPlugin Preferences</code>去改变插件参数配置。</li>
</ol>


<h2>UncrustifyX可视化配置你的代码规范</h2>

<p>你想要的代码规范是怎么样的，你可以参考<a href="http://uncrustify.sourceforge.net/">这里</a>去直接编辑文件设置你要的格式，你也可以使用UncrustifyX这个可视化工具配置，推荐后者，这样会有感官。你可以到<a href="https://github.com/ryanmaxwell/UncrustifyX/releases">这里</a>下载最新版本安装。</p>

<h2>git commit hooks(这里使用Git版本控制)</h2>

<p><a href="https://github.com/githubbrowser/Pre-commit-hooks">这里</a>有已经写好的<code>pre-commit-uncrustify(rename为pre-commit)</code>、<code>canonicalize_filename.sh(一个定位路径输出的文件)</code>可以下载，把这个两个文件<code>copy</code>到你的本地项目仓库的<code>.git/hooks</code>文件夹下面,值此就可以生效了，不过别忘了做一下配置，像如下的：</p>

<ol>
<li>设置uncrustify的路径像我这里的的路径为<code>/Applications/UncrustifyX.app/Contents/Resources/uncrustify</code>.</li>
<li>设置uncrustify配置位置，我这里路径为<code>$HOME/.uncrustify/uncrustify.cfg</code>.</li>
</ol>


<h2>git receive hooks</h2>

<p><code>commit</code>可能还不能满足要求，我们为了统一代码规范，需要在<code>git</code>服务端检查，规范不符合我们团队的我们就拒绝<code>push</code>,所以需要在<code>receive</code>的时候也触发调用。<a href="https://github.com/liuhaoxiu/pre-receive-uncrustify-hooks">这里</a>这里有我自己参考资料改的一个<code>pre-receive</code>文件可以达到上述要求，你下载完成后把<code>pre-receive</code>、<code>canonicalize_filename.sh</code>一并<code>copy</code>到服务端你的项目仓库的hooks目录下面,至此就会生效了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理APP状态转换的策略]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/22/chu-li-appzhuang-tai-zhuan-huan-de-ce-lue/"/>
    <updated>2016-07-22T16:01:54+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/22/chu-li-appzhuang-tai-zhuan-huan-de-ce-lue</id>
    <content type="html"><![CDATA[<h1>处理APP状态转换的策略(Strategies for Handling App State Transitions)</h1>

<p>  对于每一个APP可能的运行时状态，你的APP在进入每一个状态的时候系统都有不同的预期。但状态迁移发生时，系统通知这个APP对象，这个APP对象通知它自己的代理对象。你能使用<code>UIApplicationDelegate</code>协议的状态迁移方法去发现这些状态的改变和作出适当的响应。</p>

<h2>在APP启动时间做些什么(What to Do at Launch Time)</h2>

<p>  当你的APP已经启动(无论是进入前台和是后台)，使用你的APP代理方法<code>application:willFinishLaunchingWithOptions:</code>和 <code>application:didFinishLaunchingWithOptions:</code>去做一下这些。</p>

<ul>
<li>检查启动选项字典的内容得到关于为什么这个APP已经启动信息并作出适当的响应。</li>
<li>初始化你的APP关键的数据结构。</li>
<li><p>准备你的APP作为显示的窗体(window)和视图(views)</p>

<p>在启动时间，系统自动加载你的APP的主故事板(storyboard)文件和加载初始的视图控制器(view controller)。关于APP支持的状态恢复，在调用<code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法中间，APP状态恢复机械的恢复你的界面到以前的状态。使用<code>application:willFinishLaunchingWithOptions:</code>方法去显示你的APP窗体(window)和去确定状态恢复是否全部发生。使用<code>application:didFinishLaunchingWithOptions:</code>方法去对你的APP界面做最后的调整。</p>

<p>你的<code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法中应该做尽可能少的事情去减少你的APP的启动时间。APP是预期去启动初始化它们自己并在五秒之内开始处理事件。如果一个APP没有及时的结束它的启动周期，系统会终止它。所以，任何可能减慢你的启动的任务(例如访问网络)应该安排它执行在一个次要的线程上。</p></li>
</ul>


<h3>启动周期(The Launch Cycle)</h3>

<p>  当你的APP已经启动，它从没运行状态(not running)进入到活动状态(active)或者后台状态(background)，迁移短暂的进入到不活动状态作为过渡(inactive)。作为启动周期的一部份，系统为你的APP创建一个过程和主线程并在主线程上调用你APP的主函数(main function)。进来这个默认的主函数随着你的Xcode项目迅速的传递控制到UIKit框架上面，这个主函数大部分的工作是初始化你的APP和为APP运行做准备。
  当你的APP启动进入后台(background)时-通常去处理一些后台事件类型，和启动进入前台主要不同的是你的APP不是活动的(active),它进入后台状态去操作事件，在操作完时间之后可能会在任何时间挂起。当启动进入后台时，系统任然加载你的APP用户界面文件但是它不显示APP窗体(window)。
   去确定你的APP是进入前台还是后台，在你的<code>application:willFinishLaunchingWithOptions:</code>或者<code>application:didFinishLaunchingWithOptions:</code>代理方法中检查共享的<code>UIApplication</code>对象的<code>applicationState</code>属性值。当你的APP是进入的前台，这个属性值是<code>UIApplicationStateInactive</code>。当你的APP启动进入了后台，这个属性值是<code>UIApplicationStateBackground</code>，你能使用这个值去调整你的代理方法做相应的启动时间行为。</p>

<h3>横屏模式启动(Launching in Landscape Mode)</h3>

<p>  APP只有使用横屏模式启动它们的界面必须明确的告诉系统这个APP的启动方向。通常的，APP启动在竖屏模式然后界面旋转匹配设备需要的方向。关于APP支持的竖屏和横屏方向，你应该总是配置你的视图到横屏模式然后让你的视图控制器去操作任何的旋转。如果APP支持横屏单不支持竖屏方向，执行以下的几个任务去制作它初始横屏启动。</p>

<ul>
<li> 添加<code>UIInterfaceOrientation</code>键到你的APP的<code>Info.plist</code>文件，设置这个键的值为 <code>UIInterfaceOrientationLandscapeLeft</code>或者<code>UIInterfaceOrientationLandscapeRight</code>其中一个。</li>
<li> 布局你的视图在横屏模式，确保它们的布局或者自动尺寸选项是设置正确的。</li>
<li><p> 覆盖你的视图控制器的<code>shouldAutorotateToInterfaceOrientation:</code>方法，当旋转到横屏方向的left或者right时返回YES，当旋转到竖屏方向是返回NO。</p>

<pre><code>    Important:APP应该总是使用视图控制器去管理它们基于窗口的内容
</code></pre></li>
</ul>


<p>  这个<code>UIInterfaceOrientation</code>键在<code>Info.plist</code>文件告诉iOS它应该配置APP的状态栏的方向(如果有一个显示的)此外通过视图控制器在启动时间管理视图的方向。视图控制器考虑这个键然后设置他们的视图的初始方向去匹配。使用这个键等同于在早期的 <code>applicationDidFinishLaunching:</code>方法中调用UIApplication对象的<code>setStatusBarOrientation:animated:</code>方法。</p>

<h3>在第一次启动安装APP特定的数据文件(Installing App-Specific Data Files at First Launch)</h3>

<p>  你能利用你的APP第一次启动周期去建立任何数据和需要去运行的配置文件。APP特定的数据文件应该创建在你的APP沙盒的Library/Application Support/<bundleID>/目录，<bundleID>是你的APP包(bundle)标识。你能进一步细分这个目录去组织你需要的数据文件。你能同样创建文件在另外的目录，例如你的APP iClound容器目录或者本地Documents目录，这个主要根据你的需要。
   如果你的APP包(bundle)包含了你计划去改变的文件，复制这些文件到一个可以修改文件的目录，如果你直接在包(bundle)里面修改它们，那么你的APP的签名会无效，因为APP包(bundle)是代码签名了的，签名无效以为着你的APP在将来启动的时候回被系统阻止，你唯一方法是把这些要修改的文件复制到应用程序沙盒支持的可写的目录然后才能安全的使用这些文件。</p>

<h2>当你的APP暂时的中断时干些什么(What to Do When Your App Is Interrupted Temporarily)</h2>

<p>一个基于提醒的中断导致你的APP暂时失去控制，你的APP继续运行在前台，但是不接收任何来自系统的触摸事件(它不继续去接收通知和另外的事件类型，例如加速计事件)。去响应这个改变，你的APP应该在<code>applicationWillResignActive:</code>方法中做一下的事。</p>

<ul>
<li>保存数据和任何相关的状态信息.</li>
<li>停止计时器和另外的定期任务.</li>
<li>停止运行任何元数据查询.</li>
<li>不开始任何新任务。</li>
<li>暂停电影播放(通过AirPlay播放除外).</li>
<li>如果是游戏就使游戏进入一个暂停状态。</li>
<li>调节减慢OpenGL ES帧速率.</li>
<li><p>暂停任何调度队列(dispatch queues)或者操作队列(operation queues)去执行非关键的代码。(你能继续处理网络请求和另外时间灵敏的后台任务在不活动状态(inactive)).</p>

<p>当你的APP迁移回活动(active)状态，它的<code>applicationDidBecomeActive:</code>方法应该反转在<code>applicationWillResignActive:</code>方法中做得任何步骤，你的APP应该重新启动计时器，恢复调度队列，加速OpenGL ES帧速率。无论如何，游戏不应该自动恢复，它们应该保持在暂停状态知道用户选择去恢复它们。</p></li>
</ul>


<p> 当用户按压休眠/唤醒按钮，APP设置了<code>NSFileProtectionComplete</code>保护选项保护文件，这时必须关闭所有对这些文件的引用。设备配置一个适当的密码，按压休眠/唤醒按钮锁定屏幕会强制系统扔掉文件的解密秘钥使其能起到完整的保护。在这个屏幕锁定期间，任何企图去访问相应的文件将失败。如此如果你有这样的文件，你应该在你的<code>applicationWillResignActive:</code>方法中关闭任何对这些文件的引用和在你的<code>applicationDidBecomeActive:</code>方法中打开新的引用。</p>

<pre><code>    Important:总是在你的APP的适当的检查点保存数据，尽管你能使用APP状态迁移去强制对象去写未保
    存的数据到磁盘，但是绝不等到一个APP的状态迁移去保存数据。例如，一个视图控制器管理用户数据应
    该在它离开(dismissed)时保存数据
</code></pre>

<h3>暂时中断的响应(Responding to Temporary Interruptions)</h3>

<p>当一个基于提醒的中断发生，例如你一个进来的电话，APP暂时移动到不活动状态如此系统能提示这个用户如何继续下去。APP停留在这个状态直到用户关闭了这个提醒(alert)。在这一点上，APP返回到活动状态或者后台状态。</p>

<p>设置通知作为横幅显示的不会是你的APP不活动(不影响你APP)，基于提醒的APP才会影响(如上)，这个横幅显示在APP窗体顶部的边缘，你的APP可以继续接收触摸事件就像以前一样。无论如何，如果用户拉下这个横幅去显示这个通知中心，你的APP会移动到不活动状态就像发生了一个基于提醒的通知一样。你的APP保持在这个不活动状态直到用户消散(或者关闭反正就是不显示在屏幕上了)了这个通知中心或者启动了另外的APP。在这些情况上，你的APP移动到相应的活动或者后台状态。用户能够使用设置APP(Settings app,就是手机上设置你可以单独设置每个应用的设置地方)去配置那个显示横幅方式的通知和那个显示基于提醒的通知。</p>

<p>按休眠/唤醒按钮是另外一种中断类型，这个引起你的APP临时不活动。当用户按了这个按钮，系统使触摸事件失效(就是系统整个不再接收触摸事件)，移动APP到后台，设置APP的<code>applicationState</code>属性值为<code>UIApplicationStateBackground</code>和锁定屏幕。锁定屏幕对于APP来说是额外的后果，用户数据会保护到加密文件。</p>

<h2>当你的APP进入前台状态时做什么(What to Do When Your App Enters the Foreground)</h2>

<p>返回到前台状态你的APP有机会去重新启动在它移动到后台时停止的任务。</p>

<pre><code>Note:当你的APP重新进入前台这个UIApplicationWillEnterForegroundNotification
通知是可以获得的。在你的APP里的对象可以去使用默认的通知中心注册这个通知。
</code></pre>

<h3>准备处理排队通知(Be Prepared to Process Queued Notifications)</h3>

<p>  一个APP在挂起状态当它返回到前台或者后台执行状态时必须准备好去处理任何排队通知。一个挂起的APP不处理任何代码，因此也不能处理通知相关方向的改变，时间的变化，偏好的变化，和许多会影响APP外观和状态的变化。确保这些改变没有丢失，系统排队了许多相关的通知，直到APP再一次开始执行代码才交付这些通知给APP（前台或者后台任意一个状态）。为了防止当APP恢复时通知过多时APP发生过载，系统合并事件（每一个相关的事件），这些事件反映的是是你的APP自暂停以来的净变化(net change).</p>

<p>下表中的通知可以合并和交付到你的APP的。大部分这些通知是直接交付到你注册的观察者。像这些与设备方向改变相关的，是典型的通过系统框架拦截然后用另外的方法交付给你的APP。</p>

<table>
<thead>
<tr>
<th>事件 </th>
<th> 通知</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个配件连接或者断开连接 </td>
<td> EAAccessoryDidConnectNotification与EAAccessoryDidDisconnectNotification</td>
</tr>
<tr>
<td>设备方向改变 </td>
<td> UIDeviceOrientationDidChangeNotification除了这个通知，视图控制器自动的更新他们的界面方向</td>
</tr>
<tr>
<td>一个有重大意义(significant)的时间变化 </td>
<td> UIApplicationSignificantTimeChangeNotification</td>
</tr>
<tr>
<td>电池电量等级改变(The battery level)或者电池状态改变 </td>
<td> UIDeviceBatteryLevelDidChangeNotification与UIDeviceBatteryStateDidChangeNotification</td>
</tr>
<tr>
<td>接近状态改变(例如接近传感器) </td>
<td> UIDeviceProximityStateDidChangeNotification</td>
</tr>
<tr>
<td>文件保护状态改变 </td>
<td> UIApplicationProtectedDataWillBecomeUnavailable与UIApplicationProtectedDataDidBecomeAvailable</td>
</tr>
<tr>
<td>一个外部的显示连接或者断开连接 </td>
<td> UIScreenDidConnectNotification与UIScreenDidDisconnectNotification</td>
</tr>
<tr>
<td>屏幕显示模式改变 </td>
<td> UIScreenModeDidChangeNotification</td>
</tr>
<tr>
<td>你的APP偏好通过Settings app暴露出来被更改 </td>
<td> NSUserDefaultsDidChangeNotification</td>
</tr>
<tr>
<td>当前语言或者区域设置改变 </td>
<td> NSCurrentLocaleDidChangeNotification</td>
</tr>
<tr>
<td>用户的云账户状态改变 </td>
<td> NSUbiquityIdentityDidChangeNotification</td>
</tr>
</tbody>
</table>


<p>  排队通知是交付到你的APP的主运行循环(run loop)并且通常是交付在任何触摸事件或者另外的用户输入以前。大部分APP应该尽可能足够快的去处理这些事件那样在恢复时才将不会引起任何明显的滞后。无论如何，当你的APP从后台状态返回如果它出现了迟钝，使用Instruments去确定是是否你的通知处理代码引起了延迟。
  一个APP返回到前台同样接收任何视图的视图更新通知，这些是自从最后一次更新以来需要重新更新的视图。一个APP运行在后台任然可以调用<code>setNeedsDisplay或setNeedsDisplayInRect:</code>方法去请求视图的更新。因外这个视图没有显示，系统合并这些请求当APP返回到前台后更新。</p>

<h3>处理云(iClound)变化(Handle iCloud Changes)</h3>

<p>  处于任何理由的iClound状态改变，系统交付 <code>NSUbiquityIdentityDidChangeNotification</code>通知给你的APP。当用户登录或者登出一个iClound账户或者启用或者禁用文档和数据同步这个iClound状态会改变。这个通知是提示你的APP去更新缓存和任何iClound相关的用户界面元素去适应这个改变。例子，当用户登出iClound，你应该移除所有基于iClound文件或者数据的引用。
  如果你的APP已经提示用户是否去存储文件到iClound，当iClound状态改变是不会再次提示用户。在第一次提示用户之后，存储用户的选择到你的APP的本地偏好里面。你可能接下来想使用一个设置包(Settings bundle)或者作为在你APP里面的一个选项去暴露这个偏好。但是再次重复提示除非偏好目前没有在你的用户默认数据库里面。</p>

<h3>处理区域变化(Handle Locale Changes)</h3>

<p> 在你的APP挂起期间如果用户改变了当前的区域，当你的APP返回到前台时你能使用<code>NSCurrentLocaleDidChangeNotification</code>通知去强制更新任何视图包含了区域敏感(locale-sensitive)信息，例如时间，计时器，和数字。当然，最好的避免区域相关问题方法是去用你的方式写代码去制作它简单的更新视图。</p>

<h3>处理改变你的APP设置(Handle Changes to Your App’s Settings)</h3>

<p>如果你的APP的设置是通过Settings app管理的，他观察 <code>NSUserDefaultsDidChangeNotification</code>通知。应为用户能改变设置在你的APP挂起或者进入后台期间，你能够使用这个通知去响应那些设置中重大的改变。有时候，响应这个通知能够帮助你关闭一个潜在的安全漏洞。例子，一个邮件程序应该响应用户账户信息的改变。未能监测这些变化可能会引起隐私或者安全问题。典型的，当前的用户可能能够使用旧的账户信息去发送邮件，甚至这个账户不在属于这个用户了。
根据接收这个<code>NSUserDefaultsDidChangeNotification</code>通知，你的APP应该重新载入任何相关的设置，必要时，适当重置它的用户界面。如果密码或者另外的安全相关的信息改变了，你应该同样隐藏任何先前的显示信息，强制用户去键入新的密码。</p>

<h2>当你的APP进入后台时做什么(What to Do When Your App Enters the Background)</h2>

<p>当从前台移动到后台执行，使用你的app代理的<code>applicationDidEnterBackground:</code>方法去做以下的事:</p>

<ul>
<li>准备去拿你APP的照片。当你的<code>applicationDidEnterBackground</code>方法返回时，系统拿你的APP用户界面的图片去使用这个结果图片做动画迁移。如果你的用户界面的视图包含了任何的敏感信息，在调用<code>applicationDidEnterBackground</code>方法返回之前你应该隐藏或者修改这些视图。如果你添加了新的视图到你的视图层级并作为这个过处理的一部分，你必须强制这些视图去绘制。</li>
<li>保存任何APP相关的状态信息。在进入后台之前，你的APP应该已经保存了所有的用户关键数据。使用迁移到后台去保存任何最后一分钟的变化到你的APP状态。</li>
<li>根据需要释放内存。释放任何你不需要的缓存数据和做任何简单的清理，这个能够减少你APP的内存占用。APP占用太大的内存系统会第一个终止它，如此释放你不需要的图片资源，数据缓存，和任何另外的对象。</li>
</ul>


<p>你的APP代理<code>applicationDidEnterBackground</code>方法有大约五秒钟去结束任何未完成的任务然后返回，事实上，这个方法应该尽可能快的返回。如果这个方法在时间耗尽以前还没有返回，你的APP会被终止占用的内存会被释放。如果你任然需要更多的时间去执行任务，调用<code>beginBackgroundTaskWithExpirationHandler</code>方法去请求更多的后台执行时间，还有就是开启一个长运行任务在次要的线程。不管你是否启动任何后台任务，<code>applicationDidEnterBackground</code>方法在五秒钟之内任然必须退出。</p>

<pre><code>    Note:系统除了调用applicationDidEnterBackground方法之外还发送
    UIApplicationDidEnterBackgroundNotification通知，你可以使用这个通知去分布清理任
    务到你的APP的另外的对象
</code></pre>

<h3>后台迁移周期(The Background Transition Cycle)</h3>

<p>当用户按了Home键，按了休眠/唤醒键，或者系统启动了另外一个APP，当前的前台APP迁移到不活动状态接着迁移到后台状态。这些迁移结果导致调用APP的代理<code>applicationWillResignActive:</code> 和<code>applicationDidEnterBackground:</code>方法<code>applicationDidEnterBackground:</code>方法返回后，不久后大部分的APP移动到挂起状态。APP可以请求指定的后台任务(例如音乐播放)或者请求一点额外执行时间让这个APP就能够继续运行一段时间。</p>

<h3>准备APP快照(Prepare for the App Snapshot)</h3>

<p>APP的<code>applicationDidEnterBackground:</code>方法返回后不久，系统拿一个APP窗体的快照。同样的，当一个APP唤醒去执行后台任务时，系统可能拿一个快照去反映任何相关的改变。
如果你制造改变在APP马上进入后台时，你能调用主视图的<code>snapshotViewAfterScreenUpdates:</code>方法去强制这些改变去渲染。关于快照调用一个视图的<code>setNeedsDisplay</code>方法是无效的因为快照是拿下一个绘制周期以前的，因此阻止任何改变被渲染。调用<code>snapshotViewAfterScreenUpdates</code>并传入参数YES强制立即更新到基础缓冲区给快照机器使用(the snapshot machinery uses.)。</p>

<h3>降低你的内存占用(Reduce Your Memory Footprint)</h3>

<p>每个APP在马上进入后台时应该释放许多的内存这种做法是实用的。系统在同一时间视图保持许多的APP在内存里当它可以能够如此的话，但是当内存运行比较低的时候系统会终止挂起的APP来回收内存。当在后台期间APP消耗大量的内存那么它会第一个被终止。
实际上来说，当你的APP不在对这个对象需要时你的APP应该移除对这个对象的强引用，移除强引用给编译器有能力去立即释放这个对象，如此相应的内存能够回收。无论如何，如果你想去缓存一些对象去改善性能，你能等到直到APP迁移到后台以前移除对这些对象的引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac上安装Visual Studio Code开发Asp.Net应用程序]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/21/zai-macshang-an-zhuang-visual-studio-codekai-fa-asp-dot-netying-yong-cheng-xu/"/>
    <updated>2016-07-21T11:02:25+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/21/zai-macshang-an-zhuang-visual-studio-codekai-fa-asp-dot-netying-yong-cheng-xu</id>
    <content type="html"><![CDATA[<p>  现在微软出了新的跨平台编译器Visual Studio Code，能够横跨Linux、Mac、Windows并在其上面进行web开发，现在ASP.NET已经出到了5.0了而且MVC框架也已近出到6.0.下面我就来写我在Mac上安装Visual Studio Code和与其依赖的环境。</p>

<h2>安装Visual Studio Code</h2>

<p>  可以在<a href="https://code.visualstudio.com/c?utm_expid=101350005-24.YOq70TI1QcW9kAbMwmhePg.2">这里</a>下载Visual Studio Code的安装包，下载到硬盘后把下载的包拖到你机器的Application目录中就安装完成了，现在的最新版本是Visual Studio Code 1.3。
  下载完成后你可以安装相应的扩展（除了第一个强烈要求安装外其余的可以看各自需要）：
  * C# for Visual Studio Code (powered by OmniSharp)(启动VS Code按(⌘+P)快捷键然后复制ext install csharp命令到扩展查询框中接着按enter键。这个扩展提供了高亮语法，Debugging等的支持)
  * Auto Close Tag(安装方法类似上面的)</p>

<h2>安装.NET Core SDK</h2>

<p>  Net Core是什么，其实可以看做是一个所有微软框架的基础，他是.Net Framework和跨平台框架mono(mono其实是更具.Net Framework重新实现的跨平台版本)的基石，以前的.Net Framework框架和mono是两个独立的框架，那么可能有些与跨平台无关的代码重复实现了，现在有Net Core框架，他是所有的微软框架的技术栈，都是依托它搭建起来，当然现在还才开始，Net Core实现的内容还不多，不过微软以后的趋势就是这样的。</p>

<h3>安装.NET Core前必须确保安装了openssl的最新版本，用brew安装可以用以下命令</h3>

<pre><code>    brew install openssl
    brew link --force openssl
</code></pre>

<p>然后在<a href="https://download.microsoft.com/download/0/A/3/0A372822-205D-4A86-BFA7-084D2CBE9EDF/dotnet-dev-osx-x64.1.0.0-preview2-003121.pkg">这里</a>下载安装.NET Core就可以了。</p>

<p><code>注意：如果你安装了oh-my-zsh，你可能会遇到一个错误，安装完.NET Core后它的dotnet命令没有在你的PATH里面，你可以用命令(sudo ln -s /usr/local/share/dotnet/dotnet /usr/local/bin)修复它</code></p>

<h3>现在你可以初始化一些代码了</h3>

<p>用以下命令初始化一个简单的Hello World应用</p>

<pre><code>    mkdir hwapp
    cd hwapp
    dotnet new
</code></pre>

<h3>运行应用程序</h3>

<p>下面的第一个命令将恢复指定在project.json文件中的包，第二个命令将运行实际的项目。</p>

<pre><code>    dotnet restore
    dotnet run
</code></pre>

<h3>你可以创建一个web站点</h3>

<ol>
<li>就利用上面的项目，你可以更新上面的项目的project.json文件，在中间添加一行依赖于Kestrel HTTP服务包，加入后记得运行dotnet restore命令去恢复包，加入后大概类似以下部分。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0-*&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;buildOptions&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;debugType&quot;</span><span class="p">:</span> <span class="s2">&quot;portable&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;emitEntryPoint&quot;</span><span class="p">:</span> <span class="kc">true</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{},</span>
</span><span class='line'>  <span class="nt">&quot;frameworks&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;netcoreapp1.0&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;Microsoft.NETCore.App&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>          <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;platform&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="nt">&quot;Microsoft.AspNetCore.Server.Kestrel&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>      <span class="nt">&quot;imports&quot;</span><span class="p">:</span> <span class="s2">&quot;dnxcore50&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>添加一个Startup.cs(这个文件是所有的web的入口，是必须的)文件去定义请求逻辑，类似以下：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Builder</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Hosting</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Http</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">aspnetcoreapp</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Startup</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">IApplicationBuilder</span> <span class="n">app</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">app</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="n">context</span> <span class="p">=&gt;</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">context</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="s">&quot;Hello from ASP.NET Core!&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>更新修改Program.cs去建立和启动这个Web主机(host):</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Hosting</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">aspnetcoreapp</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebHostBuilder</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseKestrel</span><span class="p">()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;()</span>
</span><span class='line'>                <span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</span><span class='line'>            <span class="n">host</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>运行这个APP(这个dotnet run命令在这个APP有改动的时候自动编译它再运行)</p>

<pre><code> dotnet run
</code></pre></li>
<li><p>在浏览器键入<a href="http://localhost:5000">http://localhost:5000</a>打开这个web网站(你可以用Ctrl+C停止这个服务)</p></li>
</ol>


<h2>利用Yeoman来生成一个项目模板</h2>

<p>Yeoman是一个完整项目生成器，他是一个开源的工具，他可以生成出来像一个Visual Studio项目模板等等。</p>

<h3>安装Yeoman</h3>

<p>首先要安装Yeoman所依赖的Node.js,你可以<a href="https://nodejs.org/en/">这里</a>下载安装Node.js.然后要安装npm,可以在<a href="https://www.npmjs.com">这里</a>下载安装。接下来用npm安装Yeoman,bower,grunt和gulp</p>

<pre><code>    sudo npm install -g yo bower grunt-cli gulp
</code></pre>

<p>安装ASP.NET模板生成器（-g标识是全局生成器，可以再任何路径使用）</p>

<pre><code>    sudo npm install -g generator-aspnet
</code></pre>

<h3>创建一个ASP.NET应用</h3>

<p>键入如下命令</p>

<pre><code>    mkdir src
    cd src
    yo aspnet
</code></pre>

<p>选中Web Application选项按enter，键入项目名字mywebapp,然后键入一下命令</p>

<pre><code>    dotnet restore
</code></pre>

<p>编译和运行可以键入一下命令,其中dotnet build是可选命令，每次运行时都会重新编译一下。</p>

<pre><code>    dotnet build
    dotnet run
</code></pre>

<p>打开浏览器，导航到<a href="http://localhost:5000">http://localhost:5000</a>可以看界面。至此一个简单web站点搭建成功。</p>

<h3>利用yo可以添加类到现存项目中</h3>

<p>进入如下命令</p>

<pre><code>    yo aspnet:Class Person
</code></pre>

<p>结果是一个命名为Person.cs的文件被建立，如下Person:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>
</span><span class='line'><span class="k">namespace</span> <span class="nn">MyNamespace</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="nf">Person</span><span class="p">()</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>扩展</h2>

<p>  ASP.NET 5.0已经正式更名为 ASP.NET CORE,现在都存在于.NET Core SDK中。
  关于Kestrel,它是一个跨平台的web服务是基于<a href="https://github.com/libuv/libuv">libuv</a>的，你添加Kestrel的支持必须添加Microsoft.AspNetCore.Server.Kestrel到你的项目的project.json依赖列表中。Kestrel他是跑到一个代理服务后面的(例如IIS或者Nginx),它自己是不面向网络的，你可以在一个服务中配置代理请求转发到Kestrel处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展App的行为]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/kuo-zhan-appde-xing-wei/"/>
    <updated>2016-07-12T18:30:04+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/kuo-zhan-appde-xing-wei</id>
    <content type="html"><![CDATA[<h1>引言</h1>

<p>此篇文章几乎是对照着Apple文档翻译，某些地方是按照自己理解翻译的，难免有理解和翻译不当的地方，在此告知。</p>

<h1>扩展APP行为</h1>

<p>每一个新的Xcode项目从配置好到马上运行在iOS模拟器或者设备上。但是简单的能够运行在一个设备上并不意味着你的APP准备好传送到APP Store上。每一个APP都需要一定量的定制去确保给用户一个好的用户体验。定制的范围从给APP一个图标到制作一个建筑级别决定你的APP如何去呈现和使用信息。这些定制的行为可以再APP的计划过程中尽早的考虑。</p>

<h1>具体的可以分为以下几项</h1>

<h2>提供所需的资源</h2>

<h3>你创建每一个APP都必须有接下来的资源集合和元数据如此它才能正确的显示在设备上。</h3>

<ol>
<li>一个信息属性列表文件。这个Info.plist文件包含了你的APP的元数据，系统使用这些信息去和你的APP交互。Xcode会自动的基于你的项目的配置和设置创建这个文件。如果你想直接的查看或者修改这个内容，你能操作你的项目的Info选项卡。</li>
<li>一个APP所需能力的声明。每一个APP必须声明它运行时所需要的硬件能力或者特性.APP Store使用这个信息确定是否能够在一个特定的设备上运行你的APP。你能够在Info选项卡的"Required device capabilities"条目上编辑你的APP需要量列表。</li>
<li>一个或者多个图标。系统在用户设备主屏幕上显示的你的APP的图标。系统可能显示在设置应用上或者一个查询结果上使用的是你图标其他的版本。</li>
<li>一个或者多个启动图片。当一个APP启动时，系统显示一个临时的图片直到这个APP能够呈现它的用户界面为止。这个临时的图片是你的APP的 启动图片他提供给用户及时的反馈你的APP是正在启动和将要马上准备好了。你必须提供至少一个启动图片，你可能提供了额外的启动图片去解决不同的场景。</li>
</ol>


<p>以上的这些资源是所有的APP必须的但是你包含的应该不仅仅是这些资源。有更多的键Xcode默认没有包含在你的APP的Info.plist文件中。更多额外的键仅仅是当你的APP包含了特定的特性时加入。</p>

<h1>APP包(Bundle)</h1>

<p>当你建立你的APP的时候，Xcode包装它作为一个包(Bundle).一个包(Bundle)在文件系统中是一组相关的资源放在一个地方的目录。一个iOS App包(Bundle)包含一个APP执行文件和所支持的资源文件例如应用程序图标，图片文件，和本地化内容。</p>

<h1>支持用户隐私</h1>

<p>当你设计你的APP的时候保护用户隐私应该作为一个重要考虑。大部分iOS设备包含了用户和设备数据用户可能不想暴露这些数据到应用和外部实体。请记住如果你用一个不恰当的方法去使用数据用户可能会删除你的APP。
访问用户或者设备数据仅仅是当用户了解同意并和适当的法律一致时。另外，采取适当的步骤去保护用户和设备数据清晰的告诉用户你要如何使用这些数据。你可以采用下面的一些好的实践。</p>

<ol>
<li>可以和公司的法律顾问一起看一些来自政府或者行业关于保护移动用户隐私的文档。</li>
<li>请求访问用户或者设备数据有时候是需要的，这个数据是受iOS系统授权设置保护的。考虑在你的Info.plist文件里供应一个用法描述字符串用来解释为什么APP需要用到这个数据。受iOS系统授权设置保护的数据包含位置数据，联系人，日历事件，备忘录，照片和媒体。</li>
<li>明确的告诉用户你将要如何去使用这些数据。</li>
<li>给用户控制这些用户和设备数据。提供设置如此用户能够禁止访问某些需要的敏感数据。</li>
<li>请求使用需要的最少量的用户或者设备数据去完成一个给定的任务。如果不明显的原因或者不必要的原因或者因为你觉得这些数据以后会有用等等这些情况都不要去访问查寻或者收集数据。</li>
<li>采用合理的步骤去保护收集在你的APP中的用户和设备数据。当存储这些信息在本地时，尝试使用iOS数据保护特性 (described in Protecting Data Using On-Disk Encryption)去存储它为一个加密的格式。当你要经过网络发送用户或者设备数据时尝试采用HTTPS连接。</li>
<li>如果你的APP使用了ASIdentifierManager类，你必须考虑它的advertisingTrackingEnabled属性值。如果用户设置这个属性值为NO，使用这个类仅仅是有限的广告目的。</li>
<li>如果你还没有这么做得话，停止使用UDID。这个属性在iOS 5.0已经废弃了。App Store不接受新的APP或者APP更新使用这个标识。作为替代，ASIdentifierManager类的advertisingIdentifier属性是适合的。</li>
<li>如果你的APP支持音频输入，那么仅仅在你实际上计划要开始录音的地方配置你的录音回话（audio session）。如果你没有计划立即录音不要在启动的时候配置你的录音回话（audio session）。在iOS7中，当APP配置他们的录音的录音回话（audio session）时系统会提醒用户，并给用户一个禁用录音的选项。</li>
</ol>


<h1>APP国际化</h1>

<p>因为APP分布在许多的国家，本地化你的APP能帮助你联络到更多的用户。当APP被本地化为他们的母语时，更多的用户可能会使用这个APP。当你把面向用户的内容作为因素插入到资源文件时，本地化这个内容是一个相对简单的过程。
在你可能本地化你的内容以前，你必须使你的APP国际化这样是为了便利本地化的过程。国际化APP牵涉的因素有任何面向用户的内容插入到本地化的资源文件和提供存储内容特定语言项目目录。当使用特定语言和特定地区内容工作时它同样意味着使用恰当的技术（例如时间和数字格式化）
一个完全国际化的APP，本地化过程创建一个新的特定语言资源文件添加到你的项目。一个典型的iOS应用需要接下来这些资源文件类型的本地化版本。</p>

<ol>
<li>Storyboard文件(或者nib文件)-Storyboard能包含文本标签和另外的需要本地化的内容。你可能同样想调整界面项的位置去适应文本长度的改变。（同样的，nib文件能包含你需要本地化的文本或者你需要去更新的布局）</li>
<li>Strings文件-Strings文件（如此命名是因为他们的.strings文件名扩展）包含你的APP显示的静态文本的本地化版本。</li>
<li>Image文件-你应该避免本地化图片除非图片包含了特定的文化内容。在任何时候，你应该避免直接的存储文本在你的图片文件里面。从你的APP里面加载和使用图片，存储文本到一个strings文件，在运行时，把文字内容和图片内容整合在一起。</li>
<li>录像和录音文件-你应该避免本地化多媒体文件，除非他们包含了特定语言或者特定文化的内容。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APP生命周期与后台执行]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/appsheng-ming-zhou-qi-yu-hou-tai-zhi-xing/"/>
    <updated>2016-07-12T18:20:42+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/appsheng-ming-zhou-qi-yu-hou-tai-zhi-xing</id>
    <content type="html"><![CDATA[<h1>引言</h1>

<p>此篇文章几乎是对照着Apple文档翻译，某些地方是按照自己理解翻译的，难免有理解和翻译不当的地方，在此告知。</p>

<h1>APP生命周期（The App Life Cycle）</h1>

<p>APP是在你的自定义代码和系统框架中间复杂的相互作用。这个系统框架提供了所有的APP运行需要的基础结构，你提供的代码需要去定制这个结构和给APP一个样子和你想要的感觉。有效的做这个，它帮助你了解一点点关于iOS的结构和它如何工作的
iOS框架依赖于设计模式，例如MVC和代理在他里面的实现。了解这些设置模式是成功创建一个APP的关键。他同样帮助你熟悉objective-c语言和它的特性。</p>

<h1>APP的结构（The Structure of an App）</h1>

<p>在启动的时候，这个UIApplicationMain函数建立几个关键的对象和开始这个APP运行。每一个APP的核心是UIApplication对象，它的工作是在APP中去便利系统和另外对象的交互。iOS应用都采用了mvc结构，这个模式用来数据视觉呈现时的数据和业务逻辑的分离。这个是去创建APP运行在不同的设备的不同屏幕尺寸上的关键结构。</p>

<h2>iOS应用中各个对象的角色</h2>

<h3>UIApplication对象</h3>

<p>UIApplication对象管理事件的循环和另外的高等级的行为。它同样传达关键的APP迁移和一些特定的事件（例如正到来的推送通知）给它的代理。</p>

<h3>App delegate对象</h3>

<p>这个App delegate是你自定义代码的核心。这个对象和UIAplication对象协力去操作APP的初始化，状态迁移，和许多高等级APP事件。这个对象同样保证在每一个APP中仅仅一个，如此它通常用来建立APP的初始数据结构。</p>

<h3>Documents和data model对象</h3>

<p>Data model对象存储了你的APP内容并且是特定于你的APP的。APP能同样使用document对象（自定义UIDocument子类）去管理一些或者所有的他们的data model对象。Document对象不是必须的，但是它提供一种方便的方法去组织你的数据到一个单个的文件或者文件包中。</p>

<h3>View controller</h3>

<p>UIViewController是所有View controller对象的基类。它提供了默认的功能关于加载视图，呈现他们，旋转他们去响应设备的旋转，和几个另外的标准的系统行为。UIKit和另外的框架定义了额外的View controller类去实现标准的系统界面，例如图片选择器（image picker），tab bar界面和导航界面。</p>

<h3>UIWindow对象</h3>

<p>UIWindow对象协调一个或多个视图的显示。大部分的APP只有一个window，它在主屏幕上呈现内容，但是APP可能有一个额外的视图关于显示内容到一个外部的显示。
去改变你的APP的内容，你使用view controller去改变视图在相应的window里的显示。你永远不可能替换window本身。
除了承载视图，Windows和UIApplication一起工作去交付事件给你的视图和view controllers。</p>

<h3>View对象，control对象和layer对象</h3>

<p>Views和controls提供你的APP的内容的视觉表现。一个view是一个对象，它绘制内容在一个指定的矩形区域，响应这个指定的矩形区域中的事件。Controls是一个专门的view类型，负责实现熟悉的界面对象，例如buttons、text field和toggle switches。</p>

<h1>APP执行状态（Execution States for Apps）</h1>

<p>在任何一个给定的时刻，你的APP都是在下面的任意一个状态。系统在整个系统运行期为了响应动作的发生去迁移你的APP从一个状态到另外一个状态。例如用户按了home键，一个电话打进来或者任何几个其他的中断发生，当前运行的APP响应后去改变自己的状态。一下是一些APP各状态描述。</p>

<h2>没有运行（Not running）</h2>

<p>这个APP没有启动或者在运行但是通过启动终结了。</p>

<h2>未活动（Inactive）</h2>

<p>这个APP运行在前台但是现在不接受事件。（它可能执行另外的代码）一个APP通常只停留在这个状态一瞬间然后他迁移到不同的状态。</p>

<h2>活动(Actice)</h2>

<p>APP运行在前台并且接受事件。这个是一个前台APP标准的模式。</p>

<h2>后台（Background）</h2>

<p>APP后台和执行代码，大部分APP进入这个转态一瞬间就被系统挂起。无论如何，一个APP请求一个额外的执行时间能够保持在这个状态一段时间。另外，一个APP启动时直接进入后台状态而不是未活动（Inactive）状态.</p>

<h2>挂起（Suspended）</h2>

<p>APP进入后台但是没有执行代码，系统自动移动APP到挂起状态并且做这个的时候没有通知。在挂起的期间，APP保持在内存里但是不执行任何代码。
当一个低内存状况发生，系统可能净化挂起的APP去制造更多的空间给前台APP并且做这个的时候没有通知。
大部分的状态迁移都伴随着APP代理方法的调用。这些方法是给你机会用一些适当的方式去响应状态的改变。以下是这些方法的列表。</p>

<h3>application:willFinishLaunchingWithOptions:</h3>

<p>这个方法是在APP启动时第一次机会去执行代码。</p>

<h3>application:didFinishLaunchingWithOptions:</h3>

<p>这个方法是你的APP显示给用户之前运行你执行任何最终的初始化处理。</p>

<h3>applicationDidBecomeActive:</h3>

<p>让你知道你的APP已经变为了前台APP。这个方法给你最后一分钟的准备。</p>

<h3>applicationWillResignActive:</h3>

<p>让你知道你的APP将迁移离开前台APP，使用这个方法把你的APP变为一个静态状态。</p>

<h3>applicationDidEnterBackground:</h3>

<p>让你知道你的APP现在运行在后台状态并且随时可能挂起。</p>

<h3>applicationWillEnterForeground:</h3>

<p>让你知道你的APP已经移动退出了后台状态和返回进入了前台，但是这个还不是活动的状态。</p>

<h3>applicationWillTerminate:</h3>

<p>让你知道你的APP开始终结。如果你的APP挂起了，那么不会调用这个方法。</p>

<h1>后台执行（Background Execution）</h1>

<p>当用户没有积极的使用你的app时，系统会移动这个app到后台状态，许多的APP，在后台状态事实是驻留一瞬间就被系统迁移到挂起状态了。挂起APP这个做法是为改善电池寿命和把系统的重大资源用于新的前台APP以用于吸引用户的手段。
大部分的APP能够相当容易的迁移到挂起状态但是也同样有正当的持续在后台运行的理由。例如一个徒步旅行APP可能想要追踪用户在任何时间的位置这样能够显示航线在徒步旅行地图上面。一个音频APP可能需要在锁屏的时候继续播放音乐。另外一些APP可能需要在后台下载内容如此它能以最小的延迟展现这个内容给用户。当你认为需要你的APP能够在后台运行，iOS帮助你有效的做这些并不耗尽系统资源和用户电池。这个技术通过iOS分成三类提供。</p>

<ol>
<li>APP在前台启动一个短的任务，当APP迁移到后台时能够请求时间去结束这个任务。</li>
<li>APP在前台开始下载能够挪动那些下载的管理给系统管理，从而在下载期间允许APP挂起或者终结。</li>
<li>APP需要在后台运行指定的任务类型，可以声明他们要支持的一个或者多个后台任务模式。</li>
</ol>


<p>总是试图去避免做任何后台工作，除非这么做能够改善整体的用户体验。一个APP迁移到后台的可能的原因有用户启动了一个不同的APP或者因为用户锁定了设备和此时没有使用这个APP.在这两种情况，用户此时不需要你的APP做任何有意义的工作。在这样的条件下继续运行你的APP仅仅是耗尽电池和可能导致用户去强制完全退出你的APP。如此记住在后台你做的工作当你能避免的时候避免。</p>

<h1>执行有限长度的任务（Executing Finite-Length Tasks）</h1>

<p>APP迁移到后台是预期把自己尽可能快的进入到一个静止的转态，如此系统能够暂停他们。如果APP是在一个任务运行的中间和需要一点时间去完成这个任务，它能够调用UIApplication对象的 beginBackgroundTaskWithName:expirationHandler: 或者beginBackgroundTaskWithExpirationHandler:方法去请求一些额外的执行时间。调用这两个方法中的任何一个都可以暂时去延迟你的APP的挂起，给它一点额外的时间去结束这个工作。到这个工作完成的时候，你的APP必须调用endBackgroundTask:方法去让系统知道任务结束了系统能够挂起这个APP了。
每次调用beginBackgroundTaskWithName:expirationHandler: 或者beginBackgroundTaskWithExpirationHandler:方法生成一个唯一的令牌（token）去关联相应的任务。但你的APP完成了一个任务的时候，它必须用相应任务的令牌（token）作为参数去调用endBackgroundTask:方法去让系统知道这个任务完成了。失败去调用endBackgroundTask:方法关于一个后台任务将导致你的应用程序终结。当开始这个任务如果你提供了一个到期终止处理（expiration handler）,这个系统调用这个到期终止处理（expiration handler）给你一个最后的机会去结束任务和避免APP终结。
你不需要去等到你的APP迁移到后台的时候再去指派后台任务。开始一个任务之前，一个更有用的设计是调用beginBackgroundTaskWithName:expirationHandler: 或者 beginBackgroundTaskWithExpirationHandler:方法。等到你的任务结束就调用endBackgroundTask:方法。</p>

<p>在你自己的到期终止处理（expiration handler）中，你能够包含额外的需要去关闭你的任务的代码。你包含的任何代码不能拿太长时间去执行，因为到你调用到期终止处理（expiration handler）时候，你的APP已经很靠近它的时间限制了。因为这个原因，仅仅执行极少的你的状态信息的清理和结束这个任务。</p>

<h1>在后台下载内容（Downloading Content in the Background）</h1>

<p>但下载文件时，APP应该使用一个NSURLSession对象去开始一个下载，如果这个APP挂起或者终结此时系统能拿到这个下载处理的控制。当你配置一个NSURLSession对象作为后台传输用，系统在一个独立的处理里面管理那些传输和以通常的方式报告状态给你的APP。当以传输在进行期间如果你的APP终结了，系统在后台继续这个传输，当这个传输结束或者当一个或多个任务需要你的APP的注意，启动这个APP（当适当的时候）。
去支持后台传输，你必须适当的配置你的NSURLSession对象，去配置这个回话（session），你必须首先创建一个NSURLSessionConfiguration对象和设置这个对象的几个属性到适当的值。当创建这个回话（session）的时候，你接着传递那个配置对象到NSURLSession的适当的初始化方法。</p>

<p>创建支持后台下载配置对象的过程如下：</p>

<ol>
<li>使用NSURLSessionConfiguration的 backgroundSessionConfigurationWithIdentifier: 方法创建配置对象。</li>
<li>设置配置对象的sessionSendsLaunchEvents属性值为YES.</li>
<li>如果你的APP在前台期间启动的下载，推荐你同样设置配置对象的discretionary属性值为YES。</li>
<li>配置这个配置对象任何其他的属性值到适当的值。</li>
<li>使用这个配置对象去创建你的NSURLSession对象。</li>
</ol>


<p>一单配置，你的NSURLSession对象在适当的时候无缝移交这个上传和下载任务给系统。在APP仍然在运行的时候如果你的任务结束（前台和后台任其一的状态），这个回话（session）对象以通常的方式通知它的代理（delegate）。如果这个任务尚未完成此时系统终结了你的APP，这个系统自动的在后台继续管理这个任务。如果用户终结了你的APP，系统取消所有的待执行的任务。</p>

<h1>实现长运行任务（Implementing Long-Running Tasks）</h1>

<p>对于需要更多执行时间去实施的任务，你必须请求指定的许可（specific permissions ）在后台去运行他们，没有他们APP在后台会被暂停。iOS中，只有特定的APP类型能被允许在后台运行：</p>

<ol>
<li>在后台播放有声音的内容给用户的APP，例如音乐播放APP。</li>
<li>在后台录制音频内容的APP。</li>
<li>让用户随时了解他们的位置的APP，例如导航APP。</li>
<li>支持VoIP（Voice over Internet Protocol）的APP。</li>
<li>接收来自外部附件定期更新的APP。</li>
</ol>


<p>实现这些服务（services）的APP必须声明相应的服务，他们支持和使用系统框架去实现那些服务相关的方面。声明服务让系统知道你使用了哪一种服务，但在某些情况下，系统框架实际阻止了你的APP被暂停。</p>

<h2>声明你APP支持的后台任务（Declaring Your App’s Supported Background Tasks）</h2>

<p>支持一些后台执行类型必须通过你的APP提前声明使用它们。在Xcode5以后，你在你项目设置的“Capabilities”标签中声明你的APP所支持的后台模式。启用这个后台模式选项添加UIBackgroundModes键到你的APP的Info.plist文件中。选择一个或者多个检验盒（checkboxes ）添加相应的后台模式值到该键。你能指定以下的后台模式，Xcode会分配这个值到你的APP的Info.plist文件的UIBackgroundModes键中。</p>

<ol>
<li>Audio和AirPlay。</li>
<li>位置更新</li>
<li>VoIP(Voice over IP)</li>
<li>Newsstand下载。</li>
<li>外部附近通信。</li>
<li>使用蓝牙LE附件。</li>
<li>Acts as a Bluetooth LE accessory。</li>
<li>后台拉取。</li>
<li>远程通知。</li>
</ol>


<p>每一个前面的模式让你的系统知道你的APP应该在适当的时间唤醒或者启动去相应相关的事件。</p>

<h1>在后台获得用户的注意（Getting the User’s Attention While in the Background）</h1>

<p>通知是一个当你的APP挂起、在后台或者没有运行需要获得用户注意的方式。APP能够使用本地通知去显示通告，播放声音，以APP的图标为徽章显示，或者这三个的组合。
排定一个本地通知的交付，创建一个UILocalNotification类的实例，配置这个通知的参数，使用UIApplication类的方法计划他。</p>

<h1>选择退出后台执行</h1>

<p>如果你不想要你的APP在任何时候运行在后台，你能够通过添加UIApplicationExitsOnSuspend键（设置值为YES）到你的APP的Info.plist文件来明确的选择退出后台。当一个APP是这样设置的，它将循环在没有运行（not-running），未活跃的（inactive），和活跃（active）状态之间，并且从不进入后台或者挂起状态。当用户按了Home键去退出这个APP，这个APP的代理方法 applicationWillTerminate:会被调用，他终结以前APP大约有五秒时间去清理和退出，迁移到没运行（not-running）的状态。
选择退出后台执行时强烈反对的，但是可能在一定条件下是首选的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins+fastlane持续集成]]></title>
    <link href="http://liuhaoxiu.github.io/blog/2016/07/12/jenkins-plus-fastlanechi-xu-ji-cheng/"/>
    <updated>2016-07-12T16:04:39+08:00</updated>
    <id>http://liuhaoxiu.github.io/blog/2016/07/12/jenkins-plus-fastlanechi-xu-ji-cheng</id>
    <content type="html"><![CDATA[<h1>iOS持续集成</h1>

<p>用Jenkins配置job,在合适的时机自动触发从git上拉取最新代码、自动构建、自动运行Test最后通过slack通过发送通知形式把结果反馈给team成员。</p>

<h2>安装工具</h2>

<ol>
<li>更新brew包管理工具
$ sudo brew update</li>
<li>安装jenkins
$ sudo brew install jenkins</li>
<li>安装fastlane
$ sudo gem install fastlane</li>
<li>安装fir-cli
$ sudo gem install fir-cli</li>
</ol>


<p>brew error
You can use brew with sudo, but only if the brew executable is owned by root.
However, this is both not recommended and completely unsupported so do so at
your own risk.
解决
$ sudo chown -R root /usr/local
参考：<a href="http://raiko.in/tech/homebrew-cant-sudo/"></a>
<a href="http://lyo.is-programmer.com/posts/39956.html"></a></p>

<p>根证书过期，下载重新安装:
<a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer">根证书下载</a></p>

<h2>fastlane自动构建、自动测试等等</h2>

<ul>
<li>cd [your_project_folder]</li>
<li>fastlane init</li>
<li>Follow the setup assistant, which will set up fastlane for you</li>
<li>Edit Fastfile
<code>``
fastlane_version "1.81.0"
default_platform :ios
platform :ios do
before_all do
   ENV["SLACK_URL"] = "https://hooks.slack.com/services/..."
  #cocoapods
  #increment_build_number
  cocoaPods
  xcodebuild(workspace: "LHAlertCustomViewDevApp.xcworkspace",scheme: "LHAlertCustomViewDevApp",sdk: "iphonesimulator",destination: "platform=iOS Simulator,name=iPhone 6s")
  #gym(workspace: "LHAlertCustomViewDevApp.xcworkspace")
end
desc "Runs all the tests"
lane :test do
  xctest(scheme: "LHAlertCustomViewDevApp",destination: "platform=iOS Simulator,name=iPhone 6s",
    reports: [
      {
        report: "html",
        output: "build/reports/unit-tests.html"
      },
      {
        report: "junit",
        output: "build/reports/unit-tests.xml"
      }
    ],
    clean: nil)
  #scan
end
desc "Submit a new Beta Build to Apple TestFlight"
desc "This will also make sure the profile is up to date"
lane :beta do
  # match(type: "appstore") # more information: https://codesigning.guide
  #gym # Build your app - more options available
  #pilot
  # sh "your_script.sh"
  # You can also use other beta testing services here (run</code>fastlane actions`)
end
desc &ldquo;Deploy a new version to the App Store&rdquo;
lane :appstore do

<h1>match(type: &ldquo;appstore&rdquo;)</h1>

  # snapshot
  #gym # Build your app - more options available
  #deliver(force: true)
  # frameit
end

<h1>You can define as many lanes as you want</h1>

after_all do |lane|
  # This block is called, only if the executed lane was successful
   slack(
     message: &ldquo;Successfully test new App Update.&rdquo;
   )
end
error do |lane, exception|
   slack(
     message: exception.message,
     success: false
   )
end
end
```
在终端输入fastlane test测试自动构建，自动测试是否成功,也可以用xtool来构建和测试工程。

<h2>fir-cli</h2></li>
<li>进入slack.com注册自己的账号，可以自己创建team，也可以加入别的team。</li>
<li>进入<a href="https://ajiosteam.slack.com/services/B0ZRJH8UU?added=1%E7%94%9F%E6%88%90SLACK_URL%E3%80%82">https://ajiosteam.slack.com/services/B0ZRJH8UU?added=1%E7%94%9F%E6%88%90SLACK_URL%E3%80%82</a></li>
<li>设置Fastfile中的slack地址。</li>
</ul>


<h2>jenkins配置</h2>

<ol>
<li>创建job</li>
<li>打开<a href="http://localhost:8080">本地</a></li>
<li>Manage Jenkins > Manage Plugins > Available 安装插件

<ul>
<li>HTML Publisher Plugin</li>
<li>AnsiColor Plugin</li>
<li>Rebuild Plugin</li>
<li>GIT Plugin</li>
</ul>
</li>
<li>上一步结束点击 Back to Dashboard > New Item > 键入Item name > 选择Freestyle project > ok</li>
<li>配置job
<code>
 Source Code Management：/Users/liuhao/Documents/gittest/LHAlertCustomView
 Branches to build：*/master
 Add build step &gt; Execute shell
 Command:
 #!/bin/bash
    source ~/.bash_profile
    cd LHAlertCustomViewDevApp/
    fastlane test
    or
    #!/bin/bash
  export LC_ALL="en_US.UTF-8"
  fastlane test
</code>

<ul>
<li>Save job</li>
</ul>
</li>
<li>自动job

<ul>
<li>Build Triggers > Build periodically
<code>
在每周的工作日的每小时的前半个小时，每过十分钟触发一次
H(0-29)/10 * * * 1-5
</code></li>
</ul>
</li>
</ol>


<h2>参考</h2>

<p><a href="https://github.com/fastlane/fastlane">fastlane</a><br/>
<a href="https://github.com/fastlane/fastlane/blob/master/docs/Jenkins.md">Jenkins Integration</a></p>

<h2>Note</h2>

<h1>error:</h1>

<p>修改文件为可读可写：
<string>&ndash;httpListenAddress=0.0.0.0</string>替换<string>&ndash;httpListenAddress=127.0.0.1</string>
sudo chmod 666  ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</p>

<p>Mac-mini:~ dongmeiliang$ sudo chmod o-w /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Password:
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: Path had bad ownership/permissions
Mac-mini:~ dongmeiliang$ sudo chmod g-w /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded
Mac-mini:~ dongmeiliang$ sudo chmod o-w ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded
Mac-mini:~ dongmeiliang$ vim ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ vim /usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist
Mac-mini:~ dongmeiliang$ clear
Mac-mini:~ dongmeiliang$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist
/usr/local/Cellar/jenkins/1.643/homebrew.mxcl.jenkins.plist: service already loaded</p>

<h2>注意</h2>

<p>如果fastlane编译测试成功
但Jenkins运行编译成功测试失败并报
或者：invalid byte sequence in US-ASCII (ArgumentError)[0m</p>

<p>timeout connect(2)只是以上错误引起的。</p>

<p>可以fix错误
    export LC_ALL=&ldquo;en_US.UTF-8"写到你的shell里面</p>

<pre><code>There are two ways to fix this. You can export language settings to your shell:
</code></pre>

<p>1：不推荐，这样会修改整个系统的设置。
export LANGUAGE=en_US.UTF-8
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
or you can put this into your Gemfile:
2：推荐这个 you can put this into your Gemfile:（可以把一下代码加到你的Gemfile的头部）
if RUBY_VERSION =~ /1.9/
  Encoding.default_external = Encoding::UTF_8
  Encoding.default_internal = Encoding::UTF_8
end
提醒：可以免密码登录
The authorized_keys file corresponds to the conventional ~/.rhosts file, and has one key per line, though the lines can be very
     long.  After this, the user can log in without giving the password</p>
]]></content>
  </entry>
  
</feed>
